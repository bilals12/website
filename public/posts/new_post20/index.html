<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000000" />

    <meta name="description" content="advanced evasions, part 1: PE maps &#43; custom minidumpers">

    
        <title>advanced evasions, part 1: PE maps &#43; custom minidumpers | à¼§</title>
    

    
    <link rel="stylesheet" type="text/css" href="/style.min.6f40ec7b8baa6b4858deb6d2433606e0c74c60aa022d42f0d84457862cc005f3.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/about/">about</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/cv/">cv</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/posts/">posts</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/photography/">photography</a></li>
            
          </ul>
        </nav>
        



<div id="single-header">
  <h1>
    advanced evasions, part 1: PE maps + custom minidumpers
  </h1>
  <div id="single-meta">
    
    
        <span class="datesub">jan 7, 2024 &nbsp;&nbsp; m. jan 29, 2024</span>
      

  </div>
</div>



<aside class="toc" id="tableOfContentContainer">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#avedr">AV/EDR</a></li>
    <li><a href="#avedr--minidumps">AV/EDR + minidumps</a></li>
    <li><a href="#custom-minidumpers">custom minidumpers</a></li>
    <li><a href="#minidumpers-the-boring-stuff">minidumpers: the boring stuff</a></li>
    <li><a href="#advanced-minidump-techniques">advanced minidump techniques</a></li>
    <li><a href="#pe-portable-executable">PE: Portable Executable</a></li>
    <li><a href="#pe--minidumpers">PE + minidumpers</a>
      <ul>
        <li><a href="#mapping-out-the-pe-format-in-rust">mapping out the PE format in Rust</a></li>
        <li><a href="#code">code</a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>


<main><p>imagine if your computer kept a journal. a journal not merely consisting of poetic silicon muses, but moment-by-moment accounts of all its inner workings. these journals exist, and they&rsquo;re called <strong>minidumps</strong>. minidumps are compact snapshots of a computer&rsquo;s memory, and they capture the essence of what&rsquo;s happening inside your machine at any given moment.</p>
<p><p class="imgp">
  <img loading="lazy" src="/bluescreenview.gif" alt="bluescreenview"  />
</p>
</p>
<p><p class="imgp">
  <img loading="lazy" src="/bluescreenview2.gif" alt="bluescreenview"  />
</p>
</p>
<p>to the unitiated (or uninterested), minidumps would just look like cryptic glyphs, with maybe a vague understanding that these glyphs represent something &ldquo;important&rdquo;. indeed, minidumps are extremely valuable, and at the heart of a hidden conflict inside the digital world: they&rsquo;re prized by software engineers hunting elusive bugs, revered by security/forensics experts trying to track down phantoms, and eyed warily by the very security systems designed to protect your computer.</p>
<p>think of your computer as if it were a bustling city, with programs + data zipping along like vehicles + people. a <strong>minidump</strong> is akin to a <strong>CCTV camera</strong> on a street corner that can freeze a moment in time, capturing everything in its view. now, imagine if someone could use that frozen image to understand traffic patterns, spot accidents before they&rsquo;ve happened, or even identify &ldquo;troublemakers&rdquo;.</p>
<p>here&rsquo;s where it gets interesting. just as a city might restrict where cameras can be placed, to protect residents&rsquo; privacy, your computer has security systems that keep an eye on who&rsquo;s taking these memory snapshots and why. it&rsquo;s a delicate balance between the need for insight and the demand for security.</p>
<h2 id="avedr">AV/EDR</h2>
<p>most of us have had experience use AV (<strong>antivirus</strong>) tools in the past. EDR (<strong>endpoint detection + response</strong>) systems are an extension of traditional AVs, in that they have a heightened level of access to the underlying OS and, in some cases, even the kernel. i won&rsquo;t bore you too much with how exactly EDRs work, but there are some important points to remember:</p>
<ol>
<li>
<p>EDRs use <strong>behavioural</strong> analysis to detect threats, while AVs traditionally rely on signature matching.</p>
</li>
<li>
<p>EDRs leverage AI/ML for more sophisticated threat (<strong>0-day</strong>) detection + automated response capabilities.</p>
</li>
<li>
<p>EDRs provide <strong>continuous, real-time monitoring</strong> of endpoints and their activites.</p>
</li>
</ol>
<h2 id="avedr--minidumps">AV/EDR + minidumps</h2>
<p><p class="imgp">
  <img loading="lazy" src="/edrminidump.png" alt="edrminidump"  />
</p>
</p>
<p>creating minidumps that won&rsquo;t trigger native security systems is of paramount importance to EDRs. to do this, many EDRs (and even some AVs) use <strong>custom minidumpers</strong> to capture specific memory regions of interest when a suspicious event occurs.</p>
<p>take the crudely illustrated example above. the entire process is enclosed within the EDR&rsquo;s system, and starts at <strong>minidump creation</strong>, where the EDR creates memory snapshots of running processes. these minidumps are then sent to the <strong>analysis engine</strong>, which examines the contents of the dumpfile for signs of malicious activity. the <strong>threat detection</strong> component receives these analysis results and <strong>identifies</strong> potential threats, based on the ruleset that it was fed during the design process.</p>
<p>as you can see, this is a cyclical process: continuous monitoring feeds back into the minidump creation, and so on. but how exactly do EDRs achieve this?</p>
<h2 id="custom-minidumpers">custom minidumpers</h2>
<p>EDRs have a vested interest in monitoring + controlling minidump creation. since minidumps contain snapshots of process memory, EDRs need to be able to prevent unauthorized data extraction, credential harvesting (like dumping <code>lsass.exe</code>), and attacks like process injection. this is done by EDRs leveraging <strong>custom minidumpers</strong>. ironically, attackers use <strong>custom minidumpers</strong> to evade detection and make reverse engineering malware more convoluted, but more on that later.</p>
<p>basically, everything malware might use custom minidumpers for is used by EDRs to foil it in the first place.</p>
<p>let&rsquo;s look at <strong>memory forensics</strong>, for example. custom minidumpers are used to capture specific memory regions, which is crucial for gathering IoCs and analyzing malware behaviour <strong>in-memory</strong> (while it&rsquo;s running in RAM as opposed to being stored as a static file on disk; this is also incredibly helpful for <a href="https://intezer.com/blog/incident-response/memory-analysis-forensic-tools/**"  target="_blank" rel="noreferrer nofollow">fileless malware</a>
).</p>
<ul>
<li>some more ways custom minidumpers are used by EDRs:</li>
</ul>
<ol>
<li>
<p>optimizing egress bandwidth + reducing system overhead during analysis.</p>
</li>
<li>
<p>identifying memory regions where malware attempts to hide (code injection, process hollowing).</p>
</li>
<li>
<p>capturing kernel-mode memory regions for rootkit analysis (driver-based malware, malicious kernel mods).</p>
</li>
</ol>
<p>if you haven&rsquo;t already guessed, i&rsquo;m going to be creating my own custom minidumper to see if i can exploit some EDR blindspots! now, let&rsquo;s dive into some technical details about minidumpers.</p>
<h2 id="minidumpers-the-boring-stuff">minidumpers: the boring stuff</h2>
<p>minidumps are typically stored as binary files with a structd format, often with the <code>.dmp</code> extension on Windows systems, and they contain a curated subset of the full process memory:</p>
<ol>
<li>
<p>critical memory regions, like stacks + heaps.</p>
</li>
<li>
<p>system + process information: this includes the <strong>process ID</strong> (identifying the specific process that the dump belongs to), <strong>timestamp</strong> (for correlating with system events + logs), <strong>OS version</strong>, and <strong>CPU architecture</strong>.</p>
</li>
<li>
<p>thread contexts (register states): provide snapshots of CPU registers for each thread (get exact state of execution), <strong>thread stacks</strong> (call history + local variables), <strong>thread-local storage</strong> (holds thread-specific data, analyzing <strong>thread isolation</strong> and potential <strong>race conditions</strong>)</p>
</li>
<li>
<p>loaded module details: identifying potential malicious injections, version conflicts, and provides the basis for symbol resolution during analysis.</p>
</li>
<li>
<p>exception information (if triggered by an exception): exception code, exception address, exception parameters, first-chance/second-chance status.</p>
</li>
<li>
<p>memory regions: stack memory for each thread, selected heap regions.</p>
</li>
<li>
<p>handle information: open handles (resources currently in use by process), handle types + permissions.</p>
</li>
<li>
<p>system information.</p>
</li>
</ol>
<h2 id="advanced-minidump-techniques">advanced minidump techniques</h2>
<p>advanced techniques for minidump creation go beyond standard API calls. the goal is to procure greater control, evasion capabilities, with full customization. let&rsquo;s take a look at some of them.</p>
<p><strong>direct memory access</strong>: use low-level memory access functions like <code>ReadProcessMemory</code>. this bypasses higher-level APIs that may be hooked or monitored. it allows for selective memory capture (evading detection), but requires a pretty thorough understanding of the memory layout + protection mechanisms.</p>
<p><strong>PEB parsing</strong>: directly accessing + parsing the PEB (<strong>Process Environment Block</strong>) struct. this also avoids easily-monitored APIs, and reveals information about loaded modules that might be hidden from standard APIs.</p>
<p><strong>custom thread enumeration</strong>: use low-level APIs like <code>NtQuerySystemInformation</code> or parsing the kernel structs directly. this can reveal hidden or injected threads.</p>
<p><strong>manual stack walking</strong>: implementing custom stack walking algorithms use architecture-specific techniques. this can allow for custom filtering + analysis, bypassing debugger APIs that may be detected or hooked.</p>
<p><strong>kernel-mode dumping</strong>: creating minidumps from kernel mode by use a custom driver. this allows us to dump protected process and bypass user-mode restrictions + detections.</p>
<p><strong>in-memory dump creation</strong>: creating dumps entirely in-memory without writing to disk. this is crucial if you want to avoid leaving artifacts on disk that can be detected, but you need custom analysis tools along with careful memory management to handle potentially large dumps.</p>
<p><strong>selective component dumping</strong>: creating highly targeted dumps, and significantly reducing dump size + creation time.</p>
<p><strong>encryption + obfuscation</strong>: evading signature-based detection of dump files by encrypting the dump data during or immediately after creation.</p>
<p>as you might have guessed, there are many different ways of leveraging custom minidumpers to dump <code>lsass.exe</code>. for this project, however, i&rsquo;m going to start with understanding + mapping the <strong>portable executable</strong>.</p>
<h2 id="pe-portable-executable">PE: Portable Executable</h2>
<p><strong>PE</strong> is a file format used in Windows for executables, object code, and <strong>dynamic link libraries</strong> (DLLs). simply put, it&rsquo;s the standard format for binary programs on Windows and is used by the OS to manage the <strong>execution</strong> of applications.</p>
<p>when a <strong>process</strong> is created (a kernel-level operation), the creation of the PE is the second step, following the initialization of the address space. before i get into how the PE is created, let&rsquo;s take a look at what it consists of.</p>
<p><p class="imgp">
  <img loading="lazy" src="/PE.png" alt="PE"  />
</p>
</p>
<p>the PE file begins with an <strong>MS-DOS header</strong>, which includes a magic number (<code>MZ</code>) that identifies the file as a DOS executable. this header is primarily for backward compatibility and includes a pointer to the PE header.</p>
<p>the <strong>PE header</strong> defines the program&rsquo;s binary code, images, number of sections, the <strong>entry point address</strong> of the program, the target machine architecture, and more. it also contains a <strong>timestamp</strong>, which attackers can sometimes remove.</p>
<p>the <strong>Optional header</strong>, despite its name, is not optional. it defines the size of the code, the preferred base address, and the OS version.</p>
<p>the <strong>Section headers</strong> contain chunks of data mapped into memory, and instructions about how the program should be loaded into the memory (e.g., a contiguous string of bytes in memory?). they also contain the permissions to be granted to the sections (<strong>read</strong>, <strong>write</strong>, <strong>execute</strong>).</p>
<p>the <code>.text</code> section contains the executable program code. the <code>.idata</code> section contains the <strong>IAT</strong> (Import Address Table), which lists the DLLs + their functions (i.e., the library calls a program makes). the <code>.rsrc</code> section contains the resources used by the PE. these could be printable character strings, graphical images, and other assets.</p>
<p>finally, we have the <code>.reloc</code> section. since the PE binary is not &ldquo;position-independent&rdquo; (i.e., it won&rsquo;t work if moved from the intended location to a new location), <code>.reloc</code> tells the OS to translate memory addresses in the PE code if the PE has been moved (by adding/subtracting the offset from the memory address).</p>
<p><p class="imgp">
  <img loading="lazy" src="/PE-sections.png" alt="PE-sections"  />
</p>
</p>
<ul>
<li>the section headers. you can see the <strong>virtual address</strong> and the <strong>raw address</strong> (the offset where the mapping starts).</li>
</ul>
<p><p class="imgp">
  <img loading="lazy" src="/PE-sections-chars.png" alt="PE-sections-chars"  />
</p>
</p>
<ul>
<li>the characteristics breakdown of each section.</li>
</ul>
<p><p class="imgp">
  <img loading="lazy" src="/PE-imports.png" alt="PE-imports"  />
</p>
</p>
<ul>
<li>the import directory. this PE imports from two libraries: <code>testlib.dll</code> and <code>KERNEL32.dll</code>.</li>
</ul>
<p><p class="imgp">
  <img loading="lazy" src="/PE-kernel32APIs.png" alt="PE-kernel32APIs"  />
</p>
</p>
<ul>
<li>the <code>KERNEL32.dll</code> contains all of the Windows APIs.</li>
</ul>
<p><p class="imgp">
  <img loading="lazy" src="/PE-exports.png" alt="PE-exports"  />
</p>
</p>
<ul>
<li>the exports directory.</li>
</ul>
<p>by now you might be wondering: who cares? or, at the very least, why is the PE so important? and what does it have to do with creating custom minidumpers? i&rsquo;m not going to answer the first question, and i think i&rsquo;ve already answered the second question. so, i&rsquo;m going to address the third question.</p>
<h2 id="pe--minidumpers">PE + minidumpers</h2>
<p>the PE format provides detailed information about the modules (<strong>executables</strong> + <strong>DLLs</strong>) loaded into a process&rsquo;s memory. this includes their base addresses, sizes, and sections. custom minidumpers need this information to capture the state of a process and its dependencies.</p>
<p>the PE also includes data directories that point to <strong>export + import tables</strong>. these tables describe which functions a module provides, and which external functions it relies on. this information is often included in minidumps to help engineers trace function calls + dependencies. the data directories also contain <strong>relocation information</strong>, which describe how a module&rsquo;s code/data are relocated in memory. the relocation entries help to adjust addresses when a module is loaded at a different base address than expected.</p>
<p>custom minidumpers will also need the <strong>debugging information</strong> (symbol tables, line number data), <strong>security analysis</strong> (checksums, integrity), and everything else that the PE format provides. the PE format is a blueprint, so the logical first-step is to create a tool that parses + manipulates it.</p>
<h3 id="mapping-out-the-pe-format-in-rust">mapping out the PE format in Rust</h3>
<p>our custom minidumper starts with understanding + mapping out the the PE format. this is because we&rsquo;ll eventually be analyzing/manipulating Windows executables. we&rsquo;ll also be extracting specific information from the process&rsquo;s memory. then, we&rsquo;ll define custom structs that <strong>mirror</strong> the PE format, since we&rsquo;ll be serializing/deserializing data in a specific way.</p>
<p>before i get into the code, i&rsquo;ll provide a 1000-foot view of how this program works.</p>
<p>a variety of data structs that represent different parts of the PE format (<code>ImageDosHeader</code>, <code>ImageNtHeaders64</code>, <code>ImageOptionalHeader64</code>, <code>ImageDataDirectory</code>, etc.) will be defined. these will allow us to parse the headers + sections of a PE file.</p>
<p>we&rsquo;ll also have to create <strong>RVA (Relative Virtual Address)</strong> handling, specifically with <code>RVA32</code> + <code>RVA64</code> types. these types will provide methods to resolve RVAs to actual memory addresses.</p>
<p>we&rsquo;ll also have to access the export/import tables of a module (<code>get_export_table</code>, <code>get_import_directory_table</code>), to verify which functions are available or not.</p>
<p>to handle COFF symbols + section headers, a module will be needed to extract the symbol information and section characteristics. this is for debugging + analysis.</p>
<p>by defining my own structs + parsing logic, we can tailor the minidump to include exactly what we need and evade detection that looks for standard minidump patterns. custom parsing + dumping techniques are less detectable than use standard APIs, and stealth is always a priority in offensive security.</p>
<p>a note on why i chose Rust: Rust&rsquo;s combination of performance, safety, and modernity  makes it an excellent choice for developing a custom minidumper. its ability to provide low-level control without sacrificing safety is advantageous in security-focused projects, where both performance + reliability are paramount. this project can now achieve high efficiency and robustness, making it a powerful tool offensive security.</p>
<h3 id="code">code</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#![allow(dead_code)]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> core::mem::transmute;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> std::slice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> bitflags::bitflags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// parsed PE32+ struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PE64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pe64: <span style="color:#8be9fd;font-style:italic">Box</span><span style="color:#ff79c6">&lt;</span>Pe64C<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> data_directories: <span style="color:#50fa7b">ImageDataDirectoryVec</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// return reference to ImageDataDirectoryVec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> PE64 {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_data_directories</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">ImageDataDirectoryVec</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self.data_directories
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#34;C&#34; style representation of a parsed PE32+ struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">Pe64C</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> dos_header: <span style="color:#50fa7b">ImageDosHeader</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> Pe64C {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_nt_headers</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">ImageNtHeaders64</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> nt_headers <span style="color:#ff79c6">=</span> self.dos_header.e_lfanew.get(self <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;*</span>(nt_headers)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// constant representing valid MS-DOS sig
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">const</span> IMAGE_DOS_SIGNATURE: <span style="color:#8be9fd">u16</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">u16</span>::from_le_bytes(<span style="color:#ff79c6">*</span><span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;MZ&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f1fa8c">/// MS-DOS sig (MZ)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDosSignature</span>(<span style="color:#8be9fd">u16</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl ImageDosSignature + verify sig is valid
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> ImageDosSignature {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">is_valid</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">==</span> IMAGE_DOS_SIGNATURE
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDosHeader</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_magic: <span style="color:#50fa7b">ImageDosSignature</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_cblp: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_cp: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_crlc: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_cparhdr: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_minalloc: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_maxalloc: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_ss: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_sp: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_csum: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_ip: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_cs: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_lfarlc: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_ovno: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_res: [<span style="color:#8be9fd">u16</span>; <span style="color:#bd93f9">4</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_oemid: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_oeminfo: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_res2: [<span style="color:#8be9fd">u16</span>; <span style="color:#bd93f9">10</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// offset from module base to ImageNtHeaders64 struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> e_lfanew: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ImageNtHeaders64<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageNtHeaders64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> signature: <span style="color:#50fa7b">PESignature</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> file_header: <span style="color:#50fa7b">ImageFileHeader</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> optional_header: <span style="color:#50fa7b">ImageOptionalHeader64</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PEType is an enum representing pe32 or pe32+ identifiers
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(PartialEq, Eq, Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">PEType</span> {
</span></span><span style="display:flex;"><span>    PE32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x10b</span>,
</span></span><span style="display:flex;"><span>    PE64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x20b</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ImageOptionalHeader64 struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageOptionalHeader64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> magic: <span style="color:#50fa7b">PEType</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_linker_version: <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_linker_version: <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_code: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_initialized_data: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_uninitialized_data: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> address_of_entry_point: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">extern</span> <span style="color:#f1fa8c">&#34;C&#34;</span> <span style="color:#ff79c6">fn</span>()<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> base_of_code: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> image_base: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> section_alignment: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> file_alignment: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_operating_system_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_operating_system_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_image_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_image_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_subsystem_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_subsystem_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> win32_version_value: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_image: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_headers: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> check_sum: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> subsystem: <span style="color:#50fa7b">WindowsSubsystem</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> dll_characteristics: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_stack_reserve: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_stack_commit: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_heap_reserve: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_heap_commit: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> loader_flags: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_rva_and_sizes: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// data directory is an array of ImageDataDirectory structs
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// size is based on number_of_rva_and_sizes field in this struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> data_directory: [ImageDataDirectory; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ImageDataDirectory struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDataDirectoryVec</span>(<span style="color:#ff79c6">pub</span> <span style="color:#8be9fd;font-style:italic">Vec</span><span style="color:#ff79c6">&lt;</span>ImageDataDirectoryInfo<span style="color:#ff79c6">&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ImageDataDirectoryVec {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// get entry corresponding to export table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_export_table</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ExportDirectoryTable<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// loop thru data dirs + find entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> ImageDataDirectoryEntry::ExportTable {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ExportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// cast table to reference to ExportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(table) };
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// return table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(table);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_import_directory_table</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ImportDirectoryTable<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// loop thru data directories and find the entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> ImageDataDirectoryEntry::ImportTable {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ImportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// cast table to ref to ImportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(table) };
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// return table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(table);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_import_lookup_table</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ImportLookupTable<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// loop thru data directories + find entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> ImageDataDirectoryEntry::ImportTable {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ImportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// cast table to reference to ImportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table: <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">ImportDirectoryTable</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(table) };
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> import_lookup_table <span style="color:#ff79c6">=</span> table.import_lookup_table_rva.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> import_lookup_table <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(import_lookup_table) };
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// return table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(import_lookup_table);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// gets entry corresponding to import table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_import_address_table</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span>ImportAddressTableR<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// get pointer to ImportLookupTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd;font-style:italic">let</span> import_lookup_table <span style="color:#ff79c6">=</span> self.get_import_lookup_table().unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//  loop thru data directories + find the entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> ImageDataDirectoryEntry::IAT {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ImportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// cast table to reference to ImportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table: <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">ImportAddressTable</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(table) };
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// create ImportAddressTableR struct and fill it with entries from ImportAddressTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> table_r <span style="color:#ff79c6">=</span> ImportAddressTableR::default();
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get count of entries in table by dividing entry.size by size of u64
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> count <span style="color:#ff79c6">=</span> entry.size <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">/</span> core::mem::size_of::<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">u64</span><span style="color:#ff79c6">&gt;</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//  loop thru entries in table and add them to table_r
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">0</span><span style="color:#ff79c6">..</span>count {
</span></span><span style="display:flex;"><span>                    <span style="color:#8be9fd;font-style:italic">let</span> entry <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { table.addresses.get_unchecked(i) };
</span></span><span style="display:flex;"><span>                    <span style="color:#8be9fd;font-style:italic">let</span> import_lookup_table_entry <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">unsafe</span> { import_lookup_table.entry.get_unchecked(i) };
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// if entries are identical, target has not been bound
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#6272a4">// could handle this, but skip it instead
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">*</span>entry <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">*</span>import_lookup_table_entry {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">continue</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// ensure entry is not null
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    assert_ne!(entry <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u64</span> <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">u64</span>, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// create ImportAddressEntry struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#8be9fd;font-style:italic">let</span> entry_r <span style="color:#ff79c6">=</span> ImportAddressEntry {
</span></span><span style="display:flex;"><span>                        iat_entry_address: <span style="color:#50fa7b">entry</span> <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>                        target_function_address: <span style="color:#ff79c6">*</span>entry,
</span></span><span style="display:flex;"><span>                    };
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// add entry to ImportAddressTableR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    table_r.addresses.push(entry_r);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// return table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(table_r);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">is_within_range</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self,
</span></span><span style="display:flex;"><span>        target_type: <span style="color:#50fa7b">ImageDataDirectoryEntry</span>,
</span></span><span style="display:flex;"><span>        address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">bool</span><span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//  loop thru data directories and find the entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> target_type {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ExportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> start_addr <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> end_addr <span style="color:#ff79c6">=</span> start_addr <span style="color:#ff79c6">+</span> entry.size <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(address <span style="color:#ff79c6">&gt;=</span> start_addr <span style="color:#ff79c6">&amp;&amp;</span> address <span style="color:#ff79c6">&lt;</span> end_addr);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define ImageDataDirectory struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDataDirectory</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_address: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDataDirectoryInfo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_address: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>()<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name: <span style="color:#50fa7b">ImageDataDirectoryEntry</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ImageDataDirectoryInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// checks if provided usize is within range of this section described by the combination of the base_address and our virtual_address RVA
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">is_within_range</span>(<span style="color:#ff79c6">&amp;</span>self, address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> base_address <span style="color:#ff79c6">=</span> self.base_address;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> virtual_address <span style="color:#ff79c6">=</span> self.virtual_address.get(base_address) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        address <span style="color:#ff79c6">&gt;=</span> virtual_address <span style="color:#ff79c6">&amp;&amp;</span> address <span style="color:#ff79c6">&lt;</span> virtual_address <span style="color:#ff79c6">+</span> self.size <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// export Directory Table as described in PE format
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportDirectoryTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> characteristics: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> time_date_stamp: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> ordinal_base: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_functions: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_names: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> export_address_table_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ExportAddressTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name_ptr_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ExportNamePtrTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> ordinal_table_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ExportOrdinalTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define import directory table as described in PE format
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportDirectoryTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> import_lookup_table_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ImportLookupTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> time_date_stamp: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> forwarder_chain: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ASCIIString<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> import_address_table_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ImportAddressTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define import address table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportAddressTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> addresses: [<span style="color:#8be9fd">u64</span>; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportAddressEntry</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> iat_entry_address: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> target_function_address: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Default)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportAddressTableR</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> addresses: <span style="color:#8be9fd;font-style:italic">Vec</span><span style="color:#ff79c6">&lt;</span>ImportAddressEntry<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define import lookup table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportLookupTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> entry: [<span style="color:#8be9fd">u64</span>; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define ExportOrdinalTable (array of u16)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportOrdinalTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> ordinals: [ExportAddressTableIndex; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ExportNamePtrTable is an array of RVA32s to ASCII strings
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportNamePtrTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name_ptr: [RVA32<span style="color:#ff79c6">&lt;</span>ASCIIString<span style="color:#ff79c6">&gt;</span>; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// defines ASCIIString type (null terminated ASCII string)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ASCIIString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> string: [<span style="color:#8be9fd">u8</span>; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ASCIIString {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// enumerates bytes of string until it finds a null byte, returns the length.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// manually count bytes as type has no associated size information
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">len</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> len <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">loop</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>self.string.get_unchecked(len) } <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> len;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            len <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// converts ASCIIString to Rust String
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">to_string</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">String</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> len <span style="color:#ff79c6">=</span> self.len();
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> string <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">String</span>::with_capacity(len);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">0</span><span style="color:#ff79c6">..</span>len {
</span></span><span style="display:flex;"><span>            string.push(<span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>self.string.get_unchecked(i) } <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">char</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        string
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ExportDirectoryTable {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// get entry from the export_address_table_rva by obtaining ExportAddressTable + indexing into it with provided index, checking that index is within bounds based on the number_of_functions field
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_export_address_table_entry</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self,
</span></span><span style="display:flex;"><span>        index: <span style="color:#50fa7b">ExportAddressTableIndex</span>,
</span></span><span style="display:flex;"><span>        base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ExportAddressTableEntry<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> index <span style="color:#ff79c6">=</span> index.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> index <span style="color:#ff79c6">&gt;=</span> self.number_of_functions <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// get underlying ExportAddressTable by applying the base_address to RVA32
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd;font-style:italic">let</span> export_address_table <span style="color:#ff79c6">=</span> self.export_address_table_rva.get(base_address);
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// index into table, use an unchecked index as the table is defined as a 0-size array + and index is checked above
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd;font-style:italic">let</span> entry <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { export_address_table.entries.get_unchecked(index) };
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(entry)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// gets entry from ExportOrdinalTable, similar to how we get entries from ExportAddressTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_export_ordinal_table_entry</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self,
</span></span><span style="display:flex;"><span>        index: <span style="color:#50fa7b">OrdinalTableIndex</span>,
</span></span><span style="display:flex;"><span>        base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ExportAddressTableIndex<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> index <span style="color:#ff79c6">=</span> index.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> index <span style="color:#ff79c6">&gt;=</span> self.number_of_names <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> export_ordinal_table <span style="color:#ff79c6">=</span> self.ordinal_table_rva.get(base_address);
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(<span style="color:#ff79c6">unsafe</span> { export_ordinal_table.ordinals.get_unchecked(index) })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// enumerates ExportNamePtrTable looking for String match with provided name
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// gets ExportNamePtrTable use the provided base_address, similar to how we get tables in get_export_address_table_entry +get_export_ordinal_table_entry. 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// return value is option around index corresponding to String match found (if any)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_export_name_ptr_table_entry</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self,
</span></span><span style="display:flex;"><span>        name: <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd">str</span>,
</span></span><span style="display:flex;"><span>        base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span>OrdinalTableIndex<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> export_name_ptr_table <span style="color:#ff79c6">=</span> self.name_ptr_rva.get(base_address);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">0</span><span style="color:#ff79c6">..</span>self.number_of_names {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> export_name_ptr <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">unsafe</span> { export_name_ptr_table.name_ptr.get_unchecked(i <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) };
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> export_name <span style="color:#ff79c6">=</span> export_name_ptr.get(base_address);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> export_name.to_string().to_lowercase() <span style="color:#ff79c6">==</span> name.to_lowercase() {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(OrdinalTableIndex(i));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportAddressTableIndex</span>(<span style="color:#8be9fd">u16</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">OrdinalTableIndex</span>(<span style="color:#8be9fd">u32</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define ExportAddressTableEntry which is a RVA32 to either a function or a string
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportAddressTableEntry</span>(<span style="color:#ff79c6">pub</span> RVA32<span style="color:#ff79c6">&lt;</span>()<span style="color:#ff79c6">&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ExportAddressTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportAddressTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// export address table is array of u32 values
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// size based on number_of_functions field in ExportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> entries: [ExportAddressTableEntry; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// enum representing ImageDataDirectory entries
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(PartialEq, Eq, Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">ImageDataDirectoryEntry</span> {
</span></span><span style="display:flex;"><span>    ExportTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>    ImportTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>,
</span></span><span style="display:flex;"><span>    ResourceTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>,
</span></span><span style="display:flex;"><span>    ExceptionTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">3</span>,
</span></span><span style="display:flex;"><span>    CertificateTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">4</span>,
</span></span><span style="display:flex;"><span>    BaseRelocationTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">5</span>,
</span></span><span style="display:flex;"><span>    Debug <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">6</span>,
</span></span><span style="display:flex;"><span>    Architecture <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">7</span>,
</span></span><span style="display:flex;"><span>    GlobalPtr <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">8</span>,
</span></span><span style="display:flex;"><span>    TLSTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">9</span>,
</span></span><span style="display:flex;"><span>    LoadConfigTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">10</span>,
</span></span><span style="display:flex;"><span>    BoundImport <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">11</span>,
</span></span><span style="display:flex;"><span>    IAT <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">12</span>,
</span></span><span style="display:flex;"><span>    DelayImportDescriptor <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">13</span>,
</span></span><span style="display:flex;"><span>    CLRRuntimeHeader <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">14</span>,
</span></span><span style="display:flex;"><span>    Reserved <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">15</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl ImageDataDirectoryEntry to convert index into enum
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> ImageDataDirectoryEntry {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">from_index</span>(index: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span>ImageDataDirectoryEntry<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">match</span> index {
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::ExportTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::ImportTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">2</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::ResourceTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">3</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::ExceptionTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">4</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::CertificateTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">5</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::BaseRelocationTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">6</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::Debug),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">7</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::Architecture),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">8</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::GlobalPtr),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">9</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::TLSTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">10</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::LoadConfigTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">11</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::BoundImport),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">12</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::IAT),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">13</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::DelayImportDescriptor),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">14</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::CLRRuntimeHeader),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">15</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::Reserved),
</span></span><span style="display:flex;"><span>            _ <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// convert enum into usize index
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">to_index</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">match</span> self {
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::ExportTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::ImportTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">1</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::ResourceTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">2</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::ExceptionTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">3</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::CertificateTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">4</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::BaseRelocationTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">5</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::Debug <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">6</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::Architecture <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">7</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::GlobalPtr <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">8</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::TLSTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">9</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::LoadConfigTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">10</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::BoundImport <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">11</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::IAT <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">12</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::DelayImportDescriptor <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">13</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::CLRRuntimeHeader <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">14</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::Reserved <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">15</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// enum representing valid Windows Subsystem values
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(PartialEq, Eq, Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">WindowsSubsystem</span> {
</span></span><span style="display:flex;"><span>    ImageSubsystemUnknown <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemNative <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemWindowsGui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemWindowsCui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">3</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemOs2Cui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">5</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemPosixCui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">7</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemNativeWindows <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">8</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemWindowsCeGui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">9</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemEfiApplication <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">10</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemEfiBootServiceDriver <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">11</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemEfiRuntimeDriver <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">12</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemEfiRom <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">13</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemXbox <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">14</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemWindowsBootApplication <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">16</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bitflags! {
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">/// `SectionCharacteristics` bitflags used to describe characteristics of sections
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">SectionCharacteristics</span>: <span style="color:#8be9fd">u32</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_TYPE_NO_PAD <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000008</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_CNT_CODE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000020</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_CNT_INITIALIZED_DATA <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000040</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000080</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_OTHER <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000100</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_INFO <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000200</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_REMOVE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000800</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_COMDAT <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00001000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_GPREL <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00008000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_PURGEABLE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00020000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_16BIT <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00020000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_LOCKED <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00040000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_PRELOAD <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00080000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_1BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00100000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_2BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00200000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_4BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00300000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_8BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00400000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_16BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00500000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_32BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00600000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_64BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00700000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_128BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00800000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_256BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00900000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_512BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00A00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_1024BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00B00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_2048BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00C00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_4096BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00D00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_8192BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00E00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_NRELOC_OVFL <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x01000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_DISCARDABLE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x02000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_NOT_CACHED <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x04000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_NOT_PAGED <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x08000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_SHARED <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x10000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_EXECUTE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x20000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_READ <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x40000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_WRITE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x80000000</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PEB</span> {
</span></span><span style="display:flex;"><span>    junk1: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    junk2: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    junk3: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> ldr: <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> PebLdrData,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ListEntry</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> flink: <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> ListEntry,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> blink: <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> ListEntry,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PebLdrData</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> junk: [<span style="color:#8be9fd">usize</span>; <span style="color:#bd93f9">4</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> in_memory_order_module_list: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">LdrDataTableEntry</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> in_load_order_links: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> in_memory_order_links: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> in_initialization_order_links: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> dll_base: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> entry_point: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_image: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> full_dll_name: <span style="color:#50fa7b">UnicodeString</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> base_dll_name: <span style="color:#50fa7b">UnicodeString</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> flags: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> load_count: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> tls_index: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> hash_links: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> time_date_stamp: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">CoffX64Relocation</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_address: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> symbol_table_index: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> typ: <span style="color:#50fa7b">CoffX64RelocationType</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Eq, PartialEq, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">CoffX64RelocationType</span> {
</span></span><span style="display:flex;"><span>    ImageRelAmd64Absolute <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0000</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Addr64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0001</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Addr32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0002</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Addr32nb <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0003</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0004</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel321 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0005</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel322 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0006</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel323 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0007</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel324 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0008</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel325 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0009</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Section <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000A</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Secrel <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000B</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Secrel7 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000C</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Token <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000D</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Srel32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000E</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Pair <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000F</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Sspan32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0010</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">SectionHeader</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name: [<span style="color:#8be9fd">u8</span>; <span style="color:#bd93f9">8</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_size: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_address: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_raw_data: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pointer_to_raw_data: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pointer_to_relocations: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pointer_to_line_numbers: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_relocations: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_line_numbers: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> characteristics: <span style="color:#50fa7b">SectionCharacteristics</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> SectionHeader {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_name</span>(<span style="color:#ff79c6">&amp;</span>self, str_table: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">String</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> self.name[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#39;/&#39;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> offset <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">String</span>::new();
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">1</span><span style="color:#ff79c6">..</span><span style="color:#bd93f9">8</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> self.name[i] <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                offset.push(self.name[i] <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">char</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// convert ASCII representation of offset into u64
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> offset: <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">usize</span>::from_str_radix(<span style="color:#ff79c6">&amp;</span>offset, <span style="color:#bd93f9">10</span>).unwrap();
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// get string from string table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> name_ptr <span style="color:#ff79c6">=</span> offset <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">+</span> str_table;
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Convert name_ptr to a null-terminated str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// collect all bytes in name_ptr until null byte is reached
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> name_bytes <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">Vec</span>::new();
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">loop</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> byte <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>((name_ptr <span style="color:#ff79c6">+</span> name_bytes.len()) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>) };
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> byte <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                name_bytes.push(byte);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// convert the bytes to a str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// **unsafe if object is corrupted
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// safety: remove unwrap + return Result
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">return</span> core::<span style="color:#8be9fd">str</span>::from_utf8(<span style="color:#ff79c6">&amp;</span>name_bytes).unwrap().to_string();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> name <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">String</span>::new();
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">0</span><span style="color:#ff79c6">..</span><span style="color:#bd93f9">8</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> self.name[i] <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            name.push(self.name[i] <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">char</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageFileHeader</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> machine: <span style="color:#50fa7b">ImageFileMachine</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_sections: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> time_date_stamp: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pointer_to_symbol_table: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_symbols: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_optional_header: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> characteristics: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ImageFileHeader {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_symbols</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>[CoffSymbol]<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> self.pointer_to_symbol_table <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> symbol_table_ptr <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>            (base_address <span style="color:#ff79c6">+</span> self.pointer_to_symbol_table <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> CoffSymbol;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> symbol_table <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">unsafe</span> { slice::from_raw_parts(symbol_table_ptr, self.number_of_symbols <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) };
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(symbol_table)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_string_table</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>[<span style="color:#8be9fd">u8</span>]<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> symbol_table_ptr <span style="color:#ff79c6">=</span> base_address <span style="color:#ff79c6">+</span> self.pointer_to_symbol_table <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table_ptr <span style="color:#ff79c6">=</span> symbol_table_ptr
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">+</span> (self.number_of_symbols <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">*</span> core::mem::size_of::<span style="color:#ff79c6">&lt;</span>CoffSymbol<span style="color:#ff79c6">&gt;</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table_len <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>(str_table_ptr <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u32</span>) } <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> str_table_len <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { slice::from_raw_parts(str_table_ptr <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>, str_table_len) };
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(str_table)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_symbol_name</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>, symbol: <span style="color:#50fa7b">CoffSymbol</span>) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">String</span><span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> symbol_table_ptr <span style="color:#ff79c6">=</span> base_address <span style="color:#ff79c6">+</span> self.pointer_to_symbol_table <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table_ptr <span style="color:#ff79c6">=</span> symbol_table_ptr
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">+</span> (self.number_of_symbols <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">*</span> core::mem::size_of::<span style="color:#ff79c6">&lt;</span>CoffSymbol<span style="color:#ff79c6">&gt;</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table_len <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>(str_table_ptr <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u32</span>) } <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> str_table_len <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(symbol.name.get_name(str_table_ptr))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f1fa8c">/// COFF Symbol table (packed to prevent padding)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">CoffSymbol</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name: <span style="color:#50fa7b">CoffSymbolName</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> value: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> section_number: <span style="color:#8be9fd">i16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> type_: <span style="color:#50fa7b">CoffSymbolType</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> storage_class: <span style="color:#50fa7b">CoffSymbolStorageClass</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_aux_symbols: <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f1fa8c">/// COFF symbol type
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#ff79c6">#[derive(Clone, Copy, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">CoffSymbolType</span> {
</span></span><span style="display:flex;"><span>    ImageSymTypeNull <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0000</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeVoid <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0001</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeChar <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0002</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeShort <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0003</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeInt <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0004</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeLong <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0005</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeFloat <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0006</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeDouble <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0007</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeStruct <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0008</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeUnion <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0009</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeEnum <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000A</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeMoe <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000B</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeByte <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000C</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeWord <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000D</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeUint <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000E</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeDword <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000F</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f1fa8c">/// COFF symbol storage class
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#ff79c6">#[derive(Clone, Copy, Debug, Eq, PartialEq)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u8)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">CoffSymbolStorageClass</span> {
</span></span><span style="display:flex;"><span>    ImageSymClassEndOfFunction <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xFF</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassNull <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassAutomatic <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x01</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassExternal <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x02</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassStatic <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x03</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassRegister <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x04</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassExternalDef <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x05</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassLabel <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x06</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassUndefinedLabel <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x07</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassMemberOfStruct <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x08</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassArgument <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x09</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassStructTag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0A</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassMemberOfUnion <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0B</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassUnionTag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0C</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassTypeDefinition <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0D</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassUndefinedStatic <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0E</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassEnumTag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0F</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassMemberOfEnum <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x10</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassRegisterParam <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x11</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassBitField <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x12</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassBlock <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x64</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassFunction <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x65</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassEndOfStruct <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x66</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassFile <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x67</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassSection <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x68</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassWeakExternal <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x69</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassClrToken <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x6B</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">CoffSymbolName</span>(<span style="color:#ff79c6">pub</span> [<span style="color:#8be9fd">u8</span>; <span style="color:#bd93f9">8</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> CoffSymbolName {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_name</span>(<span style="color:#ff79c6">&amp;</span>self, str_table_ptr: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">String</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> name <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>self.<span style="color:#bd93f9">0</span>[<span style="color:#ff79c6">..</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> name[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> name_offset <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">u32</span>::from_le_bytes(name[<span style="color:#bd93f9">4</span><span style="color:#ff79c6">..</span><span style="color:#bd93f9">8</span>].try_into().unwrap());
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// name_offset + str_table_ptr = UTF8 null-terminated string
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> name_ptr <span style="color:#ff79c6">=</span> name_offset <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">+</span> str_table_ptr;
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// convert name_ptr to null-terminated str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// collect all bytes in name_ptr until null byte is reached
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> name_bytes <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">Vec</span>::new();
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">loop</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> byte <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>((name_ptr <span style="color:#ff79c6">+</span> name_bytes.len()) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>) };
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> byte <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                name_bytes.push(byte);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// convert bytes to str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// **unsafe, if object is corrupted
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// safety: remove unwrap + return Result
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">return</span> core::<span style="color:#8be9fd">str</span>::from_utf8(<span style="color:#ff79c6">&amp;</span>name_bytes).unwrap().to_string();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// convert first 8 bytes to a str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd;font-style:italic">let</span> len <span style="color:#ff79c6">=</span> name.iter().position(<span style="color:#ff79c6">|&amp;</span>c<span style="color:#ff79c6">|</span> c <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>).unwrap_or(name.len());
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">String</span>::from_utf8_lossy(<span style="color:#ff79c6">&amp;</span>name[<span style="color:#ff79c6">..</span>len]).to_string()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// enum representing valid ImageFileMachine values
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(PartialEq, Eq, Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">ImageFileMachine</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// all possible Machine Types
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    Unknown <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0</span>,
</span></span><span style="display:flex;"><span>    Am33 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1d3</span>,
</span></span><span style="display:flex;"><span>    Amd64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x8664</span>,
</span></span><span style="display:flex;"><span>    Arm <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1c0</span>,
</span></span><span style="display:flex;"><span>    Arm64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xaa64</span>,
</span></span><span style="display:flex;"><span>    ArmNT <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1c4</span>,
</span></span><span style="display:flex;"><span>    Ebc <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xebc</span>,
</span></span><span style="display:flex;"><span>    I386 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x14c</span>,
</span></span><span style="display:flex;"><span>    Ia64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x200</span>,
</span></span><span style="display:flex;"><span>    M32R <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x9041</span>,
</span></span><span style="display:flex;"><span>    Mips16 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x266</span>,
</span></span><span style="display:flex;"><span>    MipsFpu <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x366</span>,
</span></span><span style="display:flex;"><span>    MipsFpu16 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x466</span>,
</span></span><span style="display:flex;"><span>    PowerPC <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1f0</span>,
</span></span><span style="display:flex;"><span>    PowerPCFP <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1f1</span>,
</span></span><span style="display:flex;"><span>    R4000 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x166</span>,
</span></span><span style="display:flex;"><span>    RiscV32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x5032</span>,
</span></span><span style="display:flex;"><span>    RiscV64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x5064</span>,
</span></span><span style="display:flex;"><span>    RiscV128 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x5128</span>,
</span></span><span style="display:flex;"><span>    SH3 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1a2</span>,
</span></span><span style="display:flex;"><span>    SH3DSP <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1a3</span>,
</span></span><span style="display:flex;"><span>    SH4 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1a6</span>,
</span></span><span style="display:flex;"><span>    SH5 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1a8</span>,
</span></span><span style="display:flex;"><span>    Thumb <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1c2</span>,
</span></span><span style="display:flex;"><span>    WceMipsV2 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x169</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// constant representing a PE signature, e.g. &#34;PE\0\0&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">const</span> PE_SIGNATURE: <span style="color:#8be9fd">u32</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">u32</span>::from_le_bytes(<span style="color:#ff79c6">*</span><span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;PE</span><span style="color:#f1fa8c">\0\0</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PESignature</span>(<span style="color:#8be9fd">u32</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// implement PESignature + verify sig is valid
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> PESignature {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">is_valid</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">==</span> PE_SIGNATURE
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// RVA32 is a relative virtual address to an underlying type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Copy, Clone, Default)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>T: <span style="color:#ff79c6">?</span><span style="color:#8be9fd;font-style:italic">Sized</span><span style="color:#ff79c6">&gt;</span>(<span style="color:#ff79c6">pub</span> <span style="color:#8be9fd">u32</span>, <span style="color:#ff79c6">pub</span> core::marker::PhantomData<span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl RVA32 with a function that adds usize base_address then derefs the pointer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span><span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span> RVA32<span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">T</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">&amp;*</span>((base_address <span style="color:#ff79c6">+</span> self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> T) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_mut</span>(<span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">mut</span> self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">mut</span> T {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">mut</span> <span style="color:#ff79c6">*</span>((base_address <span style="color:#ff79c6">+</span> self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">mut</span> T) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Default)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">RVA64</span><span style="color:#ff79c6">&lt;</span>T: <span style="color:#ff79c6">?</span><span style="color:#8be9fd;font-style:italic">Sized</span><span style="color:#ff79c6">&gt;</span>(<span style="color:#ff79c6">pub</span> <span style="color:#8be9fd">u64</span>, <span style="color:#ff79c6">pub</span> core::marker::PhantomData<span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl RVA64 with function that adds usize base_address + then derefs the pointer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span><span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span> RVA64<span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">T</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">&amp;*</span>((base_address <span style="color:#ff79c6">+</span> self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> T) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_mut</span>(<span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">mut</span> self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">mut</span> T {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">mut</span> <span style="color:#ff79c6">*</span>((base_address <span style="color:#ff79c6">+</span> self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">mut</span> T) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">UnicodeString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> length: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> maximum_length: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> buffer: <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl Default for UnicodeString
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> <span style="color:#8be9fd;font-style:italic">Default</span> <span style="color:#ff79c6">for</span> UnicodeString {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">default</span>() -&gt; <span style="color:#50fa7b">Self</span> {
</span></span><span style="display:flex;"><span>        Self {
</span></span><span style="display:flex;"><span>            length: <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>            maximum_length: <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>            buffer: <span style="color:#50fa7b">core</span>::ptr::null(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> UnicodeString {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// convert buffer to utf16 string based on length field
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">extract_string</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">String</span><span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> self.length <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">||</span> self.buffer <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> slice <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { slice::from_raw_parts(self.buffer, self.length <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2</span>) };
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// convert slice to String
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        core::<span style="color:#8be9fd">char</span>::decode_utf16(slice.iter().cloned())
</span></span><span style="display:flex;"><span>            .collect::<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">Result</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">String</span>, _<span style="color:#ff79c6">&gt;&gt;</span>()
</span></span><span style="display:flex;"><span>            .ok()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>now that we&rsquo;ve mapped + define the structures and layouts of a PE file, as well as how to handle RVAs, we can move ahead with writing our custom minidumper! stay tuned for part 2.</p>
</main>


    <br>
    <hr>
    
      Next: <a href="//localhost:1313/posts/new_post10/">reading list [updated]</a>
    




<footer>
  <div class="footer-nav">
    
    <a class="next" href="/posts/macos-cred-access/" style="float: right"
      >next: credential access in macOS</a
    >
     
    <a class="previous" href="/posts/new_post10/">previous</a>
    
  </div>
</footer>



<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 300),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script><!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000000" />

    <meta name="description" content="advanced evasions, part 1: PE maps &#43; custom minidumpers">

    
        <title>advanced evasions, part 1: PE maps &#43; custom minidumpers | à¼§</title>
    

    
    <link rel="stylesheet" type="text/css" href="/style.min.6f40ec7b8baa6b4858deb6d2433606e0c74c60aa022d42f0d84457862cc005f3.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/about/">about</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/cv/">cv</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/posts/">posts</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/photography/">photography</a></li>
            
          </ul>
        </nav>
        



<div id="single-header">
  <h1>
    advanced evasions, part 1: PE maps + custom minidumpers
  </h1>
  <div id="single-meta">
    
    
        <span class="datesub">jan 7, 2024 &nbsp;&nbsp; m. jan 29, 2024</span>
      

  </div>
</div>



<aside class="toc" id="tableOfContentContainer">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#avedr">AV/EDR</a></li>
    <li><a href="#avedr--minidumps">AV/EDR + minidumps</a></li>
    <li><a href="#custom-minidumpers">custom minidumpers</a></li>
    <li><a href="#minidumpers-the-boring-stuff">minidumpers: the boring stuff</a></li>
    <li><a href="#advanced-minidump-techniques">advanced minidump techniques</a></li>
    <li><a href="#pe-portable-executable">PE: Portable Executable</a></li>
    <li><a href="#pe--minidumpers">PE + minidumpers</a>
      <ul>
        <li><a href="#mapping-out-the-pe-format-in-rust">mapping out the PE format in Rust</a></li>
        <li><a href="#code">code</a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>


<main><p>imagine if your computer kept a journal. a journal not merely consisting of poetic silicon muses, but moment-by-moment accounts of all its inner workings. these journals exist, and they&rsquo;re called <strong>minidumps</strong>. minidumps are compact snapshots of a computer&rsquo;s memory, and they capture the essence of what&rsquo;s happening inside your machine at any given moment.</p>
<p><p class="imgp">
  <img loading="lazy" src="/bluescreenview.gif" alt="bluescreenview"  />
</p>
</p>
<p><p class="imgp">
  <img loading="lazy" src="/bluescreenview2.gif" alt="bluescreenview"  />
</p>
</p>
<p>to the unitiated (or uninterested), minidumps would just look like cryptic glyphs, with maybe a vague understanding that these glyphs represent something &ldquo;important&rdquo;. indeed, minidumps are extremely valuable, and at the heart of a hidden conflict inside the digital world: they&rsquo;re prized by software engineers hunting elusive bugs, revered by security/forensics experts trying to track down phantoms, and eyed warily by the very security systems designed to protect your computer.</p>
<p>think of your computer as if it were a bustling city, with programs + data zipping along like vehicles + people. a <strong>minidump</strong> is akin to a <strong>CCTV camera</strong> on a street corner that can freeze a moment in time, capturing everything in its view. now, imagine if someone could use that frozen image to understand traffic patterns, spot accidents before they&rsquo;ve happened, or even identify &ldquo;troublemakers&rdquo;.</p>
<p>here&rsquo;s where it gets interesting. just as a city might restrict where cameras can be placed, to protect residents&rsquo; privacy, your computer has security systems that keep an eye on who&rsquo;s taking these memory snapshots and why. it&rsquo;s a delicate balance between the need for insight and the demand for security.</p>
<h2 id="avedr">AV/EDR</h2>
<p>most of us have had experience use AV (<strong>antivirus</strong>) tools in the past. EDR (<strong>endpoint detection + response</strong>) systems are an extension of traditional AVs, in that they have a heightened level of access to the underlying OS and, in some cases, even the kernel. i won&rsquo;t bore you too much with how exactly EDRs work, but there are some important points to remember:</p>
<ol>
<li>
<p>EDRs use <strong>behavioural</strong> analysis to detect threats, while AVs traditionally rely on signature matching.</p>
</li>
<li>
<p>EDRs leverage AI/ML for more sophisticated threat (<strong>0-day</strong>) detection + automated response capabilities.</p>
</li>
<li>
<p>EDRs provide <strong>continuous, real-time monitoring</strong> of endpoints and their activites.</p>
</li>
</ol>
<h2 id="avedr--minidumps">AV/EDR + minidumps</h2>
<p><p class="imgp">
  <img loading="lazy" src="/edrminidump.png" alt="edrminidump"  />
</p>
</p>
<p>creating minidumps that won&rsquo;t trigger native security systems is of paramount importance to EDRs. to do this, many EDRs (and even some AVs) use <strong>custom minidumpers</strong> to capture specific memory regions of interest when a suspicious event occurs.</p>
<p>take the crudely illustrated example above. the entire process is enclosed within the EDR&rsquo;s system, and starts at <strong>minidump creation</strong>, where the EDR creates memory snapshots of running processes. these minidumps are then sent to the <strong>analysis engine</strong>, which examines the contents of the dumpfile for signs of malicious activity. the <strong>threat detection</strong> component receives these analysis results and <strong>identifies</strong> potential threats, based on the ruleset that it was fed during the design process.</p>
<p>as you can see, this is a cyclical process: continuous monitoring feeds back into the minidump creation, and so on. but how exactly do EDRs achieve this?</p>
<h2 id="custom-minidumpers">custom minidumpers</h2>
<p>EDRs have a vested interest in monitoring + controlling minidump creation. since minidumps contain snapshots of process memory, EDRs need to be able to prevent unauthorized data extraction, credential harvesting (like dumping <code>lsass.exe</code>), and attacks like process injection. this is done by EDRs leveraging <strong>custom minidumpers</strong>. ironically, attackers use <strong>custom minidumpers</strong> to evade detection and make reverse engineering malware more convoluted, but more on that later.</p>
<p>basically, everything malware might use custom minidumpers for is used by EDRs to foil it in the first place.</p>
<p>let&rsquo;s look at <strong>memory forensics</strong>, for example. custom minidumpers are used to capture specific memory regions, which is crucial for gathering IoCs and analyzing malware behaviour <strong>in-memory</strong> (while it&rsquo;s running in RAM as opposed to being stored as a static file on disk; this is also incredibly helpful for <a href="https://intezer.com/blog/incident-response/memory-analysis-forensic-tools/**"  target="_blank" rel="noreferrer nofollow">fileless malware</a>
).</p>
<ul>
<li>some more ways custom minidumpers are used by EDRs:</li>
</ul>
<ol>
<li>
<p>optimizing egress bandwidth + reducing system overhead during analysis.</p>
</li>
<li>
<p>identifying memory regions where malware attempts to hide (code injection, process hollowing).</p>
</li>
<li>
<p>capturing kernel-mode memory regions for rootkit analysis (driver-based malware, malicious kernel mods).</p>
</li>
</ol>
<p>if you haven&rsquo;t already guessed, i&rsquo;m going to be creating my own custom minidumper to see if i can exploit some EDR blindspots! now, let&rsquo;s dive into some technical details about minidumpers.</p>
<h2 id="minidumpers-the-boring-stuff">minidumpers: the boring stuff</h2>
<p>minidumps are typically stored as binary files with a structd format, often with the <code>.dmp</code> extension on Windows systems, and they contain a curated subset of the full process memory:</p>
<ol>
<li>
<p>critical memory regions, like stacks + heaps.</p>
</li>
<li>
<p>system + process information: this includes the <strong>process ID</strong> (identifying the specific process that the dump belongs to), <strong>timestamp</strong> (for correlating with system events + logs), <strong>OS version</strong>, and <strong>CPU architecture</strong>.</p>
</li>
<li>
<p>thread contexts (register states): provide snapshots of CPU registers for each thread (get exact state of execution), <strong>thread stacks</strong> (call history + local variables), <strong>thread-local storage</strong> (holds thread-specific data, analyzing <strong>thread isolation</strong> and potential <strong>race conditions</strong>)</p>
</li>
<li>
<p>loaded module details: identifying potential malicious injections, version conflicts, and provides the basis for symbol resolution during analysis.</p>
</li>
<li>
<p>exception information (if triggered by an exception): exception code, exception address, exception parameters, first-chance/second-chance status.</p>
</li>
<li>
<p>memory regions: stack memory for each thread, selected heap regions.</p>
</li>
<li>
<p>handle information: open handles (resources currently in use by process), handle types + permissions.</p>
</li>
<li>
<p>system information.</p>
</li>
</ol>
<h2 id="advanced-minidump-techniques">advanced minidump techniques</h2>
<p>advanced techniques for minidump creation go beyond standard API calls. the goal is to procure greater control, evasion capabilities, with full customization. let&rsquo;s take a look at some of them.</p>
<p><strong>direct memory access</strong>: use low-level memory access functions like <code>ReadProcessMemory</code>. this bypasses higher-level APIs that may be hooked or monitored. it allows for selective memory capture (evading detection), but requires a pretty thorough understanding of the memory layout + protection mechanisms.</p>
<p><strong>PEB parsing</strong>: directly accessing + parsing the PEB (<strong>Process Environment Block</strong>) struct. this also avoids easily-monitored APIs, and reveals information about loaded modules that might be hidden from standard APIs.</p>
<p><strong>custom thread enumeration</strong>: use low-level APIs like <code>NtQuerySystemInformation</code> or parsing the kernel structs directly. this can reveal hidden or injected threads.</p>
<p><strong>manual stack walking</strong>: implementing custom stack walking algorithms use architecture-specific techniques. this can allow for custom filtering + analysis, bypassing debugger APIs that may be detected or hooked.</p>
<p><strong>kernel-mode dumping</strong>: creating minidumps from kernel mode by use a custom driver. this allows us to dump protected process and bypass user-mode restrictions + detections.</p>
<p><strong>in-memory dump creation</strong>: creating dumps entirely in-memory without writing to disk. this is crucial if you want to avoid leaving artifacts on disk that can be detected, but you need custom analysis tools along with careful memory management to handle potentially large dumps.</p>
<p><strong>selective component dumping</strong>: creating highly targeted dumps, and significantly reducing dump size + creation time.</p>
<p><strong>encryption + obfuscation</strong>: evading signature-based detection of dump files by encrypting the dump data during or immediately after creation.</p>
<p>as you might have guessed, there are many different ways of leveraging custom minidumpers to dump <code>lsass.exe</code>. for this project, however, i&rsquo;m going to start with understanding + mapping the <strong>portable executable</strong>.</p>
<h2 id="pe-portable-executable">PE: Portable Executable</h2>
<p><strong>PE</strong> is a file format used in Windows for executables, object code, and <strong>dynamic link libraries</strong> (DLLs). simply put, it&rsquo;s the standard format for binary programs on Windows and is used by the OS to manage the <strong>execution</strong> of applications.</p>
<p>when a <strong>process</strong> is created (a kernel-level operation), the creation of the PE is the second step, following the initialization of the address space. before i get into how the PE is created, let&rsquo;s take a look at what it consists of.</p>
<p><p class="imgp">
  <img loading="lazy" src="/PE.png" alt="PE"  />
</p>
</p>
<p>the PE file begins with an <strong>MS-DOS header</strong>, which includes a magic number (<code>MZ</code>) that identifies the file as a DOS executable. this header is primarily for backward compatibility and includes a pointer to the PE header.</p>
<p>the <strong>PE header</strong> defines the program&rsquo;s binary code, images, number of sections, the <strong>entry point address</strong> of the program, the target machine architecture, and more. it also contains a <strong>timestamp</strong>, which attackers can sometimes remove.</p>
<p>the <strong>Optional header</strong>, despite its name, is not optional. it defines the size of the code, the preferred base address, and the OS version.</p>
<p>the <strong>Section headers</strong> contain chunks of data mapped into memory, and instructions about how the program should be loaded into the memory (e.g., a contiguous string of bytes in memory?). they also contain the permissions to be granted to the sections (<strong>read</strong>, <strong>write</strong>, <strong>execute</strong>).</p>
<p>the <code>.text</code> section contains the executable program code. the <code>.idata</code> section contains the <strong>IAT</strong> (Import Address Table), which lists the DLLs + their functions (i.e., the library calls a program makes). the <code>.rsrc</code> section contains the resources used by the PE. these could be printable character strings, graphical images, and other assets.</p>
<p>finally, we have the <code>.reloc</code> section. since the PE binary is not &ldquo;position-independent&rdquo; (i.e., it won&rsquo;t work if moved from the intended location to a new location), <code>.reloc</code> tells the OS to translate memory addresses in the PE code if the PE has been moved (by adding/subtracting the offset from the memory address).</p>
<p><p class="imgp">
  <img loading="lazy" src="/PE-sections.png" alt="PE-sections"  />
</p>
</p>
<ul>
<li>the section headers. you can see the <strong>virtual address</strong> and the <strong>raw address</strong> (the offset where the mapping starts).</li>
</ul>
<p><p class="imgp">
  <img loading="lazy" src="/PE-sections-chars.png" alt="PE-sections-chars"  />
</p>
</p>
<ul>
<li>the characteristics breakdown of each section.</li>
</ul>
<p><p class="imgp">
  <img loading="lazy" src="/PE-imports.png" alt="PE-imports"  />
</p>
</p>
<ul>
<li>the import directory. this PE imports from two libraries: <code>testlib.dll</code> and <code>KERNEL32.dll</code>.</li>
</ul>
<p><p class="imgp">
  <img loading="lazy" src="/PE-kernel32APIs.png" alt="PE-kernel32APIs"  />
</p>
</p>
<ul>
<li>the <code>KERNEL32.dll</code> contains all of the Windows APIs.</li>
</ul>
<p><p class="imgp">
  <img loading="lazy" src="/PE-exports.png" alt="PE-exports"  />
</p>
</p>
<ul>
<li>the exports directory.</li>
</ul>
<p>by now you might be wondering: who cares? or, at the very least, why is the PE so important? and what does it have to do with creating custom minidumpers? i&rsquo;m not going to answer the first question, and i think i&rsquo;ve already answered the second question. so, i&rsquo;m going to address the third question.</p>
<h2 id="pe--minidumpers">PE + minidumpers</h2>
<p>the PE format provides detailed information about the modules (<strong>executables</strong> + <strong>DLLs</strong>) loaded into a process&rsquo;s memory. this includes their base addresses, sizes, and sections. custom minidumpers need this information to capture the state of a process and its dependencies.</p>
<p>the PE also includes data directories that point to <strong>export + import tables</strong>. these tables describe which functions a module provides, and which external functions it relies on. this information is often included in minidumps to help engineers trace function calls + dependencies. the data directories also contain <strong>relocation information</strong>, which describe how a module&rsquo;s code/data are relocated in memory. the relocation entries help to adjust addresses when a module is loaded at a different base address than expected.</p>
<p>custom minidumpers will also need the <strong>debugging information</strong> (symbol tables, line number data), <strong>security analysis</strong> (checksums, integrity), and everything else that the PE format provides. the PE format is a blueprint, so the logical first-step is to create a tool that parses + manipulates it.</p>
<h3 id="mapping-out-the-pe-format-in-rust">mapping out the PE format in Rust</h3>
<p>our custom minidumper starts with understanding + mapping out the the PE format. this is because we&rsquo;ll eventually be analyzing/manipulating Windows executables. we&rsquo;ll also be extracting specific information from the process&rsquo;s memory. then, we&rsquo;ll define custom structs that <strong>mirror</strong> the PE format, since we&rsquo;ll be serializing/deserializing data in a specific way.</p>
<p>before i get into the code, i&rsquo;ll provide a 1000-foot view of how this program works.</p>
<p>a variety of data structs that represent different parts of the PE format (<code>ImageDosHeader</code>, <code>ImageNtHeaders64</code>, <code>ImageOptionalHeader64</code>, <code>ImageDataDirectory</code>, etc.) will be defined. these will allow us to parse the headers + sections of a PE file.</p>
<p>we&rsquo;ll also have to create <strong>RVA (Relative Virtual Address)</strong> handling, specifically with <code>RVA32</code> + <code>RVA64</code> types. these types will provide methods to resolve RVAs to actual memory addresses.</p>
<p>we&rsquo;ll also have to access the export/import tables of a module (<code>get_export_table</code>, <code>get_import_directory_table</code>), to verify which functions are available or not.</p>
<p>to handle COFF symbols + section headers, a module will be needed to extract the symbol information and section characteristics. this is for debugging + analysis.</p>
<p>by defining my own structs + parsing logic, we can tailor the minidump to include exactly what we need and evade detection that looks for standard minidump patterns. custom parsing + dumping techniques are less detectable than use standard APIs, and stealth is always a priority in offensive security.</p>
<p>a note on why i chose Rust: Rust&rsquo;s combination of performance, safety, and modernity  makes it an excellent choice for developing a custom minidumper. its ability to provide low-level control without sacrificing safety is advantageous in security-focused projects, where both performance + reliability are paramount. this project can now achieve high efficiency and robustness, making it a powerful tool offensive security.</p>
<h3 id="code">code</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#![allow(dead_code)]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> core::mem::transmute;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> std::slice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> bitflags::bitflags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// parsed PE32+ struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PE64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pe64: <span style="color:#8be9fd;font-style:italic">Box</span><span style="color:#ff79c6">&lt;</span>Pe64C<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> data_directories: <span style="color:#50fa7b">ImageDataDirectoryVec</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// return reference to ImageDataDirectoryVec
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> PE64 {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_data_directories</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">ImageDataDirectoryVec</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self.data_directories
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#34;C&#34; style representation of a parsed PE32+ struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">Pe64C</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> dos_header: <span style="color:#50fa7b">ImageDosHeader</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> Pe64C {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_nt_headers</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">ImageNtHeaders64</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> nt_headers <span style="color:#ff79c6">=</span> self.dos_header.e_lfanew.get(self <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;*</span>(nt_headers)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// constant representing valid MS-DOS sig
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">const</span> IMAGE_DOS_SIGNATURE: <span style="color:#8be9fd">u16</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">u16</span>::from_le_bytes(<span style="color:#ff79c6">*</span><span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;MZ&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f1fa8c">/// MS-DOS sig (MZ)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDosSignature</span>(<span style="color:#8be9fd">u16</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl ImageDosSignature + verify sig is valid
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> ImageDosSignature {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">is_valid</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">==</span> IMAGE_DOS_SIGNATURE
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDosHeader</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_magic: <span style="color:#50fa7b">ImageDosSignature</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_cblp: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_cp: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_crlc: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_cparhdr: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_minalloc: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_maxalloc: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_ss: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_sp: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_csum: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_ip: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_cs: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_lfarlc: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_ovno: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_res: [<span style="color:#8be9fd">u16</span>; <span style="color:#bd93f9">4</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_oemid: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_oeminfo: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> e_res2: [<span style="color:#8be9fd">u16</span>; <span style="color:#bd93f9">10</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// offset from module base to ImageNtHeaders64 struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> e_lfanew: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ImageNtHeaders64<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageNtHeaders64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> signature: <span style="color:#50fa7b">PESignature</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> file_header: <span style="color:#50fa7b">ImageFileHeader</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> optional_header: <span style="color:#50fa7b">ImageOptionalHeader64</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PEType is an enum representing pe32 or pe32+ identifiers
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(PartialEq, Eq, Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">PEType</span> {
</span></span><span style="display:flex;"><span>    PE32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x10b</span>,
</span></span><span style="display:flex;"><span>    PE64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x20b</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ImageOptionalHeader64 struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageOptionalHeader64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> magic: <span style="color:#50fa7b">PEType</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_linker_version: <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_linker_version: <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_code: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_initialized_data: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_uninitialized_data: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> address_of_entry_point: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">extern</span> <span style="color:#f1fa8c">&#34;C&#34;</span> <span style="color:#ff79c6">fn</span>()<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> base_of_code: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> image_base: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> section_alignment: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> file_alignment: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_operating_system_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_operating_system_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_image_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_image_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_subsystem_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_subsystem_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> win32_version_value: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_image: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_headers: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> check_sum: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> subsystem: <span style="color:#50fa7b">WindowsSubsystem</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> dll_characteristics: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_stack_reserve: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_stack_commit: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_heap_reserve: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_heap_commit: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> loader_flags: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_rva_and_sizes: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// data directory is an array of ImageDataDirectory structs
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// size is based on number_of_rva_and_sizes field in this struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> data_directory: [ImageDataDirectory; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ImageDataDirectory struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDataDirectoryVec</span>(<span style="color:#ff79c6">pub</span> <span style="color:#8be9fd;font-style:italic">Vec</span><span style="color:#ff79c6">&lt;</span>ImageDataDirectoryInfo<span style="color:#ff79c6">&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ImageDataDirectoryVec {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// get entry corresponding to export table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_export_table</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ExportDirectoryTable<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// loop thru data dirs + find entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> ImageDataDirectoryEntry::ExportTable {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ExportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// cast table to reference to ExportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(table) };
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// return table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(table);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_import_directory_table</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ImportDirectoryTable<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// loop thru data directories and find the entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> ImageDataDirectoryEntry::ImportTable {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ImportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// cast table to ref to ImportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(table) };
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// return table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(table);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_import_lookup_table</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ImportLookupTable<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// loop thru data directories + find entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> ImageDataDirectoryEntry::ImportTable {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ImportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// cast table to reference to ImportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table: <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">ImportDirectoryTable</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(table) };
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> import_lookup_table <span style="color:#ff79c6">=</span> table.import_lookup_table_rva.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> import_lookup_table <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(import_lookup_table) };
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// return table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(import_lookup_table);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// gets entry corresponding to import table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_import_address_table</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span>ImportAddressTableR<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// get pointer to ImportLookupTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd;font-style:italic">let</span> import_lookup_table <span style="color:#ff79c6">=</span> self.get_import_lookup_table().unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//  loop thru data directories + find the entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> ImageDataDirectoryEntry::IAT {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ImportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address);
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// cast table to reference to ImportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> table: <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">ImportAddressTable</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { transmute(table) };
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// create ImportAddressTableR struct and fill it with entries from ImportAddressTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> table_r <span style="color:#ff79c6">=</span> ImportAddressTableR::default();
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get count of entries in table by dividing entry.size by size of u64
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> count <span style="color:#ff79c6">=</span> entry.size <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">/</span> core::mem::size_of::<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">u64</span><span style="color:#ff79c6">&gt;</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//  loop thru entries in table and add them to table_r
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">0</span><span style="color:#ff79c6">..</span>count {
</span></span><span style="display:flex;"><span>                    <span style="color:#8be9fd;font-style:italic">let</span> entry <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { table.addresses.get_unchecked(i) };
</span></span><span style="display:flex;"><span>                    <span style="color:#8be9fd;font-style:italic">let</span> import_lookup_table_entry <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">unsafe</span> { import_lookup_table.entry.get_unchecked(i) };
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// if entries are identical, target has not been bound
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#6272a4">// could handle this, but skip it instead
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">*</span>entry <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">*</span>import_lookup_table_entry {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">continue</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// ensure entry is not null
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    assert_ne!(entry <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u64</span> <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">u64</span>, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// create ImportAddressEntry struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#8be9fd;font-style:italic">let</span> entry_r <span style="color:#ff79c6">=</span> ImportAddressEntry {
</span></span><span style="display:flex;"><span>                        iat_entry_address: <span style="color:#50fa7b">entry</span> <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>                        target_function_address: <span style="color:#ff79c6">*</span>entry,
</span></span><span style="display:flex;"><span>                    };
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// add entry to ImportAddressTableR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    table_r.addresses.push(entry_r);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// return table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(table_r);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">is_within_range</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self,
</span></span><span style="display:flex;"><span>        target_type: <span style="color:#50fa7b">ImageDataDirectoryEntry</span>,
</span></span><span style="display:flex;"><span>        address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">bool</span><span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//  loop thru data directories and find the entry with matching type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> entry <span style="color:#ff79c6">in</span> self.<span style="color:#bd93f9">0.</span>iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> entry.name <span style="color:#ff79c6">==</span> target_type {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// get table pointer by converting the RVA32 to actual address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// use .getd the virtual_address base, then cast to ExportDirectoryTable pointer type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> start_addr <span style="color:#ff79c6">=</span> entry.virtual_address.get(entry.base_address) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> end_addr <span style="color:#ff79c6">=</span> start_addr <span style="color:#ff79c6">+</span> entry.size <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(address <span style="color:#ff79c6">&gt;=</span> start_addr <span style="color:#ff79c6">&amp;&amp;</span> address <span style="color:#ff79c6">&lt;</span> end_addr);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define ImageDataDirectory struct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDataDirectory</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_address: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageDataDirectoryInfo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_address: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>()<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name: <span style="color:#50fa7b">ImageDataDirectoryEntry</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ImageDataDirectoryInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// checks if provided usize is within range of this section described by the combination of the base_address and our virtual_address RVA
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">is_within_range</span>(<span style="color:#ff79c6">&amp;</span>self, address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> base_address <span style="color:#ff79c6">=</span> self.base_address;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> virtual_address <span style="color:#ff79c6">=</span> self.virtual_address.get(base_address) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        address <span style="color:#ff79c6">&gt;=</span> virtual_address <span style="color:#ff79c6">&amp;&amp;</span> address <span style="color:#ff79c6">&lt;</span> virtual_address <span style="color:#ff79c6">+</span> self.size <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// export Directory Table as described in PE format
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportDirectoryTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> characteristics: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> time_date_stamp: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> major_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> minor_version: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> ordinal_base: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_functions: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_names: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> export_address_table_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ExportAddressTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name_ptr_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ExportNamePtrTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> ordinal_table_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ExportOrdinalTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define import directory table as described in PE format
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportDirectoryTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> import_lookup_table_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ImportLookupTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> time_date_stamp: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> forwarder_chain: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ASCIIString<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> import_address_table_rva: <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>ImportAddressTable<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define import address table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportAddressTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> addresses: [<span style="color:#8be9fd">u64</span>; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportAddressEntry</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> iat_entry_address: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> target_function_address: <span style="color:#8be9fd">u64</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Default)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportAddressTableR</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> addresses: <span style="color:#8be9fd;font-style:italic">Vec</span><span style="color:#ff79c6">&lt;</span>ImportAddressEntry<span style="color:#ff79c6">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define import lookup table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImportLookupTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> entry: [<span style="color:#8be9fd">u64</span>; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define ExportOrdinalTable (array of u16)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportOrdinalTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> ordinals: [ExportAddressTableIndex; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ExportNamePtrTable is an array of RVA32s to ASCII strings
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportNamePtrTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name_ptr: [RVA32<span style="color:#ff79c6">&lt;</span>ASCIIString<span style="color:#ff79c6">&gt;</span>; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// defines ASCIIString type (null terminated ASCII string)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ASCIIString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> string: [<span style="color:#8be9fd">u8</span>; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ASCIIString {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// enumerates bytes of string until it finds a null byte, returns the length.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// manually count bytes as type has no associated size information
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">len</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> len <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">loop</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>self.string.get_unchecked(len) } <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> len;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            len <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// converts ASCIIString to Rust String
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">to_string</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">String</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> len <span style="color:#ff79c6">=</span> self.len();
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> string <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">String</span>::with_capacity(len);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">0</span><span style="color:#ff79c6">..</span>len {
</span></span><span style="display:flex;"><span>            string.push(<span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>self.string.get_unchecked(i) } <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">char</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        string
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ExportDirectoryTable {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// get entry from the export_address_table_rva by obtaining ExportAddressTable + indexing into it with provided index, checking that index is within bounds based on the number_of_functions field
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_export_address_table_entry</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self,
</span></span><span style="display:flex;"><span>        index: <span style="color:#50fa7b">ExportAddressTableIndex</span>,
</span></span><span style="display:flex;"><span>        base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ExportAddressTableEntry<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> index <span style="color:#ff79c6">=</span> index.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> index <span style="color:#ff79c6">&gt;=</span> self.number_of_functions <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// get underlying ExportAddressTable by applying the base_address to RVA32
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd;font-style:italic">let</span> export_address_table <span style="color:#ff79c6">=</span> self.export_address_table_rva.get(base_address);
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// index into table, use an unchecked index as the table is defined as a 0-size array + and index is checked above
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd;font-style:italic">let</span> entry <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { export_address_table.entries.get_unchecked(index) };
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(entry)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// gets entry from ExportOrdinalTable, similar to how we get entries from ExportAddressTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_export_ordinal_table_entry</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self,
</span></span><span style="display:flex;"><span>        index: <span style="color:#50fa7b">OrdinalTableIndex</span>,
</span></span><span style="display:flex;"><span>        base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>ExportAddressTableIndex<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> index <span style="color:#ff79c6">=</span> index.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> index <span style="color:#ff79c6">&gt;=</span> self.number_of_names <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> export_ordinal_table <span style="color:#ff79c6">=</span> self.ordinal_table_rva.get(base_address);
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(<span style="color:#ff79c6">unsafe</span> { export_ordinal_table.ordinals.get_unchecked(index) })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// enumerates ExportNamePtrTable looking for String match with provided name
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// gets ExportNamePtrTable use the provided base_address, similar to how we get tables in get_export_address_table_entry +get_export_ordinal_table_entry. 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// return value is option around index corresponding to String match found (if any)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_export_name_ptr_table_entry</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>self,
</span></span><span style="display:flex;"><span>        name: <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd">str</span>,
</span></span><span style="display:flex;"><span>        base_address: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span>OrdinalTableIndex<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> export_name_ptr_table <span style="color:#ff79c6">=</span> self.name_ptr_rva.get(base_address);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">0</span><span style="color:#ff79c6">..</span>self.number_of_names {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> export_name_ptr <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">unsafe</span> { export_name_ptr_table.name_ptr.get_unchecked(i <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) };
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> export_name <span style="color:#ff79c6">=</span> export_name_ptr.get(base_address);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> export_name.to_string().to_lowercase() <span style="color:#ff79c6">==</span> name.to_lowercase() {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Some</span>(OrdinalTableIndex(i));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">None</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportAddressTableIndex</span>(<span style="color:#8be9fd">u16</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">OrdinalTableIndex</span>(<span style="color:#8be9fd">u32</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// define ExportAddressTableEntry which is a RVA32 to either a function or a string
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportAddressTableEntry</span>(<span style="color:#ff79c6">pub</span> RVA32<span style="color:#ff79c6">&lt;</span>()<span style="color:#ff79c6">&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ExportAddressTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ExportAddressTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// export address table is array of u32 values
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// size based on number_of_functions field in ExportDirectoryTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> entries: [ExportAddressTableEntry; <span style="color:#bd93f9">0</span>],
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// enum representing ImageDataDirectory entries
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(PartialEq, Eq, Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">ImageDataDirectoryEntry</span> {
</span></span><span style="display:flex;"><span>    ExportTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>    ImportTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>,
</span></span><span style="display:flex;"><span>    ResourceTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>,
</span></span><span style="display:flex;"><span>    ExceptionTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">3</span>,
</span></span><span style="display:flex;"><span>    CertificateTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">4</span>,
</span></span><span style="display:flex;"><span>    BaseRelocationTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">5</span>,
</span></span><span style="display:flex;"><span>    Debug <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">6</span>,
</span></span><span style="display:flex;"><span>    Architecture <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">7</span>,
</span></span><span style="display:flex;"><span>    GlobalPtr <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">8</span>,
</span></span><span style="display:flex;"><span>    TLSTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">9</span>,
</span></span><span style="display:flex;"><span>    LoadConfigTable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">10</span>,
</span></span><span style="display:flex;"><span>    BoundImport <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">11</span>,
</span></span><span style="display:flex;"><span>    IAT <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">12</span>,
</span></span><span style="display:flex;"><span>    DelayImportDescriptor <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">13</span>,
</span></span><span style="display:flex;"><span>    CLRRuntimeHeader <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">14</span>,
</span></span><span style="display:flex;"><span>    Reserved <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">15</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl ImageDataDirectoryEntry to convert index into enum
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> ImageDataDirectoryEntry {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">from_index</span>(index: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span>ImageDataDirectoryEntry<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">match</span> index {
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::ExportTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::ImportTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">2</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::ResourceTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">3</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::ExceptionTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">4</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::CertificateTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">5</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::BaseRelocationTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">6</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::Debug),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">7</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::Architecture),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">8</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::GlobalPtr),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">9</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::TLSTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">10</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::LoadConfigTable),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">11</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::BoundImport),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">12</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::IAT),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">13</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::DelayImportDescriptor),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">14</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::CLRRuntimeHeader),
</span></span><span style="display:flex;"><span>            <span style="color:#bd93f9">15</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">Some</span>(ImageDataDirectoryEntry::Reserved),
</span></span><span style="display:flex;"><span>            _ <span style="color:#ff79c6">=&gt;</span> <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// convert enum into usize index
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">to_index</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">match</span> self {
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::ExportTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::ImportTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">1</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::ResourceTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">2</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::ExceptionTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">3</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::CertificateTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">4</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::BaseRelocationTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">5</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::Debug <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">6</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::Architecture <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">7</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::GlobalPtr <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">8</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::TLSTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">9</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::LoadConfigTable <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">10</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::BoundImport <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">11</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::IAT <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">12</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::DelayImportDescriptor <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">13</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::CLRRuntimeHeader <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">14</span>,
</span></span><span style="display:flex;"><span>            ImageDataDirectoryEntry::Reserved <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">15</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// enum representing valid Windows Subsystem values
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(PartialEq, Eq, Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">WindowsSubsystem</span> {
</span></span><span style="display:flex;"><span>    ImageSubsystemUnknown <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemNative <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemWindowsGui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemWindowsCui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">3</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemOs2Cui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">5</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemPosixCui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">7</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemNativeWindows <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">8</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemWindowsCeGui <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">9</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemEfiApplication <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">10</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemEfiBootServiceDriver <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">11</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemEfiRuntimeDriver <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">12</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemEfiRom <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">13</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemXbox <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">14</span>,
</span></span><span style="display:flex;"><span>    ImageSubsystemWindowsBootApplication <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">16</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bitflags! {
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">/// `SectionCharacteristics` bitflags used to describe characteristics of sections
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">SectionCharacteristics</span>: <span style="color:#8be9fd">u32</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_TYPE_NO_PAD <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000008</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_CNT_CODE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000020</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_CNT_INITIALIZED_DATA <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000040</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000080</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_OTHER <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000100</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_INFO <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000200</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_REMOVE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00000800</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_COMDAT <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00001000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_GPREL <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00008000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_PURGEABLE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00020000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_16BIT <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00020000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_LOCKED <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00040000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_PRELOAD <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00080000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_1BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00100000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_2BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00200000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_4BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00300000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_8BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00400000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_16BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00500000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_32BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00600000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_64BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00700000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_128BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00800000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_256BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00900000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_512BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00A00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_1024BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00B00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_2048BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00C00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_4096BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00D00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_ALIGN_8192BYTES <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00E00000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_LNK_NRELOC_OVFL <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x01000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_DISCARDABLE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x02000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_NOT_CACHED <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x04000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_NOT_PAGED <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x08000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_SHARED <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x10000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_EXECUTE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x20000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_READ <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x40000000</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> IMAGE_SCN_MEM_WRITE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x80000000</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PEB</span> {
</span></span><span style="display:flex;"><span>    junk1: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    junk2: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    junk3: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> ldr: <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> PebLdrData,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ListEntry</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> flink: <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> ListEntry,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> blink: <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> ListEntry,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PebLdrData</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> junk: [<span style="color:#8be9fd">usize</span>; <span style="color:#bd93f9">4</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> in_memory_order_module_list: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">LdrDataTableEntry</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> in_load_order_links: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> in_memory_order_links: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> in_initialization_order_links: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> dll_base: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> entry_point: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_image: <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> full_dll_name: <span style="color:#50fa7b">UnicodeString</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> base_dll_name: <span style="color:#50fa7b">UnicodeString</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> flags: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> load_count: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> tls_index: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> hash_links: <span style="color:#50fa7b">ListEntry</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> time_date_stamp: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">CoffX64Relocation</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_address: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> symbol_table_index: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> typ: <span style="color:#50fa7b">CoffX64RelocationType</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Eq, PartialEq, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">CoffX64RelocationType</span> {
</span></span><span style="display:flex;"><span>    ImageRelAmd64Absolute <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0000</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Addr64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0001</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Addr32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0002</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Addr32nb <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0003</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0004</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel321 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0005</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel322 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0006</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel323 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0007</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel324 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0008</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Rel325 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0009</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Section <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000A</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Secrel <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000B</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Secrel7 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000C</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Token <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000D</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Srel32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000E</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Pair <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000F</span>,
</span></span><span style="display:flex;"><span>    ImageRelAmd64Sspan32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0010</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">SectionHeader</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name: [<span style="color:#8be9fd">u8</span>; <span style="color:#bd93f9">8</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_size: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> virtual_address: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_raw_data: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pointer_to_raw_data: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pointer_to_relocations: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pointer_to_line_numbers: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_relocations: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_line_numbers: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> characteristics: <span style="color:#50fa7b">SectionCharacteristics</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> SectionHeader {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_name</span>(<span style="color:#ff79c6">&amp;</span>self, str_table: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">String</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> self.name[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#39;/&#39;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> offset <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">String</span>::new();
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">1</span><span style="color:#ff79c6">..</span><span style="color:#bd93f9">8</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> self.name[i] <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                offset.push(self.name[i] <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">char</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// convert ASCII representation of offset into u64
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> offset: <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">usize</span>::from_str_radix(<span style="color:#ff79c6">&amp;</span>offset, <span style="color:#bd93f9">10</span>).unwrap();
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// get string from string table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> name_ptr <span style="color:#ff79c6">=</span> offset <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">+</span> str_table;
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Convert name_ptr to a null-terminated str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// collect all bytes in name_ptr until null byte is reached
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> name_bytes <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">Vec</span>::new();
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">loop</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> byte <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>((name_ptr <span style="color:#ff79c6">+</span> name_bytes.len()) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>) };
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> byte <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                name_bytes.push(byte);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// convert the bytes to a str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// **unsafe if object is corrupted
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// safety: remove unwrap + return Result
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">return</span> core::<span style="color:#8be9fd">str</span>::from_utf8(<span style="color:#ff79c6">&amp;</span>name_bytes).unwrap().to_string();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> name <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">String</span>::new();
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#bd93f9">0</span><span style="color:#ff79c6">..</span><span style="color:#bd93f9">8</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> self.name[i] <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            name.push(self.name[i] <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">char</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">ImageFileHeader</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> machine: <span style="color:#50fa7b">ImageFileMachine</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_sections: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> time_date_stamp: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> pointer_to_symbol_table: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_symbols: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> size_of_optional_header: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> characteristics: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> ImageFileHeader {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_symbols</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>[CoffSymbol]<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> self.pointer_to_symbol_table <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> symbol_table_ptr <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>            (base_address <span style="color:#ff79c6">+</span> self.pointer_to_symbol_table <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> CoffSymbol;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> symbol_table <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">unsafe</span> { slice::from_raw_parts(symbol_table_ptr, self.number_of_symbols <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) };
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(symbol_table)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_string_table</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;&amp;</span>[<span style="color:#8be9fd">u8</span>]<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> symbol_table_ptr <span style="color:#ff79c6">=</span> base_address <span style="color:#ff79c6">+</span> self.pointer_to_symbol_table <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table_ptr <span style="color:#ff79c6">=</span> symbol_table_ptr
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">+</span> (self.number_of_symbols <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">*</span> core::mem::size_of::<span style="color:#ff79c6">&lt;</span>CoffSymbol<span style="color:#ff79c6">&gt;</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table_len <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>(str_table_ptr <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u32</span>) } <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> str_table_len <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { slice::from_raw_parts(str_table_ptr <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>, str_table_len) };
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(str_table)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_symbol_name</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>, symbol: <span style="color:#50fa7b">CoffSymbol</span>) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">String</span><span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> symbol_table_ptr <span style="color:#ff79c6">=</span> base_address <span style="color:#ff79c6">+</span> self.pointer_to_symbol_table <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table_ptr <span style="color:#ff79c6">=</span> symbol_table_ptr
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">+</span> (self.number_of_symbols <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">*</span> core::mem::size_of::<span style="color:#ff79c6">&lt;</span>CoffSymbol<span style="color:#ff79c6">&gt;</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> str_table_len <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>(str_table_ptr <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u32</span>) } <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> str_table_len <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">Some</span>(symbol.name.get_name(str_table_ptr))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f1fa8c">/// COFF Symbol table (packed to prevent padding)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">CoffSymbol</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> name: <span style="color:#50fa7b">CoffSymbolName</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> value: <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> section_number: <span style="color:#8be9fd">i16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> type_: <span style="color:#50fa7b">CoffSymbolType</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> storage_class: <span style="color:#50fa7b">CoffSymbolStorageClass</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> number_of_aux_symbols: <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f1fa8c">/// COFF symbol type
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#ff79c6">#[derive(Clone, Copy, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">CoffSymbolType</span> {
</span></span><span style="display:flex;"><span>    ImageSymTypeNull <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0000</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeVoid <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0001</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeChar <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0002</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeShort <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0003</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeInt <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0004</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeLong <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0005</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeFloat <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0006</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeDouble <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0007</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeStruct <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0008</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeUnion <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0009</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeEnum <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000A</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeMoe <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000B</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeByte <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000C</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeWord <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000D</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeUint <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000E</span>,
</span></span><span style="display:flex;"><span>    ImageSymTypeDword <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x000F</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f1fa8c">/// COFF symbol storage class
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#ff79c6">#[derive(Clone, Copy, Debug, Eq, PartialEq)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u8)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">CoffSymbolStorageClass</span> {
</span></span><span style="display:flex;"><span>    ImageSymClassEndOfFunction <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xFF</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassNull <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x00</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassAutomatic <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x01</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassExternal <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x02</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassStatic <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x03</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassRegister <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x04</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassExternalDef <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x05</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassLabel <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x06</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassUndefinedLabel <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x07</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassMemberOfStruct <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x08</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassArgument <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x09</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassStructTag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0A</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassMemberOfUnion <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0B</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassUnionTag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0C</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassTypeDefinition <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0D</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassUndefinedStatic <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0E</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassEnumTag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0F</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassMemberOfEnum <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x10</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassRegisterParam <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x11</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassBitField <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x12</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassBlock <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x64</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassFunction <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x65</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassEndOfStruct <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x66</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassFile <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x67</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassSection <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x68</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassWeakExternal <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x69</span>,
</span></span><span style="display:flex;"><span>    ImageSymClassClrToken <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x6B</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(packed)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">CoffSymbolName</span>(<span style="color:#ff79c6">pub</span> [<span style="color:#8be9fd">u8</span>; <span style="color:#bd93f9">8</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> CoffSymbolName {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_name</span>(<span style="color:#ff79c6">&amp;</span>self, str_table_ptr: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#8be9fd;font-style:italic">String</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> name <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>self.<span style="color:#bd93f9">0</span>[<span style="color:#ff79c6">..</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> name[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> name_offset <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">u32</span>::from_le_bytes(name[<span style="color:#bd93f9">4</span><span style="color:#ff79c6">..</span><span style="color:#bd93f9">8</span>].try_into().unwrap());
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// name_offset + str_table_ptr = UTF8 null-terminated string
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> name_ptr <span style="color:#ff79c6">=</span> name_offset <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">+</span> str_table_ptr;
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// convert name_ptr to null-terminated str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// collect all bytes in name_ptr until null byte is reached
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> name_bytes <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">Vec</span>::new();
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">loop</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> byte <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">*</span>((name_ptr <span style="color:#ff79c6">+</span> name_bytes.len()) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>) };
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> byte <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                name_bytes.push(byte);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// convert bytes to str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// **unsafe, if object is corrupted
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// safety: remove unwrap + return Result
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">return</span> core::<span style="color:#8be9fd">str</span>::from_utf8(<span style="color:#ff79c6">&amp;</span>name_bytes).unwrap().to_string();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// convert first 8 bytes to a str
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd;font-style:italic">let</span> len <span style="color:#ff79c6">=</span> name.iter().position(<span style="color:#ff79c6">|&amp;</span>c<span style="color:#ff79c6">|</span> c <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>).unwrap_or(name.len());
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">String</span>::from_utf8_lossy(<span style="color:#ff79c6">&amp;</span>name[<span style="color:#ff79c6">..</span>len]).to_string()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// enum representing valid ImageFileMachine values
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(PartialEq, Eq, Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(u16)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">ImageFileMachine</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// all possible Machine Types
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    Unknown <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0</span>,
</span></span><span style="display:flex;"><span>    Am33 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1d3</span>,
</span></span><span style="display:flex;"><span>    Amd64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x8664</span>,
</span></span><span style="display:flex;"><span>    Arm <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1c0</span>,
</span></span><span style="display:flex;"><span>    Arm64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xaa64</span>,
</span></span><span style="display:flex;"><span>    ArmNT <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1c4</span>,
</span></span><span style="display:flex;"><span>    Ebc <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xebc</span>,
</span></span><span style="display:flex;"><span>    I386 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x14c</span>,
</span></span><span style="display:flex;"><span>    Ia64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x200</span>,
</span></span><span style="display:flex;"><span>    M32R <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x9041</span>,
</span></span><span style="display:flex;"><span>    Mips16 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x266</span>,
</span></span><span style="display:flex;"><span>    MipsFpu <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x366</span>,
</span></span><span style="display:flex;"><span>    MipsFpu16 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x466</span>,
</span></span><span style="display:flex;"><span>    PowerPC <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1f0</span>,
</span></span><span style="display:flex;"><span>    PowerPCFP <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1f1</span>,
</span></span><span style="display:flex;"><span>    R4000 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x166</span>,
</span></span><span style="display:flex;"><span>    RiscV32 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x5032</span>,
</span></span><span style="display:flex;"><span>    RiscV64 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x5064</span>,
</span></span><span style="display:flex;"><span>    RiscV128 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x5128</span>,
</span></span><span style="display:flex;"><span>    SH3 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1a2</span>,
</span></span><span style="display:flex;"><span>    SH3DSP <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1a3</span>,
</span></span><span style="display:flex;"><span>    SH4 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1a6</span>,
</span></span><span style="display:flex;"><span>    SH5 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1a8</span>,
</span></span><span style="display:flex;"><span>    Thumb <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1c2</span>,
</span></span><span style="display:flex;"><span>    WceMipsV2 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x169</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// constant representing a PE signature, e.g. &#34;PE\0\0&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">const</span> PE_SIGNATURE: <span style="color:#8be9fd">u32</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">u32</span>::from_le_bytes(<span style="color:#ff79c6">*</span><span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;PE</span><span style="color:#f1fa8c">\0\0</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PESignature</span>(<span style="color:#8be9fd">u32</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// implement PESignature + verify sig is valid
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> PESignature {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">is_valid</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">==</span> PE_SIGNATURE
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// RVA32 is a relative virtual address to an underlying type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#[derive(Copy, Clone, Default)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">RVA32</span><span style="color:#ff79c6">&lt;</span>T: <span style="color:#ff79c6">?</span><span style="color:#8be9fd;font-style:italic">Sized</span><span style="color:#ff79c6">&gt;</span>(<span style="color:#ff79c6">pub</span> <span style="color:#8be9fd">u32</span>, <span style="color:#ff79c6">pub</span> core::marker::PhantomData<span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl RVA32 with a function that adds usize base_address then derefs the pointer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span><span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span> RVA32<span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">T</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">&amp;*</span>((base_address <span style="color:#ff79c6">+</span> self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> T) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_mut</span>(<span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">mut</span> self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">mut</span> T {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">mut</span> <span style="color:#ff79c6">*</span>((base_address <span style="color:#ff79c6">+</span> self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">mut</span> T) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Default)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(transparent)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">RVA64</span><span style="color:#ff79c6">&lt;</span>T: <span style="color:#ff79c6">?</span><span style="color:#8be9fd;font-style:italic">Sized</span><span style="color:#ff79c6">&gt;</span>(<span style="color:#ff79c6">pub</span> <span style="color:#8be9fd">u64</span>, <span style="color:#ff79c6">pub</span> core::marker::PhantomData<span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl RVA64 with function that adds usize base_address + then derefs the pointer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span><span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span> RVA64<span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get</span>(<span style="color:#ff79c6">&amp;</span>self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">T</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">&amp;*</span>((base_address <span style="color:#ff79c6">+</span> self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> T) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">get_mut</span>(<span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">mut</span> self, base_address: <span style="color:#8be9fd">usize</span>) -&gt; <span style="color:#ff79c6">&amp;</span><span style="color:#50fa7b">mut</span> T {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">unsafe</span> { <span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">mut</span> <span style="color:#ff79c6">*</span>((base_address <span style="color:#ff79c6">+</span> self.<span style="color:#bd93f9">0</span> <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">mut</span> T) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[derive(Copy, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">UnicodeString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> length: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> maximum_length: <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pub</span> buffer: <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u16</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// impl Default for UnicodeString
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">impl</span> <span style="color:#8be9fd;font-style:italic">Default</span> <span style="color:#ff79c6">for</span> UnicodeString {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">default</span>() -&gt; <span style="color:#50fa7b">Self</span> {
</span></span><span style="display:flex;"><span>        Self {
</span></span><span style="display:flex;"><span>            length: <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>            maximum_length: <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>            buffer: <span style="color:#50fa7b">core</span>::ptr::null(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">impl</span> UnicodeString {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// convert buffer to utf16 string based on length field
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">extract_string</span>(<span style="color:#ff79c6">&amp;</span>self) -&gt; <span style="color:#8be9fd;font-style:italic">Option</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">String</span><span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> self.length <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">||</span> self.buffer <span style="color:#ff79c6">as</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> _ <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">None</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> slice <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">unsafe</span> { slice::from_raw_parts(self.buffer, self.length <span style="color:#ff79c6">as</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2</span>) };
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// convert slice to String
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        core::<span style="color:#8be9fd">char</span>::decode_utf16(slice.iter().cloned())
</span></span><span style="display:flex;"><span>            .collect::<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">Result</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">String</span>, _<span style="color:#ff79c6">&gt;&gt;</span>()
</span></span><span style="display:flex;"><span>            .ok()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>now that we&rsquo;ve mapped + define the structures and layouts of a PE file, as well as how to handle RVAs, we can move ahead with writing our custom minidumper! stay tuned for part 2.</p>
</main>


    <br>
    <hr>
    
      Next: <a href="//localhost:1313/posts/new_post10/">reading list [updated]</a>
    




<footer>
  <div class="footer-nav">
    
    <a class="next" href="/posts/macos-cred-access/" style="float: right"
      >next: credential access in macOS</a
    >
     
    <a class="previous" href="/posts/new_post10/">previous</a>
    
  </div>
</footer>



<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 300),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>